// Package binarylane provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package binarylane

import (
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiTokenScopes = "apiToken.Scopes"
)

// Defines values for AccountStatus.
const (
	AccountStatusActive     AccountStatus = "active"
	AccountStatusIncomplete AccountStatus = "incomplete"
	AccountStatusLocked     AccountStatus = "locked"
	AccountStatusWarning    AccountStatus = "warning"
)

// Defines values for ActionStatus.
const (
	Completed  ActionStatus = "completed"
	Errored    ActionStatus = "errored"
	InProgress ActionStatus = "in-progress"
)

// Defines values for AddDiskType.
const (
	AddDiskTypeAddDisk AddDiskType = "add_disk"
)

// Defines values for AdvancedFirewallRuleAction.
const (
	Accept AdvancedFirewallRuleAction = "accept"
	Drop   AdvancedFirewallRuleAction = "drop"
)

// Defines values for AdvancedFirewallRuleProtocol.
const (
	All  AdvancedFirewallRuleProtocol = "all"
	Icmp AdvancedFirewallRuleProtocol = "icmp"
	Tcp  AdvancedFirewallRuleProtocol = "tcp"
	Udp  AdvancedFirewallRuleProtocol = "udp"
)

// Defines values for AttachBackupType.
const (
	AttachBackupTypeAttachBackup AttachBackupType = "attach_backup"
)

// Defines values for BackupReplacementStrategy.
const (
	BackupReplacementStrategyNewest    BackupReplacementStrategy = "newest"
	BackupReplacementStrategyNone      BackupReplacementStrategy = "none"
	BackupReplacementStrategyOldest    BackupReplacementStrategy = "oldest"
	BackupReplacementStrategySpecified BackupReplacementStrategy = "specified"
)

// Defines values for BackupSlot.
const (
	Daily     BackupSlot = "daily"
	Monthly   BackupSlot = "monthly"
	Temporary BackupSlot = "temporary"
	Weekly    BackupSlot = "weekly"
)

// Defines values for ChangeAdvancedFeaturesType.
const (
	ChangeAdvancedFeaturesTypeChangeAdvancedFeatures ChangeAdvancedFeaturesType = "change_advanced_features"
)

// Defines values for ChangeAdvancedFirewallRulesType.
const (
	ChangeAdvancedFirewallRulesTypeChangeAdvancedFirewallRules ChangeAdvancedFirewallRulesType = "change_advanced_firewall_rules"
)

// Defines values for ChangeBackupScheduleType.
const (
	ChangeBackupScheduleTypeChangeBackupSchedule ChangeBackupScheduleType = "change_backup_schedule"
)

// Defines values for ChangeIpv6Type.
const (
	ChangeIpv6TypeChangeIpv6 ChangeIpv6Type = "change_ipv6"
)

// Defines values for ChangeIpv6ReverseNameserversType.
const (
	ChangeIpv6ReverseNameserversTypeChangeIpv6ReverseNameservers ChangeIpv6ReverseNameserversType = "change_ipv6_reverse_nameservers"
)

// Defines values for ChangeKernelType.
const (
	ChangeKernelTypeChangeKernel ChangeKernelType = "change_kernel"
)

// Defines values for ChangeManageOffsiteBackupCopiesType.
const (
	ChangeManageOffsiteBackupCopiesTypeChangeManageOffsiteBackupCopies ChangeManageOffsiteBackupCopiesType = "change_manage_offsite_backup_copies"
)

// Defines values for ChangeNetworkType.
const (
	ChangeNetworkTypeChangeNetwork ChangeNetworkType = "change_network"
)

// Defines values for ChangeOffsiteBackupLocationType.
const (
	ChangeOffsiteBackupLocationTypeChangeOffsiteBackupLocation ChangeOffsiteBackupLocationType = "change_offsite_backup_location"
)

// Defines values for ChangePartnerType.
const (
	ChangePartnerTypeChangePartner ChangePartnerType = "change_partner"
)

// Defines values for ChangePortBlockingType.
const (
	ChangePortBlockingTypeChangePortBlocking ChangePortBlockingType = "change_port_blocking"
)

// Defines values for ChangeRegionType.
const (
	ChangeRegionTypeChangeRegion ChangeRegionType = "change_region"
)

// Defines values for ChangeReverseNameType.
const (
	ChangeReverseNameTypeChangeReverseName ChangeReverseNameType = "change_reverse_name"
)

// Defines values for ChangeSeparatePrivateNetworkInterfaceType.
const (
	ChangeSeparatePrivateNetworkInterfaceTypeChangeSeparatePrivateNetworkInterface ChangeSeparatePrivateNetworkInterfaceType = "change_separate_private_network_interface"
)

// Defines values for ChangeSourceAndDestinationCheckType.
const (
	ChangeSourceAndDestinationCheckTypeChangeSourceAndDestinationCheck ChangeSourceAndDestinationCheckType = "change_source_and_destination_check"
)

// Defines values for ChangeThresholdAlertsType.
const (
	ChangeThresholdAlertsTypeChangeThresholdAlerts ChangeThresholdAlertsType = "change_threshold_alerts"
)

// Defines values for ChangeVpcIpv4Type.
const (
	ChangeVpcIpv4TypeChangeVpcIpv4 ChangeVpcIpv4Type = "change_vpc_ipv4"
)

// Defines values for CloneUsingBackupType.
const (
	CloneUsingBackupTypeCloneUsingBackup CloneUsingBackupType = "clone_using_backup"
)

// Defines values for DataInterval.
const (
	Day        DataInterval = "day"
	FiveMinute DataInterval = "five-minute"
	FourHour   DataInterval = "four-hour"
	HalfHour   DataInterval = "half-hour"
	Month      DataInterval = "month"
	Week       DataInterval = "week"
)

// Defines values for DeleteDiskType.
const (
	DeleteDiskTypeDeleteDisk DeleteDiskType = "delete_disk"
)

// Defines values for DetachBackupType.
const (
	DetachBackupTypeDetachBackup DetachBackupType = "detach_backup"
)

// Defines values for DisableBackupsType.
const (
	DisableBackupsTypeDisableBackups DisableBackupsType = "disable_backups"
)

// Defines values for DisableSelinuxType.
const (
	DisableSelinuxTypeDisableSelinux DisableSelinuxType = "disable_selinux"
)

// Defines values for DistributionFeature.
const (
	DistributionFeatureRemoteDesktop DistributionFeature = "remote-desktop"
	DistributionFeatureSsh           DistributionFeature = "ssh"
	DistributionFeatureUserData      DistributionFeature = "user-data"
)

// Defines values for DomainRecordType.
const (
	A     DomainRecordType = "A"
	AAAA  DomainRecordType = "AAAA"
	CAA   DomainRecordType = "CAA"
	CNAME DomainRecordType = "CNAME"
	MX    DomainRecordType = "MX"
	NS    DomainRecordType = "NS"
	SOA   DomainRecordType = "SOA"
	SRV   DomainRecordType = "SRV"
	TXT   DomainRecordType = "TXT"
)

// Defines values for EnableBackupsType.
const (
	EnableBackupsTypeEnableBackups EnableBackupsType = "enable_backups"
)

// Defines values for EnableIpv6Type.
const (
	EnableIpv6TypeEnableIpv6 EnableIpv6Type = "enable_ipv6"
)

// Defines values for ImageStatus.
const (
	Available ImageStatus = "available"
	Deleted   ImageStatus = "deleted"
	NEW       ImageStatus = "NEW"
	Pending   ImageStatus = "pending"
)

// Defines values for ImageType.
const (
	Backup   ImageType = "backup"
	Custom   ImageType = "custom"
	Snapshot ImageType = "snapshot"
)

// Defines values for IsRunningType.
const (
	IsRunningTypeIsRunning IsRunningType = "is_running"
)

// Defines values for LoadBalancerRuleProtocol.
const (
	Http  LoadBalancerRuleProtocol = "http"
	Https LoadBalancerRuleProtocol = "https"
)

// Defines values for LoadBalancerStatus.
const (
	LoadBalancerStatusActive  LoadBalancerStatus = "active"
	LoadBalancerStatusErrored LoadBalancerStatus = "errored"
	LoadBalancerStatusNew     LoadBalancerStatus = "new"
)

// Defines values for NetworkType.
const (
	Private NetworkType = "private"
	Public  NetworkType = "public"
)

// Defines values for PasswordRecoveryType.
const (
	Manual        PasswordRecoveryType = "manual"
	OfflineChange PasswordRecoveryType = "offline-change"
	OfflineClear  PasswordRecoveryType = "offline-clear"
	OnlineChange  PasswordRecoveryType = "online-change"
)

// Defines values for PasswordResetType.
const (
	PasswordResetTypePasswordReset PasswordResetType = "password_reset"
)

// Defines values for PaymentMethod.
const (
	CreditCard PaymentMethod = "credit-card"
	Paypal     PaymentMethod = "paypal"
)

// Defines values for PingType.
const (
	PingTypePing PingType = "ping"
)

// Defines values for PowerCycleType.
const (
	PowerCycleTypePowerCycle PowerCycleType = "power_cycle"
)

// Defines values for PowerOffType.
const (
	PowerOffTypePowerOff PowerOffType = "power_off"
)

// Defines values for PowerOnType.
const (
	PowerOnTypePowerOn PowerOnType = "power_on"
)

// Defines values for RebootType.
const (
	RebootTypeReboot RebootType = "reboot"
)

// Defines values for RebuildType.
const (
	RebuildTypeRebuild RebuildType = "rebuild"
)

// Defines values for RenameType.
const (
	RenameTypeRename RenameType = "rename"
)

// Defines values for ResizeType.
const (
	ResizeTypeResize ResizeType = "resize"
)

// Defines values for ResizeDiskType.
const (
	ResizeDiskTypeResizeDisk ResizeDiskType = "resize_disk"
)

// Defines values for ResourceType.
const (
	ResourceTypeImage                ResourceType = "image"
	ResourceTypeLoadBalancer         ResourceType = "load-balancer"
	ResourceTypeRegisteredDomainName ResourceType = "registered-domain-name"
	ResourceTypeServer               ResourceType = "server"
	ResourceTypeSshKey               ResourceType = "ssh-key"
	ResourceTypeVpc                  ResourceType = "vpc"
)

// Defines values for RestoreType.
const (
	RestoreTypeRestore RestoreType = "restore"
)

// Defines values for ServerStatus.
const (
	Active  ServerStatus = "active"
	Archive ServerStatus = "archive"
	New     ServerStatus = "new"
	Off     ServerStatus = "off"
)

// Defines values for ShutdownType.
const (
	ShutdownTypeShutdown ShutdownType = "shutdown"
)

// Defines values for TakeBackupType.
const (
	TakeBackupTypeTakeBackup TakeBackupType = "take_backup"
)

// Defines values for TaxCodeType.
const (
	TaxCodeTypeNone   TaxCodeType = "none"
	TaxCodeTypeScalar TaxCodeType = "scalar"
)

// Defines values for ThresholdAlertType.
const (
	Cpu              ThresholdAlertType = "cpu"
	DataTransferUsed ThresholdAlertType = "data-transfer-used"
	MemoryUsed       ThresholdAlertType = "memory-used"
	NetworkIncoming  ThresholdAlertType = "network-incoming"
	NetworkOutgoing  ThresholdAlertType = "network-outgoing"
	StorageRequests  ThresholdAlertType = "storage-requests"
	StorageUsed      ThresholdAlertType = "storage-used"
)

// Defines values for UncancelType.
const (
	UncancelTypeUncancel UncancelType = "uncancel"
)

// Defines values for UptimeType.
const (
	UptimeTypeUptime UptimeType = "uptime"
)

// Defines values for UserInteractionType.
const (
	AllowUncleanPowerOff     UserInteractionType = "allow-unclean-power-off"
	ContinueAfterPingFailure UserInteractionType = "continue-after-ping-failure"
)

// Defines values for VideoDevice.
const (
	CirrusLogic VideoDevice = "cirrus-logic"
	Standard    VideoDevice = "standard"
	Virtio      VideoDevice = "virtio"
	VirtioWide  VideoDevice = "virtio-wide"
)

// Defines values for VmMachineType.
const (
	PcI440fx1point5  VmMachineType = "pc_i440fx_1point5"
	PcI440fx2point11 VmMachineType = "pc_i440fx_2point11"
	PcI440fx4point1  VmMachineType = "pc_i440fx_4point1"
	PcI440fx4point2  VmMachineType = "pc_i440fx_4point2"
	PcI440fx5point0  VmMachineType = "pc_i440fx_5point0"
	PcI440fx5point1  VmMachineType = "pc_i440fx_5point1"
	PcI440fx7point2  VmMachineType = "pc_i440fx_7point2"
	PcI440fx8point2  VmMachineType = "pc_i440fx_8point2"
)

// Account defines model for Account.
type Account struct {
	// AdditionalIpv4Limit The maximum additional IPv4 addresses this account may assign across all servers. You may contact support to request this limit be increased.
	AdditionalIpv4Limit *int32 `json:"additional_ipv4_limit,omitempty"`

	// ConfiguredPaymentMethods The payment methods that are configured (available) for this account.
	ConfiguredPaymentMethods *[]PaymentMethod `json:"configured_payment_methods,omitempty"`

	// Email The email address registered for this account.
	Email *string `json:"email,omitempty"`

	// EmailVerified Whether this account has been verified. Un-verified accounts are subject to some restrictions.
	EmailVerified *bool `json:"email_verified,omitempty"`

	// Status The status of this account.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | incomplete | An account that exists but is not ready for use. The most common reason for this is a lack of payment information. |
	// | active | An account in the normal state. |
	// | warning | An account that is under review. If you are unsure why your account has this status please urgently contact support. |
	// | locked | An account that is no longer permitted to access the service. |
	//
	Status *AccountStatus `json:"status,omitempty"`

	// TaxCode The tax code that currently applies to transactions for this account.
	TaxCode *TaxCode `json:"tax_code,omitempty"`

	// TwoFactorAuthenticationEnabled Whether this account has enabled two factor authentication.
	TwoFactorAuthenticationEnabled *bool `json:"two_factor_authentication_enabled,omitempty"`
}

// AccountResponse defines model for AccountResponse.
type AccountResponse struct {
	Account *Account `json:"account,omitempty"`
}

// AccountStatus
// | Value | Description |
// | ----- | ----------- |
// | incomplete | An account that exists but is not ready for use. The most common reason for this is a lack of payment information. |
// | active | An account in the normal state. |
// | warning | An account that is under review. If you are unsure why your account has this status please urgently contact support. |
// | locked | An account that is no longer permitted to access the service. |
type AccountStatus string

// Action defines model for Action.
type Action struct {
	// BlockingInvoiceId If this Action is currently blocked by an invoice that requires payment this property will be set.
	BlockingInvoiceId *int64 `json:"blocking_invoice_id"`

	// CompletedAt The timestamp in ISO8601 format of when processing of this action completed. If this value is null the action is currently in progress.
	CompletedAt *time.Time `json:"completed_at"`

	// Id The ID of this action.
	Id *int64 `json:"id,omitempty"`

	// Progress Information about the current progress of the action. Some actions are divided into 'steps' and this may also contain information about the current and completed steps.
	Progress *ActionProgress `json:"progress,omitempty"`

	// Region The region (if any) of the resource associated with this action.
	Region *Region `json:"region"`

	// RegionSlug The region slug (if any) of the resource associated with this action.
	RegionSlug *string `json:"region_slug"`

	// ResourceId The resource id of the resource (if any) associated with this action.
	ResourceId *int64 `json:"resource_id"`

	// ResourceType The resource type (if any) associated with this action.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | server | Server |
	// | load-balancer | Load Balancer |
	// | ssh-key | SSH Key |
	// | vpc | Virtual Private Network |
	// | image | Backup or Operating System Image |
	// | registered-domain-name | Registered Domain Name |
	//
	ResourceType *ResourceType `json:"resource_type"`

	// ResultData Returned information from a completed action. For example: a successful completed 'uptime' action will have the uptime value in this field.
	ResultData *string `json:"result_data"`

	// StartedAt The timestamp in ISO8601 format of when processing of this action started.
	StartedAt *time.Time    `json:"started_at,omitempty"`
	Status    *ActionStatus `json:"status,omitempty"`

	// Type The type of this action.
	Type *string `json:"type,omitempty"`

	// UserInteractionRequired If this is not null the action is waiting on a response from the user.
	UserInteractionRequired *UserInteractionRequired `json:"user_interaction_required"`
}

// ActionLink defines model for ActionLink.
type ActionLink struct {
	Href string  `json:"href"`
	Id   *int64  `json:"id,omitempty"`
	Rel  *string `json:"rel,omitempty"`
}

// ActionProgress defines model for ActionProgress.
type ActionProgress struct {
	// CompletedSteps A list of the completed action steps.
	CompletedSteps *[]string `json:"completed_steps,omitempty"`

	// CurrentStep An description of the current action step.
	CurrentStep *string `json:"current_step"`

	// CurrentStepDetail Detail about the progress of the current step of the action. For example, when creating an offsite backup this may be populated with the current upload speed and completion ETA of the upload step.
	CurrentStepDetail *string `json:"current_step_detail"`

	// PercentComplete An estimation of the overall completion of the action.
	PercentComplete *int32 `json:"percent_complete,omitempty"`
}

// ActionResponse defines model for ActionResponse.
type ActionResponse struct {
	Action *Action `json:"action,omitempty"`
}

// ActionStatus
// | Value | Description |
// | ----- | ----------- |
// | in-progress | This action is currently in progress. |
// | completed | This action has successfully completed. |
// | errored | An error was encountered while processing the action. |
type ActionStatus string

// ActionsLinks defines model for ActionsLinks.
type ActionsLinks struct {
	Actions *[]ActionLink `json:"actions,omitempty"`
}

// ActionsResponse defines model for ActionsResponse.
type ActionsResponse struct {
	Actions *[]Action `json:"actions,omitempty"`
	Links   *Links    `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// AddDisk Create an Additional Disk for a Server
type AddDisk struct {
	// Description An optional description for the disk. If this is null a default description will be added. Submit an empty string to prevent the default description being added.
	Description *string `json:"description"`

	// SizeGigabytes The size of the new disk in GB. The server must have at least this much unallocated storage space.
	SizeGigabytes int32       `json:"size_gigabytes"`
	Type          AddDiskType `json:"type"`
}

// AddDiskType defines model for AddDisk.Type.
type AddDiskType string

// AdvancedFirewallRule defines model for AdvancedFirewallRule.
type AdvancedFirewallRule struct {
	// Action The action to take when there is a match on this rule.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | drop | Traffic matching this rule will be dropped. |
	// | accept | Traffic matching this rule will be accepted. |
	//
	Action AdvancedFirewallRuleAction `json:"action" tfsdk:"action"`

	// Description A description to assist in identifying this rule. Commonly used to record the reason for the rule or the intent behind it, e.g. "Block access to RDP" or "Allow access from HQ".
	Description *string `json:"description" tfsdk:"description"`

	// DestinationAddresses The destination addresses to match for this rule. Each address may be an individual IPv4 address or a range in IPv4 CIDR notation.
	DestinationAddresses []string `json:"destination_addresses" tfsdk:"destination_addresses"`

	// DestinationPorts The destination ports to match for this rule. Leave null or empty to match on all ports.
	DestinationPorts *[]string `json:"destination_ports" tfsdk:"destination_ports"`

	// Protocol The protocol to match for this rule.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | all | This rule will match any protocol. |
	// | icmp | This rule will match ICMP traffic only. |
	// | tcp | This rule will match TCP traffic only. |
	// | udp | This rule will match UDP traffic only. |
	//
	Protocol AdvancedFirewallRuleProtocol `json:"protocol" tfsdk:"protocol"`

	// SourceAddresses The source addresses to match for this rule. Each address may be an individual IPv4 address or a range in IPv4 CIDR notation.
	SourceAddresses []string `json:"source_addresses" tfsdk:"source_addresses"`
}

// AdvancedFirewallRuleAction
// | Value | Description |
// | ----- | ----------- |
// | drop | Traffic matching this rule will be dropped. |
// | accept | Traffic matching this rule will be accepted. |
type AdvancedFirewallRuleAction string

// AdvancedFirewallRuleProtocol
// | Value | Description |
// | ----- | ----------- |
// | all | This rule will match any protocol. |
// | icmp | This rule will match ICMP traffic only. |
// | tcp | This rule will match TCP traffic only. |
// | udp | This rule will match UDP traffic only. |
type AdvancedFirewallRuleProtocol string

// AdvancedFirewallRuleRequest defines model for AdvancedFirewallRuleRequest.
type AdvancedFirewallRuleRequest struct {
	// Action The action to take when there is a match on this rule.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | drop | Traffic matching this rule will be dropped. |
	// | accept | Traffic matching this rule will be accepted. |
	//
	Action AdvancedFirewallRuleAction `json:"action" tfsdk:"action"`

	// Description A description to assist in identifying this rule. Commonly used to record the reason for the rule or the intent behind it, e.g. "Block access to RDP" or "Allow access from HQ".
	Description *string `json:"description" tfsdk:"description"`

	// DestinationAddresses The destination addresses to match for this rule. Each address may be an individual IPv4 address or a range in IPv4 CIDR notation.
	DestinationAddresses []string `json:"destination_addresses" tfsdk:"destination_addresses"`

	// DestinationPorts The destination ports to match for this rule. Leave null or empty to match on all ports.
	DestinationPorts *[]string `json:"destination_ports" tfsdk:"destination_ports"`

	// Protocol The protocol to match for this rule.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | all | This rule will match any protocol. |
	// | icmp | This rule will match ICMP traffic only. |
	// | tcp | This rule will match TCP traffic only. |
	// | udp | This rule will match UDP traffic only. |
	//
	Protocol AdvancedFirewallRuleProtocol `json:"protocol" tfsdk:"protocol"`

	// SourceAddresses The source addresses to match for this rule. Each address may be an individual IPv4 address or a range in IPv4 CIDR notation.
	SourceAddresses []string `json:"source_addresses" tfsdk:"source_addresses"`
}

// AdvancedFirewallRulesResponse defines model for AdvancedFirewallRulesResponse.
type AdvancedFirewallRulesResponse struct {
	// FirewallRules The advanced firewall rules for the selected server. Please note that the order of the rules is critical as the first matching rule is applied, and if no rules match the traffic is permitted.
	FirewallRules []AdvancedFirewallRule `json:"firewall_rules"`
}

// AdvancedServerFeatures defines model for AdvancedServerFeatures.
type AdvancedServerFeatures struct {
	// EnabledAdvancedFeatures A list of the currently enabled advanced features for this server.
	EnabledAdvancedFeatures *[]string `json:"enabled_advanced_features,omitempty"`

	// MachineType The machine_type (corresponding to a KVM version) used for this server.
	// A null value indicates automatic selection of the best KVM machine type supported by the host node.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | pc_i440fx_1point5 | PC i440FX 1.5 |
	// | pc_i440fx_2point11 | PC i440FX 2.11 |
	// | pc_i440fx_4point1 | PC i440FX 4.1 |
	// | pc_i440fx_4point2 | PC i440FX 4.2 |
	// | pc_i440fx_5point0 | PC i440FX 5.0 |
	// | pc_i440fx_5point1 | PC i440FX 5.1 |
	// | pc_i440fx_7point2 | PC i440FX 7.2 |
	// | pc_i440fx_8point2 | PC i440FX 8.2 |
	//
	MachineType *VmMachineType `json:"machine_type"`

	// ProcessorModel The ID of the processor model (and therefore CPU flags) available for this server.
	// A null value indicates automatic selection of the best processor model supported by the host node.
	// This does not change the physical CPU, only the CPU flags available to the operating system.
	ProcessorModel *int64 `json:"processor_model"`

	// VideoDevice Video Device
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | cirrus-logic | Cirrus Logic GD5446 |
	// | standard | Standard VGA with VESA 2.0 extensions |
	// | virtio | Virtio VGA (800x600) |
	// | virtio-wide | Virtio VGA (1600x900) |
	//
	VideoDevice *VideoDevice `json:"video_device,omitempty"`
}

// AttachBackup Attach a Backup to a Server
type AttachBackup struct {
	// Image Only attaching backup images is currently supported.
	Image int64            `json:"image"`
	Type  AttachBackupType `json:"type"`
}

// AttachBackupType defines model for AttachBackup.Type.
type AttachBackupType string

// AttachedBackup defines model for AttachedBackup.
type AttachedBackup struct {
	// AttachedAt The date and time in ISO8601 format when this image was attached to the server.
	AttachedAt *time.Time `json:"attached_at"`

	// AttachmentExpires The date and time in ISO8601 format when the backup will be automatically detached unless it is manually detached earlier.
	AttachmentExpires *time.Time `json:"attachment_expires"`

	// DiskIdentifiers A list of the operating specific disk identifiers for the attached backup disks.
	DiskIdentifiers *[]string `json:"disk_identifiers,omitempty"`

	// Id The ID of the backup image.
	Id *int64 `json:"id,omitempty"`
}

// AvailableAdvancedServerFeatures defines model for AvailableAdvancedServerFeatures.
type AvailableAdvancedServerFeatures struct {
	// AdvancedFeatures A list of the advanced features available for this server.
	AdvancedFeatures *[]string `json:"advanced_features,omitempty"`

	// MachineTypes A list of the machine types available for this server.
	MachineTypes *[]VmMachineType `json:"machine_types,omitempty"`

	// ProcessorModels A list of the processor models available for this server.
	ProcessorModels *[]ProcessorModel `json:"processor_models,omitempty"`
}

// AvailableAdvancedServerFeaturesResponse defines model for AvailableAdvancedServerFeaturesResponse.
type AvailableAdvancedServerFeaturesResponse struct {
	AvailableAdvancedServerFeatures *AvailableAdvancedServerFeatures `json:"available_advanced_server_features,omitempty"`
}

// BackupDisk defines model for BackupDisk.
type BackupDisk struct {
	// Description A description of this disk.
	Description *string `json:"description"`

	// Id The ID of this backup disk.
	Id *int64 `json:"id,omitempty"`

	// MinDiskSize This is the minimum disk size in GB required to restore this disk image.
	MinDiskSize *int32 `json:"min_disk_size,omitempty"`

	// SizeGigabytes This is the compressed size of the disk image in GB.
	SizeGigabytes *float64 `json:"size_gigabytes,omitempty"`
}

// BackupInfo defines model for BackupInfo.
type BackupInfo struct {
	// BackupDisks A list of the individual disks that make up this backup.
	BackupDisks *[]BackupDisk `json:"backup_disks,omitempty"`

	// Iso If this is true the backup is an ISO image and cannot be restored or downloaded. ISO images may only be attached for use as a boot disk or an additional disk.
	Iso *bool `json:"iso,omitempty"`

	// Locked If this is true the backup is locked and cannot be replaced.
	Locked *bool `json:"locked,omitempty"`

	// Offsite If this is true, an attempt to create an offsite copy was made. This does not mean that the offsite copy attempt was successful or that the copy still exists.
	Offsite *bool `json:"offsite,omitempty"`

	// ServerId The server ID that was used to create this backup.
	ServerId *int64      `json:"server_id,omitempty"`
	Type     *BackupSlot `json:"type,omitempty"`
}

// BackupReplacementStrategy
// | Value | Description |
// | ----- | ----------- |
// | none | Do not replace any existing backup: use a free slot of the provided backup type. If there are no free slots an error will occur. |
// | specified | Replace the specific backup id provided. |
// | oldest | Use any free slots of the provided backup type, and if there are no free slots replace the oldest unlocked and un-attached backup of the provided backup type. |
// | newest | Use any free slots of the provided backup type, and if there are no free slots replace the newest unlocked and un-attached backup of the provided backup type. |
type BackupReplacementStrategy string

// BackupSettings defines model for BackupSettings.
type BackupSettings struct {
	// BackupDayOfMonth If monthly backups are enabled the day of the month the monthly backup will occur.
	BackupDayOfMonth *int32 `json:"backup_day_of_month,omitempty"`

	// BackupDayOfWeek If weekly backups are enabled the day of the week that the weekly backup will occur. Sunday is day 0.
	BackupDayOfWeek *int32 `json:"backup_day_of_week,omitempty"`

	// BackupHourOfDay The hour of the day that backups will be scheduled. This is an approximate value.
	BackupHourOfDay *int32 `json:"backup_hour_of_day,omitempty"`

	// OffsiteBackupSettings If offsite backups are enabled this details how they are stored and managed.
	OffsiteBackupSettings *OffsiteBackupSettings `json:"offsite_backup_settings"`
}

// BackupSlot
// | Value | Description |
// | ----- | ----------- |
// | daily | A backup which is scheduled to be taken each day. |
// | weekly | A backup which is scheduled to be taken each week. |
// | monthly | A backup which is scheduled to be taken each month. |
// | temporary | A backup which is created on demand and only retained for a maximum of seven days. |
type BackupSlot string

// BackupWindow defines model for BackupWindow.
type BackupWindow struct {
	// End The expected latest date and time in ISO8601 format of the next scheduled backup.
	// This is not a guarantee that the backup will have started or completed by this date and time.
	End *time.Time `json:"end,omitempty"`

	// Start The approximate earliest start date and time in ISO8601 format of the next scheduled backup.
	Start *time.Time `json:"start,omitempty"`
}

// BackupsResponse defines model for BackupsResponse.
type BackupsResponse struct {
	Backups *[]Image `json:"backups,omitempty"`
	Links   *Links   `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// Balance defines model for Balance.
type Balance struct {
	// AvailableCredit Available credit in AU$.
	AvailableCredit *float64 `json:"available_credit,omitempty"`

	// Charges A list of all of the individual charges that contribute to the un-billed total.
	Charges *[]ChargeInformation `json:"charges,omitempty"`

	// GeneratedAt The timestamp of the most recent charge.
	GeneratedAt *time.Time `json:"generated_at"`

	// UnbilledTotal The total of any un-billed charges in AU$.
	UnbilledTotal *float64 `json:"unbilled_total,omitempty"`
}

// BalanceResponse defines model for BalanceResponse.
type BalanceResponse struct {
	Balance *Balance `json:"balance,omitempty"`
}

// ChangeAdvancedFeatures Change the Advanced Features of a Server
type ChangeAdvancedFeatures struct {
	// AutomaticMachineType Set to true to use best available machine type. If this is provided the machine_type property must not be provided.
	AutomaticMachineType *bool `json:"automatic_machine_type"`

	// AutomaticProcessorModel Set to true to use best available processor model. If this is provided the processor_model property must not be provided.
	AutomaticProcessorModel *bool `json:"automatic_processor_model"`

	// EnabledAdvancedFeatures Do not provide or set to null to keep existing advanced features. Provide an empty array to disable all advanced features, otherwise provide an array with selected advanced features. If provided, any currently enabled advanced features that aren't included will be disabled.
	EnabledAdvancedFeatures *[]string `json:"enabled_advanced_features"`

	// MachineType Do not provide or set to null to keep existing machine type.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | pc_i440fx_1point5 | PC i440FX 1.5 |
	// | pc_i440fx_2point11 | PC i440FX 2.11 |
	// | pc_i440fx_4point1 | PC i440FX 4.1 |
	// | pc_i440fx_4point2 | PC i440FX 4.2 |
	// | pc_i440fx_5point0 | PC i440FX 5.0 |
	// | pc_i440fx_5point1 | PC i440FX 5.1 |
	// | pc_i440fx_7point2 | PC i440FX 7.2 |
	// | pc_i440fx_8point2 | PC i440FX 8.2 |
	//
	MachineType *VmMachineType `json:"machine_type"`

	// ProcessorModel Do not provide or set to null to keep existing processor model.
	ProcessorModel *int64                     `json:"processor_model"`
	Type           ChangeAdvancedFeaturesType `json:"type"`

	// VideoDevice Do not provide or set to null to keep existing video device.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | cirrus-logic | Cirrus Logic GD5446 |
	// | standard | Standard VGA with VESA 2.0 extensions |
	// | virtio | Virtio VGA (800x600) |
	// | virtio-wide | Virtio VGA (1600x900) |
	//
	VideoDevice *VideoDevice `json:"video_device"`
}

// ChangeAdvancedFeaturesType defines model for ChangeAdvancedFeatures.Type.
type ChangeAdvancedFeaturesType string

// ChangeAdvancedFirewallRules Change the Advanced Firewall Rules for a Server
type ChangeAdvancedFirewallRules struct {
	// FirewallRules A list of rules for the server. NB: that any existing rules that are not included will be removed. Submit an empty list to clear all rules.
	FirewallRules []AdvancedFirewallRuleRequest   `json:"firewall_rules"`
	Type          ChangeAdvancedFirewallRulesType `json:"type"`
}

// ChangeAdvancedFirewallRulesType defines model for ChangeAdvancedFirewallRules.Type.
type ChangeAdvancedFirewallRulesType string

// ChangeBackupSchedule Change the Backup Schedule of a Server
type ChangeBackupSchedule struct {
	// BackupDayOfMonth Do not provide a value to keep the current setting.
	BackupDayOfMonth *int32 `json:"backup_day_of_month"`

	// BackupDayOfWeek Sunday is 0, Monday is 1 etc. Do not provide a value to keep the current setting.
	BackupDayOfWeek *int32 `json:"backup_day_of_week"`

	// BackupHourOfDay Do not provide a value to keep the current setting.
	BackupHourOfDay *int32                   `json:"backup_hour_of_day"`
	Type            ChangeBackupScheduleType `json:"type"`
}

// ChangeBackupScheduleType defines model for ChangeBackupSchedule.Type.
type ChangeBackupScheduleType string

// ChangeImage defines model for ChangeImage.
type ChangeImage struct {
	// Image The slug or ID of the selected image. What type of image is permitted here varies based on the server action.
	Image *string `json:"image"`

	// Options Additional options for the server configuration after the image has been changed.
	Options *ImageOptions `json:"options"`
}

// ChangeIpv6 Enable or Disable IPv6 for a Server
type ChangeIpv6 struct {
	// Enabled The desired enabled status of IPv6.
	Enabled bool           `json:"enabled"`
	Type    ChangeIpv6Type `json:"type"`
}

// ChangeIpv6Type defines model for ChangeIpv6.Type.
type ChangeIpv6Type string

// ChangeIpv6ReverseNameservers Update the IPv6 Reverse Name Servers for a Server
type ChangeIpv6ReverseNameservers struct {
	// Ipv6ReverseNameservers A list of all IPv6 reverse name servers for this server. Any existing reverse name servers that are omitted from the list will be removed from the server.
	Ipv6ReverseNameservers []string                         `json:"ipv6_reverse_nameservers"`
	Type                   ChangeIpv6ReverseNameserversType `json:"type"`
}

// ChangeIpv6ReverseNameserversType defines model for ChangeIpv6ReverseNameservers.Type.
type ChangeIpv6ReverseNameserversType string

// ChangeKernel Change the Kernel of a Server
type ChangeKernel struct {
	// Kernel The ID of the kernel to use.
	Kernel int64            `json:"kernel"`
	Type   ChangeKernelType `json:"type"`
}

// ChangeKernelType defines model for ChangeKernel.Type.
type ChangeKernelType string

// ChangeLicenses defines model for ChangeLicenses.
type ChangeLicenses struct {
	// Licenses The desired set of licenses.
	Licenses []License `json:"licenses"`
}

// ChangeManageOffsiteBackupCopies Change the Management of Offsite Backup Copies
type ChangeManageOffsiteBackupCopies struct {
	// ManageOffsiteBackupCopies This only has effect if a custom offsite location is being used: the internal offsite backup location always manages copies. If this is true old offsite backups will be removed once the replacement upload is complete. If this is false backups must be removed from the Amazon S3 bucket manually. Amazon will charge your S3 account at their standard rate for every backup stored.
	ManageOffsiteBackupCopies bool                                `json:"manage_offsite_backup_copies"`
	Type                      ChangeManageOffsiteBackupCopiesType `json:"type"`
}

// ChangeManageOffsiteBackupCopiesType defines model for ChangeManageOffsiteBackupCopies.Type.
type ChangeManageOffsiteBackupCopiesType string

// ChangeNetwork Move a Server to an Existing Network
type ChangeNetwork struct {
	Type ChangeNetworkType `json:"type"`

	// VpcId If this is null the server will be moved into the default public network for the server's region.
	VpcId *int64 `json:"vpc_id"`
}

// ChangeNetworkType defines model for ChangeNetwork.Type.
type ChangeNetworkType string

// ChangeOffsiteBackupLocation Change the Offsite Backup Location of a Server
type ChangeOffsiteBackupLocation struct {
	// OffsiteBackupLocation Do not provide or set to null to use the internal offsite backup location, otherwise this must be a valid Amazon S3 bucket address. If this is provided Amazon will charge your S3 account at their standard rate for every backup stored.
	OffsiteBackupLocation *string                         `json:"offsite_backup_location"`
	Type                  ChangeOffsiteBackupLocationType `json:"type"`
}

// ChangeOffsiteBackupLocationType defines model for ChangeOffsiteBackupLocation.Type.
type ChangeOffsiteBackupLocationType string

// ChangePartner Add, Update or Remove a Partner Server for a Server
type ChangePartner struct {
	// PartnerServerId Leave this null to remove the server partnership. The partner server must be in the same region as the target server.
	PartnerServerId *int64            `json:"partner_server_id"`
	Type            ChangePartnerType `json:"type"`
}

// ChangePartnerType defines model for ChangePartner.Type.
type ChangePartnerType string

// ChangePortBlocking Change the Port Blocking for a Server
type ChangePortBlocking struct {
	// Enabled The desired enabled status for port blocking.
	Enabled bool                   `json:"enabled"`
	Type    ChangePortBlockingType `json:"type"`
}

// ChangePortBlockingType defines model for ChangePortBlocking.Type.
type ChangePortBlockingType string

// ChangeRegion Change the Region of a Server
type ChangeRegion struct {
	// Region The slug of the selected region.
	Region string           `json:"region"`
	Type   ChangeRegionType `json:"type"`
}

// ChangeRegionType defines model for ChangeRegion.Type.
type ChangeRegionType string

// ChangeReverseName Change the Reverse Name for an IPv4 Address on a Server
type ChangeReverseName struct {
	// Ipv4Address The IPv4 address to set or clear the reverse name for.
	Ipv4Address string `json:"ipv4_address"`

	// ReverseName Leave this null to clear the custom reverse name.
	ReverseName *string               `json:"reverse_name"`
	Type        ChangeReverseNameType `json:"type"`
}

// ChangeReverseNameType defines model for ChangeReverseName.Type.
type ChangeReverseNameType string

// ChangeSeparatePrivateNetworkInterface Enable or Disable a Separate Private Network Interface for a Server in a VPC
type ChangeSeparatePrivateNetworkInterface struct {
	// Enabled The desired enabled status of the separate second network interface.
	Enabled bool                                      `json:"enabled"`
	Type    ChangeSeparatePrivateNetworkInterfaceType `json:"type"`
}

// ChangeSeparatePrivateNetworkInterfaceType defines model for ChangeSeparatePrivateNetworkInterface.Type.
type ChangeSeparatePrivateNetworkInterfaceType string

// ChangeSizeOptionsRequest defines model for ChangeSizeOptionsRequest.
type ChangeSizeOptionsRequest struct {
	// DailyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	DailyBackups *int32 `json:"daily_backups"`

	// Disk The total storage in GB for this server.
	// If specified this is the absolute value, not just the additional storage above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values for sizes that do not provide a value for options.restricted_storage_values_gb:
	// - must be a multiple of 5
	// - &gt; 60GB must be a multiple of 10
	// - &gt; 200GB must be a multiple of 100
	Disk *int32 `json:"disk"`

	// Ipv4Addresses The total count of IPv4 addresses for this server. If specified this is the absolute value, not just the additional IPv4 addresses above what is included in the size. Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server. Must not exceed the size.ipv4_addresses_max value.
	Ipv4Addresses *int32 `json:"ipv4_addresses"`

	// Ipv4AddressesToRemove If you are reducing the number of IPv4 addresses you must specify which addresses to remove. If you specify more IPv4 addresses to remove than the number of IPv4 addresses being removed the extra IPv4 addresses will be re-provisioned with new addresses.
	Ipv4AddressesToRemove *[]string `json:"ipv4_addresses_to_remove"`

	// Memory The total memory in MB for this server.
	// If specified this is the absolute value, not just the additional memory above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values:
	// - must be a multiple of 128
	// - &gt; 2048MB must be a multiple of 1024
	// - &gt; 16384MB must be a multiple of 2048
	// - &gt; 24576MB must be a multiple of 4096
	Memory *int32 `json:"memory"`

	// MonthlyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	MonthlyBackups *int32 `json:"monthly_backups"`

	// OffsiteBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	OffsiteBackups *bool `json:"offsite_backups"`

	// Transfer The total transfer per month in TB for this server.
	// If specified this is the absolute value, not just the additional transfer above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values (when converted to GB by multiplying the value provided by 1024):
	// - must be a multiple of 5GB
	// - &gt; 30GB must be a multiple of 10
	// - &gt; 200GB must be a multiple of 100
	// - &gt; 2000GB must be a multiple of 1000
	Transfer *float64 `json:"transfer"`

	// WeeklyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	WeeklyBackups *int32 `json:"weekly_backups"`
}

// ChangeSourceAndDestinationCheck Enable or Disable Network Source and Destination Checks for a Server in a VPC
type ChangeSourceAndDestinationCheck struct {
	// Enabled The desired enabled status of the source and destination checks for network packets.
	Enabled bool                                `json:"enabled"`
	Type    ChangeSourceAndDestinationCheckType `json:"type"`
}

// ChangeSourceAndDestinationCheckType defines model for ChangeSourceAndDestinationCheck.Type.
type ChangeSourceAndDestinationCheckType string

// ChangeThresholdAlerts Set or Update the Threshold Alerts for a Server
type ChangeThresholdAlerts struct {
	// ThresholdAlerts Any alert type not listed will not be updated.
	ThresholdAlerts []ThresholdAlertRequest   `json:"threshold_alerts"`
	Type            ChangeThresholdAlertsType `json:"type"`
}

// ChangeThresholdAlertsType defines model for ChangeThresholdAlerts.Type.
type ChangeThresholdAlertsType string

// ChangeVpcIpv4 Change the IPv4 Address for a Server in a VPC
type ChangeVpcIpv4 struct {
	// CurrentIpv4Address The existing Ipv4 address for the private VPC network adapter you wish to change.
	CurrentIpv4Address string `json:"current_ipv4_address"`

	// NewIpv4Address The new Ipv4 address for the private VPC network adapter.
	NewIpv4Address string            `json:"new_ipv4_address"`
	Type           ChangeVpcIpv4Type `json:"type"`
}

// ChangeVpcIpv4Type defines model for ChangeVpcIpv4.Type.
type ChangeVpcIpv4Type string

// ChargeInformation defines model for ChargeInformation.
type ChargeInformation struct {
	// Created The time when the charge was created.
	Created *time.Time `json:"created,omitempty"`

	// Description A summary of the charge.
	Description *string `json:"description,omitempty"`

	// Ongoing If this is true the charge is for an ongoing service. If this is false the charge is complete and awaiting invoicing.
	Ongoing *bool `json:"ongoing,omitempty"`

	// Total The cost in AU$.
	Total *float64 `json:"total,omitempty"`
}

// CloneUsingBackup Restore a Backup of a Server to a Different Existing Server
type CloneUsingBackup struct {
	// ImageId The ID of the image to clone. Only backup type images are currently supported. This must be a backup of the server ID in the action endpoint URL.
	ImageId int64 `json:"image_id"`

	// Name The new hostname for the target server. If this is not supplied the target server's existing hostname will be used.
	Name *string `json:"name"`

	// TargetServerId The target server ID. This server's current disks will be wiped and replaced with the selected backup image.
	TargetServerId int64                `json:"target_server_id"`
	Type           CloneUsingBackupType `json:"type"`
}

// CloneUsingBackupType defines model for CloneUsingBackup.Type.
type CloneUsingBackupType string

// Console defines model for Console.
type Console struct {
	// Browser The URL for the full screen and full featured version of the console.
	Browser *string `json:"browser,omitempty"`

	// Expiry The expiry time of the provided URLs.
	Expiry *time.Time `json:"expiry,omitempty"`

	// Height Rescue console native height.
	Height *int32 `json:"height,omitempty"`

	// Iframe The URL for the embedded version of the console.
	Iframe *string `json:"iframe,omitempty"`

	// Width Rescue console native width.
	Width *int32 `json:"width,omitempty"`
}

// ConsoleResponse defines model for ConsoleResponse.
type ConsoleResponse struct {
	Console *Console `json:"console,omitempty"`
}

// CreateLoadBalancerRequest defines model for CreateLoadBalancerRequest.
type CreateLoadBalancerRequest struct {
	// ForwardingRules The rules that control which traffic the load balancer will forward to servers in the pool. Leave null to accept a default "HTTP" only forwarding rule.
	ForwardingRules *[]ForwardingRule `json:"forwarding_rules" tfsdk:"forwarding_rules"`

	// HealthCheck The rules that determine which servers are considered 'healthy' and in the server pool for the load balancer. Leave this null to accept appropriate defaults based on the forwarding_rules.
	HealthCheck *HealthCheck `json:"health_check"`

	// Name The hostname of the load balancer.
	Name string `json:"name"`

	// Region Leave null to create an anycast load balancer.
	Region *string `json:"region"`

	// ServerIds A list of server IDs to assign to this load balancer.
	ServerIds *[]int64 `json:"server_ids"`
}

// CreateLoadBalancerResponse defines model for CreateLoadBalancerResponse.
type CreateLoadBalancerResponse struct {
	Links        *ActionsLinks `json:"links,omitempty"`
	LoadBalancer *LoadBalancer `json:"load_balancer,omitempty"`
}

// CreateServerRequest defines model for CreateServerRequest.
type CreateServerRequest struct {
	// Backups If true this will enable two daily backups for the server. Options.daily_backups will override this value if provided. Setting this to false has no effect.
	Backups *bool `json:"backups"`

	// Image The slug or id of the selected operating system.
	Image string `json:"image"`

	// Ipv6 If true this will enable IPv6 for this server.
	Ipv6 *bool `json:"ipv6"`

	// Licenses The desired set of licenses.
	Licenses *[]License `json:"licenses"`

	// Name The hostname of your server, such as vps01.yourcompany.com. If not provided, the server will be created with a random name.
	Name *string `json:"name"`

	// Options This may be left null to accept all of the defaults for the selected size.
	Options *SizeOptionsRequest `json:"options"`

	// Password If this is provided the default remote user account's password will be set to this value. If this is null a random password will be generated and emailed to the account email address.
	Password *string `json:"password"`

	// PortBlocking Port blocking of outgoing connections for email, SSH and Remote Desktop (TCP ports 22, 25, and 3389) is enabled by default for all new servers. If this is false port blocking will be disabled. Disabling port blocking is only available to reviewed accounts.
	PortBlocking *bool `json:"port_blocking"`

	// Region The slug of the selected region.
	Region string `json:"region"`

	// Size The slug of the selected size.
	Size string `json:"size"`

	// SshKeys This may be either the SSH keys Ids or fingerprints. If this is null or not provided any SSH keys that have been marked as default will be deployed (if the operating system supports SSH keys). Submit an empty array to disable deployment of default keys.
	SshKeys *[]int `json:"ssh_keys"`

	// UserData If provided this will be used to initialise the new server. This must be left null if the Image does not support UserData, see DistributionInfo.Features for more information.
	UserData *string `json:"user_data"`

	// VpcId Leave null to use default (public) network for the selected region.
	VpcId *int64 `json:"vpc_id"`
}

// CreateServerResponse defines model for CreateServerResponse.
type CreateServerResponse struct {
	Links  *ActionsLinks `json:"links,omitempty"`
	Server *Server       `json:"server,omitempty"`
}

// CreateVpcRequest defines model for CreateVpcRequest.
type CreateVpcRequest struct {
	// IpRange A private address range that you select during creation, such as the default value of 10.240.0.0/16. Because the virtual network is dedicated to your use, you may use whatever IP address range you like.
	IpRange *string `json:"ip_range"`

	// Name A name to help identify this VPC.
	Name string `json:"name"`

	// RouteEntries The route entries that control how network traffic is directed through the VPC environment.
	RouteEntries *[]RouteEntryRequest `json:"route_entries"`
}

// CurrentServerAlertsResponse defines model for CurrentServerAlertsResponse.
type CurrentServerAlertsResponse struct {
	ServerIds *[]int64 `json:"server_ids,omitempty"`
}

// DataInterval
// | Value | Description |
// | ----- | ----------- |
// | five-minute | 5 Minutes |
// | half-hour | 30 Minutes |
// | four-hour | 4 Hours |
// | day | 1 Day |
// | week | 7 Days |
// | month | 1 Month |
type DataInterval string

// DataUsage defines model for DataUsage.
type DataUsage struct {
	// CurrentTransferUsageGigabytes The used data transfer for this server in this period in GB.
	// If you have more than one server, please see our data pooling policy: this value may include excess data transfer used by other servers or may have 'offloaded' excess data transfer to other servers with spare capacity.
	CurrentTransferUsageGigabytes *float64 `json:"current_transfer_usage_gigabytes,omitempty"`

	// Expires The date and time in ISO8601 format that the current billing period expires.
	Expires *time.Time `json:"expires,omitempty"`

	// ServerId The ID of the server that this data transfer usage refers to.
	ServerId *int64 `json:"server_id,omitempty"`

	// TransferGigabytes The included data transfer for this server in this period in GB.
	TransferGigabytes *int64 `json:"transfer_gigabytes,omitempty"`

	// TransferPeriodEnd The date and time in ISO8601 format that the data transfer limit period ended (if it is completed) or when it will end (if this is the current period).
	TransferPeriodEnd *time.Time `json:"transfer_period_end,omitempty"`
}

// DataUsageResponse defines model for DataUsageResponse.
type DataUsageResponse struct {
	DataUsage DataUsage `json:"data_usage"`
}

// DataUsagesResponse defines model for DataUsagesResponse.
type DataUsagesResponse struct {
	DataUsages *[]DataUsage `json:"data_usages,omitempty"`
	Links      *Links       `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// DeleteDisk Delete an Additional Disk for a Server
type DeleteDisk struct {
	// DiskId The ID of the existing disk. See server.disks for a list of IDs.
	DiskId int64          `json:"disk_id"`
	Type   DeleteDiskType `json:"type"`
}

// DeleteDiskType defines model for DeleteDisk.Type.
type DeleteDiskType string

// DetachBackup Detach Any Attached Backup from a Server
type DetachBackup struct {
	Type DetachBackupType `json:"type"`
}

// DetachBackupType defines model for DetachBackup.Type.
type DetachBackupType string

// DisableBackups Disable Backups for an Existing Server
type DisableBackups struct {
	Type DisableBackupsType `json:"type"`
}

// DisableBackupsType defines model for DisableBackups.Type.
type DisableBackupsType string

// DisableSelinux Disable SE Linux for a Server
type DisableSelinux struct {
	Type DisableSelinuxType `json:"type"`
}

// DisableSelinuxType defines model for DisableSelinux.Type.
type DisableSelinuxType string

// Disk defines model for Disk.
type Disk struct {
	// Description A description of this disk.
	Description *string `json:"description"`

	// Id The ID of this disk.
	Id *int64 `json:"id,omitempty"`

	// Primary A primary disk is treated differently from other disks.
	Primary *bool `json:"primary,omitempty"`

	// SizeGigabytes The size of the disk in GB.
	SizeGigabytes *float64 `json:"size_gigabytes,omitempty"`
}

// DistributionFeature
// | Value | Description |
// | ----- | ----------- |
// | ssh | Initial install supports SSH connections and SSH keys. |
// | remote-desktop | Initial install supports Remote Desktop (RDP) connections. |
// | user-data | Initial install supports cloud-init user-data. |
type DistributionFeature string

// DistributionInfo defines model for DistributionInfo.
type DistributionInfo struct {
	// Features Features supported by this distribution.
	Features *[]DistributionFeature `json:"features,omitempty" tfsdk:"features"`

	// ImageId If this is a backup image, the operating system ID of the server at the time the backup was created.
	ImageId *int64 `json:"image_id,omitempty" tfsdk:"image_id"`

	// PasswordRecovery Supported methods of password recovery.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | manual | Password must be reset manually using the recovery console and rescue disk. |
	// | offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |
	// | offline-change | Password can be reset and new credentials sent (Requires restart). |
	// | online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |
	//
	PasswordRecovery *PasswordRecoveryType `json:"password_recovery,omitempty" tfsdk:"password_recovery"`

	// RemoteAccessUser User name to use when connecting via remote access (RDP or SSH).
	RemoteAccessUser *string `json:"remote_access_user" tfsdk:"remote_access_user"`
}

// DistributionSurcharges defines model for DistributionSurcharges.
type DistributionSurcharges struct {
	// SurchargeBaseCost The additional cost for using this operating system as the base image for a size.
	SurchargeBaseCost *float64 `json:"surcharge_base_cost" tfsdk:"surcharge_base_cost"`

	// SurchargeMinVcpu The minimum vcpu count for surcharge calculations.
	SurchargeMinVcpu *int32 `json:"surcharge_min_vcpu" tfsdk:"surcharge_min_vcpu"`

	// SurchargePerMemoryMaxMegabytes The maximum memory in MB that counts towards the surcharge_per_memory_mb. Any memory above this cap does not attract the surcharge.
	SurchargePerMemoryMaxMegabytes *int32 `json:"surcharge_per_memory_max_megabytes" tfsdk:"surcharge_per_memory_max_megabytes"`

	// SurchargePerMemoryMegabyte The additional cost per MB for using this operating system as the base image for a size.
	SurchargePerMemoryMegabyte *float64 `json:"surcharge_per_memory_megabyte" tfsdk:"surcharge_per_memory_megabyte"`

	// SurchargePerVcpu The additional cost per vcpu for using this operating system as the base image for a size.
	SurchargePerVcpu *float64 `json:"surcharge_per_vcpu" tfsdk:"surcharge_per_vcpu"`
}

// Domain defines model for Domain.
type Domain struct {
	// CurrentNameservers The current authoritative name servers for this domain.
	CurrentNameservers *[]string `json:"current_nameservers,omitempty"`

	// Id The ID of this domain.
	Id *int64 `json:"id,omitempty"`

	// Name The name of the domain.
	Name *string `json:"name,omitempty"`

	// Ttl The time to live for records in this domain in seconds. If the DNS records for this domain are not managed locally this will be what the TTL would be if the authority was delegated to us.
	Ttl *int32 `json:"ttl"`

	// ZoneFile The zone file for the selected domain. If the DNS records for this domain are not managed locally this is what the zone file would be if the authority was delegated to us.
	ZoneFile *string `json:"zone_file,omitempty"`
}

// DomainRecord defines model for DomainRecord.
type DomainRecord struct {
	// Data Variable data depending on record type.
	Data *string `json:"data"`

	// Flags An unsigned integer between 0-255 that is only relevant for CAA records.
	Flags *int32 `json:"flags"`

	// Id The ID of this domain record.
	Id *int64 `json:"id,omitempty"`

	// Name The subdomain, alias, or service defined by the record.
	Name *string `json:"name,omitempty"`

	// Port A port value that is only relevant for SRV records.
	Port *int32 `json:"port"`

	// Priority A priority value that is only relevant for SRV and MX records.
	Priority *int32 `json:"priority"`

	// Tag A parameter tag that is only relevant for CAA records.
	Tag *string `json:"tag"`

	// Ttl This value is the time to live for the record in seconds.
	Ttl *int32 `json:"ttl,omitempty"`

	// Type A general data field that has different functions depending on the record type.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | A | Map an IPv4 address to a hostname. |
	// | AAAA | Map an IPv6 address to a hostname. |
	// | CAA | Restrict which certificate authorities are permitted to issue certificates for a domain. |
	// | CNAME | Define an alias for your canonical hostname. |
	// | MX | Define the mail exchanges that handle mail for the domain. |
	// | NS | Define the nameservers that manage the domain. |
	// | SOA | The Start of Authority record for the zone. |
	// | SRV | Specify a server by hostname and port to handle a service or services. |
	// | TXT | Define a string of text that is associated with a hostname. |
	//
	Type *DomainRecordType `json:"type,omitempty"`

	// Weight The weight value that is only relevant for SRV records.
	Weight *int32 `json:"weight"`
}

// DomainRecordRequest defines model for DomainRecordRequest.
type DomainRecordRequest struct {
	// Data A general data field that has different functions depending on the record type.
	Data string `json:"data"`

	// Flags An unsigned integer between 0-255 that is only relevant for CAA records.
	Flags *int32 `json:"flags"`

	// Name The subdomain for this record. Use @ for records on the domain itself, and * to create a wildcard record.
	Name string `json:"name"`

	// Port A port value that is only relevant for SRV records.
	Port *int32 `json:"port"`

	// Priority A priority value that is only relevant for SRV and MX records.
	Priority *int32 `json:"priority"`

	// Tag A parameter tag that is only relevant for CAA records.
	Tag *string `json:"tag"`

	// Ttl This value is the time to live for the record, in seconds. The default and only supported value is 3600. Leave null to accept this default.
	Ttl *int32 `json:"ttl"`

	// Type The type of the DNS record.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | A | Map an IPv4 address to a hostname. |
	// | AAAA | Map an IPv6 address to a hostname. |
	// | CAA | Restrict which certificate authorities are permitted to issue certificates for a domain. |
	// | CNAME | Define an alias for your canonical hostname. |
	// | MX | Define the mail exchanges that handle mail for the domain. |
	// | NS | Define the nameservers that manage the domain. |
	// | SOA | The Start of Authority record for the zone. |
	// | SRV | Specify a server by hostname and port to handle a service or services. |
	// | TXT | Define a string of text that is associated with a hostname. |
	//
	Type DomainRecordType `json:"type"`

	// Weight The weight value that is only relevant for SRV records.
	Weight *int32 `json:"weight"`
}

// DomainRecordResponse defines model for DomainRecordResponse.
type DomainRecordResponse struct {
	DomainRecord *DomainRecord `json:"domain_record,omitempty"`
}

// DomainRecordType
// | Value | Description |
// | ----- | ----------- |
// | A | Map an IPv4 address to a hostname. |
// | AAAA | Map an IPv6 address to a hostname. |
// | CAA | Restrict which certificate authorities are permitted to issue certificates for a domain. |
// | CNAME | Define an alias for your canonical hostname. |
// | MX | Define the mail exchanges that handle mail for the domain. |
// | NS | Define the nameservers that manage the domain. |
// | SOA | The Start of Authority record for the zone. |
// | SRV | Specify a server by hostname and port to handle a service or services. |
// | TXT | Define a string of text that is associated with a hostname. |
type DomainRecordType string

// DomainRecordsResponse defines model for DomainRecordsResponse.
type DomainRecordsResponse struct {
	DomainRecords *[]DomainRecord `json:"domain_records,omitempty"`
	Links         *Links          `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// DomainRefreshRequest defines model for DomainRefreshRequest.
type DomainRefreshRequest struct {
	// DomainNames The domain names to refresh.
	DomainNames []string `json:"domain_names"`
}

// DomainRequest defines model for DomainRequest.
type DomainRequest struct {
	// IpAddress An optional IPv4 address that will be used to create an A record for the root domain.
	IpAddress *string `json:"ip_address"`

	// Name The domain name to add to the DNS management system.
	Name string `json:"name"`
}

// DomainResponse defines model for DomainResponse.
type DomainResponse struct {
	Domain *Domain `json:"domain,omitempty"`
}

// DomainsResponse defines model for DomainsResponse.
type DomainsResponse struct {
	Domains *[]Domain `json:"domains,omitempty"`
	Links   *Links    `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// EnableBackups Enable Two Daily Backups for an Existing Server
type EnableBackups struct {
	Type EnableBackupsType `json:"type"`
}

// EnableBackupsType defines model for EnableBackups.Type.
type EnableBackupsType string

// EnableIpv6 Enable IPv6 for a Server
type EnableIpv6 struct {
	Type EnableIpv6Type `json:"type"`
}

// EnableIpv6Type defines model for EnableIpv6.Type.
type EnableIpv6Type string

// ForwardingRule defines model for ForwardingRule.
type ForwardingRule struct {
	// EntryProtocol The protocol that traffic must match for the load balancer to forward it. Valid values are "http" and "https".
	EntryProtocol LoadBalancerRuleProtocol `json:"entry_protocol" tfsdk:"entry_protocol"`
}

// ForwardingRulesRequest defines model for ForwardingRulesRequest.
type ForwardingRulesRequest struct {
	// ForwardingRules The rules that control which traffic the load balancer will forward to servers in the pool.
	ForwardingRules []ForwardingRule `json:"forwarding_rules"`
}

// HealthCheck defines model for HealthCheck.
type HealthCheck struct {
	// Path Leave null to accept the default '/' path.
	Path *string `json:"path"`

	// Protocol Leave null to accept the default HTTP protocol.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | http | The health check will be performed via HTTP. |
	// | https | The health check will be performed via HTTPS. |
	// | both | The health check will be performed via both HTTP and HTTPS. Failing a health check on one protocol will remove the server from the pool of servers only for that protocol. |
	//
	Protocol *HealthCheckProtocol `json:"protocol"`
}

// HealthCheckProtocol
// | Value | Description |
// | ----- | ----------- |
// | http | The health check will be performed via HTTP. |
// | https | The health check will be performed via HTTPS. |
// | both | The health check will be performed via both HTTP and HTTPS. Failing a health check on one protocol will remove the server from the pool of servers only for that protocol. |
type HealthCheckProtocol = string

// Host defines model for Host.
type Host struct {
	// DisplayName The name for this host. If this is a dedicated host this property will be empty.
	DisplayName *string `json:"display_name,omitempty"`

	// StatusPage This is the URL of the status page of the host. This will normally only be set if the host is under maintenance.
	StatusPage *string `json:"status_page"`

	// UptimeMs The current uptime in milliseconds of this host.
	UptimeMs *int64 `json:"uptime_ms"`
}

// Image defines model for Image.
type Image struct {
	// BackupInfo If this image is a backup, this object will provide further information.
	BackupInfo *BackupInfo `json:"backup_info" tfsdk:"backup_info"`

	// CreatedAt If this is a backup image this is the date and time in ISO8601 format when the image was created.
	CreatedAt *time.Time `json:"created_at" tfsdk:"created_at"`

	// Description A description that may provide further details or warnings about the image.
	Description *string `json:"description" tfsdk:"description"`

	// Distribution If this is an operating system image, this is the name of the distribution. If this is a backup image, this is the name of the distribution the server is using.
	Distribution *string `json:"distribution" tfsdk:"distribution"`

	// DistributionInfo This object may provide further information about the distribution.
	DistributionInfo *DistributionInfo `json:"distribution_info,omitempty" tfsdk:"distribution_info"`

	// DistributionSurcharges If this is not null the use of this image may incur surcharges above the base cost of the server. All costs are in AU$.
	DistributionSurcharges *DistributionSurcharges `json:"distribution_surcharges" tfsdk:"distribution_surcharges"`

	// ErrorMessage If the image creation failed this may provide further information.
	ErrorMessage *string `json:"error_message" tfsdk:"error_message"`

	// FullName If this is an operating system image, this is the name and version of the distribution. If this is a backup image, this is the server hostname and label of the backup if it exists, otherwise it is the server hostname and UTC timestamp of the creation of the image.
	FullName *string `json:"full_name" tfsdk:"full_name"`

	// Id The ID of this image.
	Id *int64 `json:"id,omitempty" tfsdk:"id"`

	// MinDiskSize For a distribution image this is the minimum disk size in GB required to install the operating system. For a backup image this is the minimum total disk size in GB required to restore the backup.
	MinDiskSize *int32 `json:"min_disk_size,omitempty" tfsdk:"min_disk_size"`

	// MinMemoryMegabytes This is minimum memory in MB necessary to support this operating system (or the base operating system for a backup image).
	MinMemoryMegabytes *int32 `json:"min_memory_megabytes" tfsdk:"min_memory_megabytes"`

	// Name If this is an operating system image, this is the name of the operating system version. If this is a backup image, this is the label of the backup if it exists, otherwise it is the UTC timestamp of the creation of the image.
	Name *string `json:"name,omitempty" tfsdk:"name"`

	// Public A public image is available to all users. A private image is available only to the account that created the image.
	Public *bool `json:"public,omitempty" tfsdk:"public"`

	// Regions The slugs of the regions where the image is available for use.
	Regions *[]string `json:"regions,omitempty" tfsdk:"regions"`

	// SizeGigabytes For a distribution image this is the disk size used in GB by the operating system on initial install. For a backup image this is the size of the compressed backup image in GB.
	SizeGigabytes *float64 `json:"size_gigabytes,omitempty" tfsdk:"size_gigabytes"`

	// Slug If this is an operating system image this is a slug which may be used as an alternative to the ID as a reference.
	Slug   *string      `json:"slug" tfsdk:"slug"`
	Status *ImageStatus `json:"status,omitempty" tfsdk:"status"`
	Type   *ImageType   `json:"type,omitempty" tfsdk:"type"`
}

// ImageDiskDownload defines model for ImageDiskDownload.
type ImageDiskDownload struct {
	// CompressedUrl The URL of the compressed disk image. It is always preferable to download the compressed disk image if at all possible.
	CompressedUrl string `json:"compressed_url"`

	// Id The ID of this backup disk.
	Id int64 `json:"id"`

	// RawUrl The URL of the raw (uncompressed) disk image.
	RawUrl string `json:"raw_url"`
}

// ImageDownload defines model for ImageDownload.
type ImageDownload struct {
	// Disks A list of objects containing the download URLs for each disk in the image.
	Disks *[]ImageDiskDownload `json:"disks,omitempty"`

	// Expiry The date and time in ISO8601 format that this download URL will expire.
	Expiry *time.Time `json:"expiry,omitempty"`

	// Id The ID of the image this download object refers to.
	Id *int64 `json:"id,omitempty"`
}

// ImageDownloadResponse defines model for ImageDownloadResponse.
type ImageDownloadResponse struct {
	Link *ImageDownload `json:"link,omitempty"`
}

// ImageOptions defines model for ImageOptions.
type ImageOptions struct {
	// Name The hostname for the server. Leave null to accept the auto-generated permalink.
	Name *string `json:"name"`

	// Password If this is provided the default remote user account's password will be set to this value. If this is null a random password will be generated and emailed to the account email address.
	Password *string `json:"password"`

	// SshKeys This may be either the existing SSH Keys IDs or fingerprints.
	// If this is null or not provided any SSH keys that have been marked as default will be deployed (if the operating system supports SSH Keys).
	// Submit an empty array to disable deployment of default keys.
	SshKeys *[]int `json:"ssh_keys"`

	// UserData If provided this will be used to initialise the new server. This must be left null if the Image does not support UserData, see DistributionInfo.Features for more information.
	UserData *string `json:"user_data"`
}

// ImageResponse defines model for ImageResponse.
type ImageResponse struct {
	Image Image `json:"image"`
}

// ImageStatus
// | Value | Description |
// | ----- | ----------- |
// | NEW | The image is new. |
// | available | The image is available for use. |
// | pending | The image is pending and is not yet available for use. |
// | deleted | The image has been deleted and is no longer available for use. |
type ImageStatus string

// ImageType
// | Value | Description |
// | ----- | ----------- |
// | custom | An image uploaded by a user. |
// | snapshot | A snapshot. Snapshot creation is not currently supported so only distribution images will have this value. |
// | backup | A backup of a server. |
type ImageType string

// ImagesResponse defines model for ImagesResponse.
type ImagesResponse struct {
	Images *[]Image `json:"images,omitempty"`
	Links  *Links   `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	// Amount The amount of the invoice in AU$.
	Amount *float64 `json:"amount,omitempty"`

	// Created The date in ISO8601 format this invoice was created.
	Created *time.Time `json:"created,omitempty"`

	// DateDue The date in ISO8601 format this invoice is due for payment.
	DateDue *time.Time `json:"date_due,omitempty"`

	// DateOverdue The date in ISO8601 format this invoice is considered overdue.
	DateOverdue *time.Time `json:"date_overdue,omitempty"`

	// InvoiceDownloadUrl The download URL for the rendered version of the invoice.
	InvoiceDownloadUrl *string `json:"invoice_download_url"`

	// InvoiceId The ID of the invoice.
	InvoiceId *int64 `json:"invoice_id,omitempty"`

	// InvoiceItems The individual items that make up invoice.
	InvoiceItems *[]InvoiceLineItem `json:"invoice_items,omitempty"`

	// InvoiceNumber The invoice number for this invoice.
	InvoiceNumber *string `json:"invoice_number,omitempty"`

	// Paid If this is true the invoice has been paid.
	Paid *bool `json:"paid,omitempty"`

	// PaymentFailureCount If this is included it indicates the number of failed attempts at processing payment for this invoice that have occurred.
	PaymentFailureCount *int32 `json:"payment_failure_count"`

	// Reference The reference for this invoice. If this invoice is for a single service this may identify the service, otherwise it will be the account reference.
	Reference *string `json:"reference"`

	// Refunded If this is true the payment for this invoice has been refunded.
	Refunded *bool `json:"refunded,omitempty"`

	// Tax The amount of tax (if any) that was charged on the transactions on this invoice.
	Tax *float64 `json:"tax,omitempty"`

	// TaxCode The tax code that was applied to transactions on this invoice.
	TaxCode *TaxCode `json:"tax_code,omitempty"`
}

// InvoiceLineItem defines model for InvoiceLineItem.
type InvoiceLineItem struct {
	// Amount The charge in AU$ for this item. A negative value indicates a discount or credit.
	Amount *float64 `json:"amount,omitempty"`

	// AmountIncludesTax If this is true the line item amount includes (if applicable) whatever tax was applied (see invoice.tax_code for details) and the total of the line items on this invoice will match the invoice.amount.
	// If this is false the line item amount does not include any applicable tax and the total of the line items on this invoice will be the invoice.amount less invoice.tax.
	AmountIncludesTax *bool `json:"amount_includes_tax,omitempty"`

	// Name A description of the item.
	Name *string `json:"name,omitempty"`
}

// InvoiceResponse defines model for InvoiceResponse.
type InvoiceResponse struct {
	Invoice *Invoice `json:"invoice,omitempty"`
}

// InvoicesResponse defines model for InvoicesResponse.
type InvoicesResponse struct {
	Invoices *[]Invoice `json:"invoices,omitempty"`
	Links    *Links     `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// IsRunning Check if a Server is Running
type IsRunning struct {
	Type IsRunningType `json:"type"`
}

// IsRunningType defines model for IsRunning.Type.
type IsRunningType string

// Kernel defines model for Kernel.
type Kernel struct {
	// Id The ID of this kernel.
	Id int64 `json:"id"`

	// Name This name of this kernel.
	Name *string `json:"name"`

	// Version The version (if any) of this kernel.
	Version *string `json:"version"`
}

// KernelsResponse defines model for KernelsResponse.
type KernelsResponse struct {
	Kernels *[]Kernel `json:"kernels,omitempty"`
	Links   *Links    `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// License defines model for License.
type License struct {
	// Count The number of licences.
	Count int32 `json:"count"`

	// SoftwareId The ID of the software to license.
	SoftwareId int64 `json:"software_id"`
}

// LicensedSoftware defines model for LicensedSoftware.
type LicensedSoftware struct {
	// LicenceCount The current licence count for the software.
	LicenceCount int32 `json:"licence_count"`

	// Software The currently licensed software.
	Software Software `json:"software"`
}

// LicensedSoftwaresResponse defines model for LicensedSoftwaresResponse.
type LicensedSoftwaresResponse struct {
	LicensedSoftware []LicensedSoftware `json:"licensed_software"`
	Links            *Links             `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// Links defines model for Links.
type Links struct {
	// Pages Provides links to first, last, next and previous pages if more than a single page of results exists.
	Pages *Pages `json:"pages,omitempty"`
}

// LoadBalancer defines model for LoadBalancer.
type LoadBalancer struct {
	// CreatedAt The date and time in ISO8601 format of the creation of the load balancer.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// ForwardingRules The rules that control which traffic the load balancer will forward to servers in the pool.
	ForwardingRules *[]ForwardingRule `json:"forwarding_rules,omitempty"`

	// HealthCheck The rules that determine which servers are considered 'healthy' and in the server pool for the load balancer.
	HealthCheck *HealthCheck `json:"health_check,omitempty" tfsdk:"health_check"`

	// Id The ID of the load balancer.
	Id *int64 `json:"id,omitempty"`

	// Ip The IPv4 address of the load balancer.
	Ip *string `json:"ip,omitempty"`

	// Name The hostname of the load balancer.
	Name *string `json:"name,omitempty"`

	// Region The region the load balancer is located in. If this value is null the load balancer is an 'AnyCast' load balancer.
	Region *Region `json:"region"`

	// ServerIds The server IDs of the servers that are currently in the load balancer pool (regardless of their current 'health').
	ServerIds *[]int64            `json:"server_ids,omitempty"`
	Status    *LoadBalancerStatus `json:"status,omitempty"`
}

// LoadBalancerAvailabilityOption defines model for LoadBalancerAvailabilityOption.
type LoadBalancerAvailabilityOption struct {
	// Anycast If true this is an Anycast load balancer option.
	Anycast *bool `json:"anycast,omitempty"`

	// PriceHourly Hourly price in AU$.
	PriceHourly *float64 `json:"price_hourly,omitempty"`

	// PriceMonthly Monthly Price in AU$.
	PriceMonthly *float64 `json:"price_monthly,omitempty"`

	// Regions The slugs of regions where this load balancer option is available. If this is an Anycast load balancer option this will be null.
	Regions *[]string `json:"regions"`
}

// LoadBalancerAvailabilityResponse defines model for LoadBalancerAvailabilityResponse.
type LoadBalancerAvailabilityResponse struct {
	LoadBalancerAvailabilityOptions *[]LoadBalancerAvailabilityOption `json:"load_balancer_availability_options,omitempty"`
}

// LoadBalancerResponse defines model for LoadBalancerResponse.
type LoadBalancerResponse struct {
	LoadBalancer *LoadBalancer `json:"load_balancer,omitempty"`
}

// LoadBalancerRuleProtocol
// | Value | Description |
// | ----- | ----------- |
// | http | The load balancer will forward HTTP traffic that matches this rule. |
// | https | The load balancer will forward HTTPS traffic that matches this rule. |
type LoadBalancerRuleProtocol string

// LoadBalancerStatus
// | Value | Description |
// | ----- | ----------- |
// | new | The load balancer is currently being built and is not ready to accept connections. |
// | active | The load balancer is available. |
// | errored | The load balancer is in an errored state. |
type LoadBalancerStatus string

// LoadBalancersResponse defines model for LoadBalancersResponse.
type LoadBalancersResponse struct {
	Links         *Links          `json:"links"`
	LoadBalancers *[]LoadBalancer `json:"load_balancers,omitempty"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// LocalNameserversResponse defines model for LocalNameserversResponse.
type LocalNameserversResponse struct {
	LocalNameservers *[]string `json:"local_nameservers,omitempty"`
}

// Meta Contains metadata about the response, currently this includes the total number of items.
type Meta struct {
	// Total The total number of items available.
	Total *int32 `json:"total,omitempty"`
}

// Network defines model for Network.
type Network struct {
	// Gateway The gateway for this network.
	Gateway *string `json:"gateway"`

	// IpAddress The IP address for this network.
	IpAddress string `json:"ip_address"`

	// NatTarget If this is not null this property is the private IP address which receives packets from this network.
	NatTarget *string `json:"nat_target"`

	// Netmask The netmask for this network.
	Netmask *Network_Netmask `json:"netmask"`

	// ReverseName The reverse name (if any) for this network.
	ReverseName *string     `json:"reverse_name"`
	Type        NetworkType `json:"type"`
}

// NetworkNetmask0 defines model for .
type NetworkNetmask0 = int

// NetworkNetmask1 defines model for .
type NetworkNetmask1 = string

// Network_Netmask The netmask for this network.
type Network_Netmask struct {
	union json.RawMessage
}

// NetworkType
// | Value | Description |
// | ----- | ----------- |
// | private | A private (non internet accessible) network. |
// | public | A public (internet accessible) network. |
type NetworkType string

// Networks defines model for Networks.
type Networks struct {
	// Ipv6ReverseNameservers Any configured IPv6 reverse nameservers for this server. Please see our documentation for how this interacts with IPv6 nameserver settings at the account level.
	Ipv6ReverseNameservers *[]string `json:"ipv6_reverse_nameservers"`

	// PortBlocking Whether the default port blocking is enabled for this server.
	PortBlocking bool `json:"port_blocking"`

	// RecentDdos If this is true this server has been the target of a recent DDOS attack. An email will have been sent to your email address when the DDOS was detected (and if it has ended, when it ended) with more details.
	RecentDdos bool `json:"recent_ddos"`

	// SeparatePrivateNetworkInterface Whether a separate private network interface is provided for the server's VPC traffic.
	SeparatePrivateNetworkInterface *bool `json:"separate_private_network_interface"`

	// SourceAndDestinationCheck If enabled, this server is only able to send and receive data packets directly addressed to an IP address assigned to this server.
	SourceAndDestinationCheck *bool `json:"source_and_destination_check"`

	// V4 A list of the IPv4 networks for this server.
	V4 []Network `json:"v4"`

	// V6 A list of the IPv6 networks for this server.
	V6 []Network `json:"v6"`
}

// OffsiteBackupFrequencyCost All costs are in AU$.
type OffsiteBackupFrequencyCost struct {
	// DailyPerGigabyte The additional cost per GB per month for enabling daily offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.
	DailyPerGigabyte *float64 `json:"daily_per_gigabyte,omitempty" tfsdk:"daily_per_gigabyte"`

	// MonthlyPerGigabyte The additional cost per GB per month for enabling monthly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.
	MonthlyPerGigabyte *float64 `json:"monthly_per_gigabyte,omitempty" tfsdk:"monthly_per_gigabyte"`

	// WeeklyPerGigabyte The additional cost per GB per month for enabling weekly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.
	WeeklyPerGigabyte *float64 `json:"weekly_per_gigabyte,omitempty" tfsdk:"weekly_per_gigabyte"`
}

// OffsiteBackupSettings defines model for OffsiteBackupSettings.
type OffsiteBackupSettings struct {
	// ManageOffsiteCopies This only has effect if a custom offsite location is being used: the internal offsite backup location always manages copies.
	// If this is true old offsite backups will be removed once the replacement upload is complete.
	// If this is false backups must be removed from the Amazon S3 bucket manually. Amazon will charge your S3 account at their standard rate for every backup stored.
	ManageOffsiteCopies *bool `json:"manage_offsite_copies"`

	// OffsiteBackupLocation If a custom backup location is used, this is the provided location.
	OffsiteBackupLocation *string `json:"offsite_backup_location"`

	// UseCustomBackupLocation If this is true a custom backup location will be used. If false our internally managed offsite backup location be used.
	UseCustomBackupLocation *bool `json:"use_custom_backup_location,omitempty"`
}

// Pages Provides links to first, last, next and previous pages if more than a single page of results exists.
type Pages struct {
	// First A link to the first page of items if this is not the first page.
	First *string `json:"first"`

	// Last A link to the last page of items if this is not the last page.
	Last *string `json:"last"`

	// Next A link to the next page of items if this is not the last page.
	Next *string `json:"next"`

	// Prev A link to the previous page of items if this is not the first page.
	Prev *string `json:"prev"`
}

// PasswordRecoveryType
// | Value | Description |
// | ----- | ----------- |
// | manual | Password must be reset manually using the recovery console and rescue disk. |
// | offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |
// | offline-change | Password can be reset and new credentials sent (Requires restart). |
// | online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |
type PasswordRecoveryType string

// PasswordReset Reset the Password of a Server
type PasswordReset struct {
	// Password If this is provided the specified or default remote user's account password will be set to this value.
	// Only valid if the server supports password change actions (check server.password_change_supported via the servers endpoint).
	// If omitted and the server supports password change actions a random password will be generated and emailed to the account email address.
	Password *string           `json:"password"`
	Type     PasswordResetType `json:"type"`

	// Username The username of the user to change the password.
	// Only valid if the server supports password change actions (check server.password_change_supported via the servers endpoint).
	// If omitted and the server supports password change actions this will default to the username of the remote user that was configured when the server was created (normally 'root').
	Username *string `json:"username"`
}

// PasswordResetType defines model for PasswordReset.Type.
type PasswordResetType string

// PatchVpcRequest defines model for PatchVpcRequest.
type PatchVpcRequest struct {
	// Name >A name to help identify this VPC. Submit null to leave unaltered.
	Name *string `json:"name"`

	// RouteEntries Submit null to leave unaltered, submit an empty list to clear all route entries. It is not possible to PATCH individual route entries, to alter a route entry submit the entire list of route entries you wish to save.
	RouteEntries *[]RouteEntryRequest `json:"route_entries"`
}

// PaymentMethod
// | Value | Description |
// | ----- | ----------- |
// | credit-card | A validated credit card. |
// | paypal | PayPal. |
type PaymentMethod string

// Period defines model for Period.
type Period struct {
	// DataInterval The duration between data points. This is not the collection interval.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | five-minute | 5 Minutes |
	// | half-hour | 30 Minutes |
	// | four-hour | 4 Hours |
	// | day | 1 Day |
	// | week | 7 Days |
	// | month | 1 Month |
	//
	DataInterval *DataInterval `json:"data_interval,omitempty"`

	// End The date and time of the end of the period in ISO8601 format.
	End *time.Time `json:"end,omitempty"`

	// Start The date and time of the start of the period in ISO8601 format.
	Start *time.Time `json:"start,omitempty"`
}

// Ping Attempt to Ping a Server
type Ping struct {
	Type PingType `json:"type"`
}

// PingType defines model for Ping.Type.
type PingType string

// PowerCycle Power a Server Off and then On
type PowerCycle struct {
	Type PowerCycleType `json:"type"`
}

// PowerCycleType defines model for PowerCycle.Type.
type PowerCycleType string

// PowerOff Power a Server Off
type PowerOff struct {
	Type PowerOffType `json:"type"`
}

// PowerOffType defines model for PowerOff.Type.
type PowerOffType string

// PowerOn Power a Server On
type PowerOn struct {
	Type PowerOnType `json:"type"`
}

// PowerOnType defines model for PowerOn.Type.
type PowerOnType string

// ProceedRequest defines model for ProceedRequest.
type ProceedRequest struct {
	// Proceed Please see the documentation for each type of interaction for the effect of providing 'true' or 'false' here.
	Proceed bool `json:"proceed"`
}

// ProcessorModel defines model for ProcessorModel.
type ProcessorModel struct {
	// Description A description of this processor model.
	Description *string `json:"description"`

	// Id The ID of this processor model.
	Id *int64 `json:"id,omitempty"`

	// Name The name of this processor model.
	Name *string `json:"name,omitempty"`
}

// Reboot Request a Server Perform a Reboot
type Reboot struct {
	Type RebootType `json:"type"`
}

// RebootType defines model for Reboot.Type.
type RebootType string

// Rebuild Rebuild an Existing Server
type Rebuild struct {
	// Image The Operating System ID or slug or Backup image ID to use as a base for the rebuild.
	Image *string `json:"image"`

	// Options Additional options. Leaving this entirely null or any of the properties included null will use the defaults from the existing server.
	Options *ImageOptions `json:"options"`
	Type    RebuildType   `json:"type"`
}

// RebuildType defines model for Rebuild.Type.
type RebuildType string

// Region defines model for Region.
type Region struct {
	// Available Whether this region is available for the allocation of new resources.
	Available *bool `json:"available,omitempty" tfsdk:"available"`

	// Features A list of features available for resources in this region.
	Features *[]string `json:"features,omitempty" tfsdk:"features"`

	// Name The name of this region.
	Name *string `json:"name,omitempty" tfsdk:"name"`

	// NameServers A list of nameservers available for resources in this region.
	NameServers *[]string `json:"name_servers,omitempty" tfsdk:"name_servers"`

	// Sizes The slugs of the sizes available in this region.
	Sizes *[]string `json:"sizes,omitempty" tfsdk:"sizes"`

	// Slug The unique slug for this region.
	Slug *string `json:"slug,omitempty" tfsdk:"slug"`
}

// RegionsResponse defines model for RegionsResponse.
type RegionsResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta    Meta     `json:"meta"`
	Regions []Region `json:"regions"`
}

// Rename Rename a Server
type Rename struct {
	// Name The new hostname of your server, such as vps01.yourcompany.com.
	Name string     `json:"name"`
	Type RenameType `json:"type"`
}

// RenameType defines model for Rename.Type.
type RenameType string

// Resize Update the Size and Related Options for a Server
type Resize struct {
	// ChangeImage This may be left null to keep the current base image for the server. If this is provided the server disks will be destroyed and the server will be rebuilt from the selected image.
	ChangeImage *ChangeImage `json:"change_image"`

	// ChangeLicenses This may be left null to keep the current licenses for the server. If this is provided any licenses that are not included will be removed.
	ChangeLicenses *ChangeLicenses `json:"change_licenses"`

	// Options If this is null and the server has no selected size options the defaults for the size will be used. If this is null and the server has currently selected size options those will be preserved. If this is provided any option fields that are not included will be removed from the existing server.
	Options *ChangeSizeOptionsRequest `json:"options"`

	// PreActionBackup Specify this to create a backup before any actions are taken, or leave null to skip.
	PreActionBackup *TakeBackup `json:"pre_action_backup"`

	// Size The slug of the selected size. Do not provide to keep the current size.
	Size *string    `json:"size"`
	Type ResizeType `json:"type"`
}

// ResizeType defines model for Resize.Type.
type ResizeType string

// ResizeDisk Alter the Size of an Existing Disk for a Server
type ResizeDisk struct {
	// DiskId The ID of the existing disk. See server.disks for a list of IDs.
	DiskId int64 `json:"disk_id"`

	// SizeGigabytes The new size of the disk in GB. If increasing the size of the disk the server must have sufficient unallocated storage space.
	SizeGigabytes int32          `json:"size_gigabytes"`
	Type          ResizeDiskType `json:"type"`
}

// ResizeDiskType defines model for ResizeDisk.Type.
type ResizeDiskType string

// ResourceType
// | Value | Description |
// | ----- | ----------- |
// | server | Server |
// | load-balancer | Load Balancer |
// | ssh-key | SSH Key |
// | vpc | Virtual Private Network |
// | image | Backup or Operating System Image |
// | registered-domain-name | Registered Domain Name |
type ResourceType string

// Restore Restore a Backup to a Server
type Restore struct {
	// Image The ID of the specific backup to use. Snapshots are not currently supported.
	Image Restore_Image `json:"image"`
	Type  RestoreType   `json:"type"`
}

// RestoreImage0 defines model for .
type RestoreImage0 = int

// RestoreImage1 defines model for .
type RestoreImage1 = string

// Restore_Image The ID of the specific backup to use. Snapshots are not currently supported.
type Restore_Image struct {
	union json.RawMessage
}

// RestoreType defines model for Restore.Type.
type RestoreType string

// ReverseNameServersResponse defines model for ReverseNameServersResponse.
type ReverseNameServersResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta               Meta     `json:"meta"`
	ReverseNameservers []string `json:"reverse_nameservers"`
}

// ReverseNameserversRequest defines model for ReverseNameserversRequest.
type ReverseNameserversRequest struct {
	// ReverseNameservers A list of IPv6 reverse name servers for all IPv6 enabled servers. Any existing reverse name servers that are omitted from the list will be removed.
	ReverseNameservers []string `json:"reverse_nameservers"`
}

// RouteEntry defines model for RouteEntry.
type RouteEntry struct {
	// Description An optional description for the route.
	Description *string `json:"description"`

	// Destination The destination address for this route entry. This may be in CIDR format.
	Destination *string `json:"destination,omitempty"`

	// Router The server that will receive traffic sent to the destination property in this VPC.
	Router *string `json:"router,omitempty"`
}

// RouteEntryRequest defines model for RouteEntryRequest.
type RouteEntryRequest struct {
	// Description An optional description for the route.
	Description *string `json:"description" tfsdk:"description"`

	// Destination The destination address for this route entry. This may be in CIDR format.
	Destination string `json:"destination" tfsdk:"destination"`

	// Router The server that will receive traffic sent to the destination property in this VPC.
	Router string `json:"router" tfsdk:"router"`
}

// Sample defines model for Sample.
type Sample struct {
	// CpuUsageDetailed The usage percentage of each virtual CPU.
	CpuUsageDetailed *[]float64 `json:"cpu_usage_detailed,omitempty"`

	// CpuUsagePercent The usage percentage of all CPU; 100% is the maximum possible even with multiple processors.
	CpuUsagePercent *float64 `json:"cpu_usage_percent,omitempty"`

	// MemoryUsageBytes The virtual memory used in bytes.
	MemoryUsageBytes *float64 `json:"memory_usage_bytes,omitempty"`

	// NetworkIncomingKbps The incoming network data rate in Kb per second.
	NetworkIncomingKbps *float64 `json:"network_incoming_kbps,omitempty"`

	// NetworkOutgoingKbps The outgoing network data rate in Kb per second.
	NetworkOutgoingKbps *float64 `json:"network_outgoing_kbps,omitempty"`

	// StorageReadKbps The storage read rate in Kb per second.
	StorageReadKbps *float64 `json:"storage_read_kbps,omitempty"`

	// StorageReadRequestsPerSecond The storage read requests per second.
	StorageReadRequestsPerSecond *float64 `json:"storage_read_requests_per_second,omitempty"`

	// StorageUsageMegabytes The total storage used in MB.
	StorageUsageMegabytes *float64 `json:"storage_usage_megabytes,omitempty"`

	// StorageWriteKbps The storage write rate in Kb per second.
	StorageWriteKbps *float64 `json:"storage_write_kbps,omitempty"`

	// StorageWriteRequestsPerSecond The storage write requests per second.
	StorageWriteRequestsPerSecond *float64 `json:"storage_write_requests_per_second,omitempty"`
}

// SampleSet defines model for SampleSet.
type SampleSet struct {
	// Average The average values of the samples collected during this period.
	Average *Sample `json:"average,omitempty"`

	// MaximumMemoryMegabytes The maximum memory used in MB at any point during this collection period.
	MaximumMemoryMegabytes *float64 `json:"maximum_memory_megabytes,omitempty"`

	// MaximumStorageGigabytes The maximum storage used in GB at any point during this collection period.
	MaximumStorageGigabytes *float64 `json:"maximum_storage_gigabytes,omitempty"`

	// Period The period when this sample set was collected.
	Period *Period `json:"period,omitempty"`

	// ServerId The ID of the server that this sample set refers to.
	ServerId *int64 `json:"server_id,omitempty"`
}

// SampleSetResponse defines model for SampleSetResponse.
type SampleSetResponse struct {
	SampleSet *SampleSet `json:"sample_set"`
}

// SampleSetsResponse defines model for SampleSetsResponse.
type SampleSetsResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta       Meta        `json:"meta"`
	SampleSets []SampleSet `json:"sample_sets"`
}

// SelectedSizeOptions defines model for SelectedSizeOptions.
type SelectedSizeOptions struct {
	// DailyBackups The number of retained daily backups. e.g. if this is '2' we will store two daily backups, so each daily backup will be retained for two days before being overwritten.
	DailyBackups int32 `json:"daily_backups"`

	// Disk The total storage in GB for this server.
	Disk int32 `json:"disk"`

	// Ipv4Addresses The total count of IPv4 addresses for this server.
	Ipv4Addresses int32 `json:"ipv4_addresses"`

	// Memory The total memory in MB for this server.
	Memory int32 `json:"memory"`

	// MonthlyBackups The number of retained monthly backups. e.g. if this is '3' we will store three monthly backups, so each monthly backup will be retained for three months before being overwritten.
	MonthlyBackups int32 `json:"monthly_backups"`

	// OffsiteBackups If this is true any daily, weekly or monthly backups will be duplicated to an off-site location.
	OffsiteBackups bool `json:"offsite_backups"`

	// Transfer The total transfer per month in TB for this server.
	Transfer float64 `json:"transfer"`

	// WeeklyBackups The number of retained weekly backups. e.g. if this is '1' we will store one weekly backup, so that weekly backup will be retained for one week before being overwritten.
	WeeklyBackups int32 `json:"weekly_backups"`
}

// Server defines model for Server.
type Server struct {
	// AdvancedFeatures The currently enabled advanced features, machine type and processor flags.
	AdvancedFeatures *AdvancedServerFeatures `json:"advanced_features,omitempty"`

	// AttachedBackup An object that provides details of any backup image currently attached to the server..
	AttachedBackup *AttachedBackup `json:"attached_backup"`

	// BackupIds A list of the currently existing backup image IDs for this server (if any).
	BackupIds *[]int64 `json:"backup_ids,omitempty"`

	// BackupSettings Detailed backup settings for the server.
	BackupSettings *BackupSettings `json:"backup_settings,omitempty"`

	// CancelledAt If the server has been cancelled, this is the date and time in ISO8601 format of that cancellation.
	CancelledAt *time.Time `json:"cancelled_at"`

	// CreatedAt The date and time in ISO8601 format of this server's initial creation.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Disk The total disk in GB of this server.
	Disk *int32 `json:"disk,omitempty"`

	// Disks A list of the disks that are currently attached to the server.
	Disks *[]Disk `json:"disks,omitempty"`

	// FailoverIps A list of any assigned failover IP addresses for this server.
	FailoverIps *[]string `json:"failover_ips,omitempty"`

	// Features A list of the currently enabled features on this server.
	Features *[]string `json:"features,omitempty"`

	// Host Summary information about the host of this server.
	Host *Host `json:"host,omitempty"`

	// Id The ID of this server.
	Id *int64 `json:"id,omitempty"`

	// Image The base image used to create this server.
	Image *Image `json:"image,omitempty"`

	// Kernel The currently selected kernel for the server.
	Kernel *Kernel `json:"kernel"`

	// Memory The memory in MB of this server.
	Memory *int32 `json:"memory,omitempty"`

	// Name The hostname of this server.
	Name *string `json:"name,omitempty"`

	// Networks A list of the networks of the server.
	Networks *Networks `json:"networks,omitempty"`

	// NextBackupWindow The details of the next scheduled backup, if any.
	NextBackupWindow *BackupWindow `json:"next_backup_window"`

	// PartnerId The server ID of the partner of this server, if one has been assigned.
	PartnerId *int64 `json:"partner_id"`

	// PasswordChangeSupported If this is true the password_reset server action can be called to change a user's password. If this is false the password_reset server action will merely clear the root/administrator password allowing the password to be changed via the web console.
	PasswordChangeSupported *bool `json:"password_change_supported,omitempty"`

	// Permalink A randomly generated two-word identifier assigned to servers in regions that support this feature.
	Permalink *string `json:"permalink"`

	// Region The region this server is allocated to.
	Region *Region `json:"region,omitempty"`

	// SelectedSizeOptions An object that details the selected options for the current size.
	SelectedSizeOptions *SelectedSizeOptions `json:"selected_size_options"`

	// Size The currently selected size for this server.
	Size *Size `json:"size,omitempty"`

	// SizeSlug The slug of the currently selected size for this server.
	SizeSlug *string       `json:"size_slug,omitempty"`
	Status   *ServerStatus `json:"status,omitempty"`

	// Vcpus The number of virtual CPUs of this server.
	Vcpus *int32 `json:"vcpus,omitempty"`

	// VpcId The VPC ID that this server is allocated to. If this value is null the server is in the default (public) network for the region.
	VpcId *int64 `json:"vpc_id"`
}

// ServerAction defines model for ServerAction.
type ServerAction struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// ServerIdsRequest defines model for ServerIdsRequest.
type ServerIdsRequest struct {
	// ServerIds A list of server IDs.
	ServerIds []int64 `json:"server_ids"`
}

// ServerResponse defines model for ServerResponse.
type ServerResponse struct {
	Server Server `json:"server"`
}

// ServerStatus
// | Value | Description |
// | ----- | ----------- |
// | new | The server is currently in the process of building and is not yet available for use. |
// | active | The server is available for use. |
// | archive | The server is powered off due to cancellation or non payment. |
// | off | The server has been powered off, but may be powered back on. |
type ServerStatus string

// ServersResponse defines model for ServersResponse.
type ServersResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta    Meta      `json:"meta"`
	Servers *[]Server `json:"servers,omitempty"`
}

// Shutdown Request a Server Perform a Shutdown
type Shutdown struct {
	Type ShutdownType `json:"type"`
}

// ShutdownType defines model for Shutdown.Type.
type ShutdownType string

// Size defines model for Size.
type Size struct {
	// Available If this is false the size is not available for new servers.
	Available *bool `json:"available,omitempty" tfsdk:"available"`

	// CpuDescription A description of the CPU provided in this size.
	CpuDescription *string `json:"cpu_description" tfsdk:"cpu_description"`

	// Description A description of this size.
	Description *string `json:"description" tfsdk:"description"`

	// Disk The included storage for this size in GB.
	Disk *int32 `json:"disk,omitempty" tfsdk:"disk"`

	// ExcessTransferCostPerGigabyte The excess charged for any transfer above the included data transfer in AU$ per GB.
	ExcessTransferCostPerGigabyte *float64 `json:"excess_transfer_cost_per_gigabyte,omitempty" tfsdk:"excess_transfer_cost_per_gigabyte"`

	// Memory The included memory for this size in MB.
	Memory *int32 `json:"memory,omitempty" tfsdk:"memory"`

	// Options Available add-ons (optional features not included in the base price) for the size. All costs are in AU$ per month (pro-rated).
	Options SizeOptions `json:"options" tfsdk:"options"`

	// PriceHourly Hourly price in AU$.
	PriceHourly *float64 `json:"price_hourly,omitempty" tfsdk:"price_hourly"`

	// PriceMonthly Monthly Price in AU$.
	PriceMonthly *float64 `json:"price_monthly,omitempty" tfsdk:"price_monthly"`

	// Regions A list of region slugs where this size is available regardless of stock.
	// If this a response to a query that included a selected operating system this response will only include regions where that operating system is available on this size,
	// otherwise not all regions listed will support all operating systems on this size.
	Regions *[]string `json:"regions,omitempty" tfsdk:"regions"`

	// RegionsOutOfStock A list of region slugs where the size is normally available but is currently not available due to lack of stock.
	RegionsOutOfStock *[]string `json:"regions_out_of_stock" tfsdk:"regions_out_of_stock"`

	// SizeType The type of this size, generally used to differentiate sizes optimized for different usages.
	SizeType *SizeType `json:"size_type,omitempty" tfsdk:"size_type"`

	// Slug The slug of this size.
	Slug *string `json:"slug,omitempty" tfsdk:"slug"`

	// StorageDescription A description of the storage provided in this size.
	StorageDescription *string `json:"storage_description" tfsdk:"storage_description"`

	// Transfer The included data transfer for this size in TB.
	Transfer *float64 `json:"transfer,omitempty" tfsdk:"transfer"`

	// VcpuUnits This is the unit that the vcpus field counts, e.g. "core" or "thread".
	VcpuUnits *string `json:"vcpu_units,omitempty" tfsdk:"vcpu_units"`

	// Vcpus The count of virtual CPUs for this size. See vcpu_units for a description of how each virtual CPU maps to the underlying hardware.
	Vcpus *int32 `json:"vcpus,omitempty" tfsdk:"vcpus"`
}

// SizeOptions Available add-ons (optional features not included in the base price) for the size. All costs are per month (pro-rated).
type SizeOptions struct {
	// BackupsCostPerBackupPerGigabyte The cost per GB of storage of each selected backup. See the API support document for how to calculate the final cost of backups based on the options selected.
	BackupsCostPerBackupPerGigabyte *float64 `json:"backups_cost_per_backup_per_gigabyte,omitempty" tfsdk:"backups_cost_per_backup_per_gigabyte"`

	// DailyBackups The number of daily backups included in the base size cost.
	DailyBackups *int32 `json:"daily_backups,omitempty" tfsdk:"daily_backups"`

	// DiscountForNoPublicIpv4 This is the discount (if any) that is applied if no public IPv4 addresses are selected.
	DiscountForNoPublicIpv4 *float64 `json:"discount_for_no_public_ipv4,omitempty" tfsdk:"discount_for_no_public_ipv4"`

	// DiskCostPerAdditionalGigabyte The additional cost per GB per month for additional storage space.
	DiskCostPerAdditionalGigabyte *float64 `json:"disk_cost_per_additional_gigabyte,omitempty" tfsdk:"disk_cost_per_additional_gigabyte"`

	// DiskMax The maximum storage in GB permitted on this size.
	DiskMax *int32 `json:"disk_max,omitempty" tfsdk:"disk_max"`

	// DiskMin The minimum storage in GB permitted on this size.
	DiskMin *int32 `json:"disk_min,omitempty" tfsdk:"disk_min"`

	// Ipv4AddressesCostPerAddress The additional cost per public IPv4 address per month for additional IPv4 addresses.
	Ipv4AddressesCostPerAddress *float64 `json:"ipv4_addresses_cost_per_address,omitempty" tfsdk:"ipv4_addresses_cost_per_address"`

	// Ipv4AddressesMax The maximum number of IPv4 addresses permitted on this size.
	Ipv4AddressesMax *int32 `json:"ipv4_addresses_max,omitempty" tfsdk:"ipv4_addresses_max"`

	// MemoryCostPerAdditionalMegabyte The additional cost per MB per month for additional memory.
	MemoryCostPerAdditionalMegabyte *float64 `json:"memory_cost_per_additional_megabyte,omitempty" tfsdk:"memory_cost_per_additional_megabyte"`

	// MemoryMax The maximum memory in MB permitted on this size.
	MemoryMax *int32 `json:"memory_max,omitempty" tfsdk:"memory_max"`

	// MonthlyBackups The number of monthly backups included in the base size cost.
	MonthlyBackups *int32 `json:"monthly_backups,omitempty" tfsdk:"monthly_backups"`

	// OffsiteBackupFrequencyCost The additional cost per GB of storage for enabling offsite backups based on highest frequency of backups currently enabled. All costs are in AU$.
	OffsiteBackupFrequencyCost *OffsiteBackupFrequencyCost `json:"offsite_backup_frequency_cost,omitempty" tfsdk:"offsite_backup_frequency_cost"`

	// OffsiteBackupsCostPerGigabyte The additional cost per GB of storage for enabling offsite backups. See the API support document for how to calculate the final cost of backups based on the options selected.
	OffsiteBackupsCostPerGigabyte *float64 `json:"offsite_backups_cost_per_gigabyte,omitempty" tfsdk:"offsite_backups_cost_per_gigabyte"`

	// RestrictedDiskValues If this is null the normal valid values in the documentation for SizeOptionsRequest are used, otherwise only these values (in GB) are permitted.
	RestrictedDiskValues *[]int32 `json:"restricted_disk_values" tfsdk:"restricted_disk_values"`

	// TransferCostPerAdditionalGigabyte The additional cost per GB per month for additional included transfer.
	TransferCostPerAdditionalGigabyte *float64 `json:"transfer_cost_per_additional_gigabyte,omitempty" tfsdk:"transfer_cost_per_additional_gigabyte"`

	// TransferMax The maximum transfer in TB permitted for this size.
	TransferMax *float64 `json:"transfer_max,omitempty" tfsdk:"transfer_max"`

	// WeeklyBackups The number of weekly backups included in the base size cost.
	WeeklyBackups *int32 `json:"weekly_backups,omitempty" tfsdk:"weekly_backups"`
}

// SizeOptionsRequest defines model for SizeOptionsRequest.
type SizeOptionsRequest struct {
	// DailyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	DailyBackups *int32 `json:"daily_backups"`

	// Disk The total storage in GB for this server.
	// If specified this is the absolute value, not just the additional storage above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values for sizes that do not provide a value for options.restricted_storage_values_gb:
	// - must be a multiple of 5
	// - &gt; 60GB must be a multiple of 10
	// - &gt; 200GB must be a multiple of 100
	Disk *int32 `json:"disk"`

	// Ipv4Addresses The total count of IPv4 addresses for this server. If specified this is the absolute value, not just the additional IPv4 addresses above what is included in the size. Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server. Must not exceed the size.ipv4_addresses_max value.
	Ipv4Addresses *int32 `json:"ipv4_addresses"`

	// Memory The total memory in MB for this server.
	// If specified this is the absolute value, not just the additional memory above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values:
	// - must be a multiple of 128
	// - &gt; 2048MB must be a multiple of 1024
	// - &gt; 16384MB must be a multiple of 2048
	// - &gt; 24576MB must be a multiple of 4096
	Memory *int32 `json:"memory"`

	// MonthlyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	MonthlyBackups *int32 `json:"monthly_backups"`

	// OffsiteBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	OffsiteBackups *bool `json:"offsite_backups"`

	// Transfer The total transfer per month in TB for this server.
	// If specified this is the absolute value, not just the additional transfer above what is included in the size.
	// Leave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.
	//
	// Valid values (when converted to GB by multiplying the value provided by 1024):
	// - must be a multiple of 5GB
	// - &gt; 30GB must be a multiple of 10
	// - &gt; 200GB must be a multiple of 100
	// - &gt; 2000GB must be a multiple of 1000
	Transfer *float64 `json:"transfer"`

	// WeeklyBackups Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.
	WeeklyBackups *int32 `json:"weekly_backups"`
}

// SizeType defines model for SizeType.
type SizeType struct {
	// Description The description of this size type, generally used to indicate the intended use case for sizes of this type.
	Description *string `json:"description" tfsdk:"description"`

	// Name The name of this size type.
	Name *string `json:"name,omitempty" tfsdk:"name"`

	// Slug The slug of this size type.
	Slug *string `json:"slug,omitempty" tfsdk:"slug"`
}

// SizesResponse defines model for SizesResponse.
type SizesResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta  Meta   `json:"meta"`
	Sizes []Size `json:"sizes"`
}

// SnapshotsResponse defines model for SnapshotsResponse.
type SnapshotsResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta      Meta     `json:"meta"`
	Snapshots *[]Image `json:"snapshots,omitempty"`
}

// Software defines model for Software.
type Software struct {
	// CostPerLicencePerMonth The cost for each licence of this software per month in AU$.
	CostPerLicencePerMonth *float64 `json:"cost_per_licence_per_month,omitempty"`

	// Description The description of this software.
	Description *string `json:"description,omitempty"`

	// Enabled Software that is not enabled is not available to be added to servers but may be retained by servers that currently use it.
	Enabled *bool `json:"enabled,omitempty"`

	// Group Software in the same group may not be licensed together.
	Group *string `json:"group"`

	// Id The ID of this software.
	Id *int64 `json:"id,omitempty"`

	// LicenceStepCount Licences must be purchased in multiples of this value.
	LicenceStepCount *int32 `json:"licence_step_count,omitempty"`

	// MaximumLicenceCount The maximum licences permitted for this software.
	MaximumLicenceCount *int32 `json:"maximum_licence_count,omitempty"`

	// MinimumLicenceCount The minimum licences permitted for this software.
	MinimumLicenceCount *int32 `json:"minimum_licence_count,omitempty"`

	// Name The name of this software.
	Name *string `json:"name,omitempty"`

	// SupportedOperatingSystems A list of slugs of operating system images that support this software.
	SupportedOperatingSystems *[]string `json:"supported_operating_systems,omitempty"`
}

// SoftwareResponse defines model for SoftwareResponse.
type SoftwareResponse struct {
	Software Software `json:"software"`
}

// SoftwaresResponse defines model for SoftwaresResponse.
type SoftwaresResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta     Meta       `json:"meta"`
	Software []Software `json:"software"`
}

// SshKey defines model for SshKey.
type SshKey struct {
	// Default If an SSH key is marked as default it will be deployed to all newly created servers that support SSH keys unless expressly overridden in the creation request.
	Default *bool `json:"default,omitempty"`

	// Fingerprint The fingerprint of this SSH key.
	Fingerprint *string `json:"fingerprint,omitempty"`

	// Id The ID of this SSH key.
	Id *int64 `json:"id,omitempty"`

	// Name The name of this SSH key. This is used only to aid in identification.
	Name *string `json:"name"`

	// PublicKey The public key of this SSH key.
	PublicKey *string `json:"public_key,omitempty"`
}

// SshKeyRequest defines model for SshKeyRequest.
type SshKeyRequest struct {
	// Default Optional: If true this will be added to all new server installations (if we support SSH Key injection for the server's operating system).
	Default *bool `json:"default"`

	// Name A name to help you identify the key.
	Name string `json:"name"`

	// PublicKey The public key in OpenSSH "authorized_keys" format.
	PublicKey string `json:"public_key"`
}

// SshKeyResponse defines model for SshKeyResponse.
type SshKeyResponse struct {
	SshKey SshKey `json:"ssh_key"`
}

// SshKeysResponse defines model for SshKeysResponse.
type SshKeysResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta    Meta     `json:"meta"`
	SshKeys []SshKey `json:"ssh_keys"`
}

// TakeBackup Take a Backup of a Server
type TakeBackup struct {
	// BackupIdToReplace If replacement_strategy is 'specified' this property must be set to an existing backup.
	BackupIdToReplace *int64 `json:"backup_id_to_replace"`

	// BackupType If replacement_strategy is anything other than 'specified', this must be provided.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | daily | A backup which is scheduled to be taken each day. |
	// | weekly | A backup which is scheduled to be taken each week. |
	// | monthly | A backup which is scheduled to be taken each month. |
	// | temporary | A backup which is created on demand and only retained for a maximum of seven days. |
	//
	BackupType *BackupSlot `json:"backup_type"`

	// Label An optional label to identify the backup.
	Label *string `json:"label"`

	// ReplacementStrategy The strategy for selecting which backup to replace (if any).
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | none | Do not replace any existing backup: use a free slot of the provided backup type. If there are no free slots an error will occur. |
	// | specified | Replace the specific backup id provided. |
	// | oldest | Use any free slots of the provided backup type, and if there are no free slots replace the oldest unlocked and un-attached backup of the provided backup type. |
	// | newest | Use any free slots of the provided backup type, and if there are no free slots replace the newest unlocked and un-attached backup of the provided backup type. |
	//
	ReplacementStrategy BackupReplacementStrategy `json:"replacement_strategy"`
	Type                TakeBackupType            `json:"type"`
}

// TakeBackupType defines model for TakeBackup.Type.
type TakeBackupType string

// TaxCode defines model for TaxCode.
type TaxCode struct {
	// FixedPercent If this is set then this tax is added to all applicable transactions. This is a percentage value where 100 = 100%. For example: if the type is 'scalar' and the value of this is '10' then 10% of the value of all transactions will be added as tax.
	FixedPercent *float64 `json:"fixed_percent"`

	// Name The name of this tax code.
	Name *string `json:"name,omitempty"`

	// Type The type of tax code.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | none | No tax is applied to any transaction. |
	// | scalar | A fixed fraction of the value of all transactions is added as tax. |
	//
	Type *TaxCodeType `json:"type,omitempty"`
}

// TaxCodeType
// | Value | Description |
// | ----- | ----------- |
// | none | No tax is applied to any transaction. |
// | scalar | A fixed fraction of the value of all transactions is added as tax. |
type TaxCodeType string

// ThresholdAlert defines model for ThresholdAlert.
type ThresholdAlert struct {
	AlertType *ThresholdAlertType `json:"alert_type,omitempty"`

	// CurrentValue The last measured value for this alert type over the threshold alert period. Refer to the documentation for each threshold alert type for what this value measures in the context of the alert type. If there is no measured value in the threshold alert period this will be null.
	CurrentValue *int32 `json:"current_value"`

	// Enabled If a threshold alert is not enabled it will not generate warnings for the user.
	Enabled *bool `json:"enabled,omitempty"`

	// LastCleared The date and time (if any) in ISO8601 format of the last time this alert was cleared. An alert may not be raised again until a minimum duration has passed since it was last cleared.
	LastCleared *time.Time `json:"last_cleared"`

	// LastRaised The date and time (if any) in ISO8601 format of the last time this alert was raised. An alert may not be raised again until it has been cleared.
	LastRaised *time.Time `json:"last_raised"`

	// Value The threshold value of the alert. Refer to the documentation for each threshold alert type for what this value measures in the context of the alert type.
	Value *int32 `json:"value,omitempty"`
}

// ThresholdAlertRequest defines model for ThresholdAlertRequest.
type ThresholdAlertRequest struct {
	AlertType ThresholdAlertType `json:"alert_type"`

	// Enabled Do not provide or leave null to keep existing status.
	Enabled *bool `json:"enabled"`

	// Value Do not provide or leave null to keep existing value.
	Value *int32 `json:"value"`
}

// ThresholdAlertType
// | Value | Description |
// | ----- | ----------- |
// | cpu | The alert is based off the average percentage of all CPU; 100% is the maximum possible even with multiple processors. A high average will prevent the server from responding quickly. |
// | storage-requests | The alert is based off The average number of requests (combined read and write) received by the storage subsystem. A high number of requests often indicates swap usage (due to memory exhaustion) and is associated with poor performance. |
// | network-incoming | The alert is based off the amount of data going into the server (from the internet and the LAN). A sudden increase may indicate the server is the victim of a DOS attack. |
// | network-outgoing | The alert is based off the amount of data coming out of the server (to the internet and the LAN). A sudden increase may indicate the server has been hacked and is being used for spam delivery. |
// | data-transfer-used | The alert is based off the percentage of your monthly data transfer limit. |
// | storage-used | The alert is based off the disk space consumed as a percentage of your total disk space. If the server runs out of disk space programs may fail to execute or be unable to create new files, or the server may become unresponsive. |
// | memory-used | The alert is based off the virtual memory consumed as a percentage of your physical memory. Virtual memory includes the swap file so the percentage may exceed 100% indicating that the server has run out of physical memory and is relying on swap space, which will generally cause poor performance. |
type ThresholdAlertType string

// ThresholdAlertsResponse defines model for ThresholdAlertsResponse.
type ThresholdAlertsResponse struct {
	ThresholdAlerts *[]ThresholdAlert `json:"threshold_alerts,omitempty"`
}

// Uncancel Revert the Cancellation of a Server
type Uncancel struct {
	Type UncancelType `json:"type"`
}

// UncancelType defines model for Uncancel.Type.
type UncancelType string

// UnpaidFailedInvoicesResponse defines model for UnpaidFailedInvoicesResponse.
type UnpaidFailedInvoicesResponse struct {
	Invoices *[]Invoice `json:"invoices,omitempty"`
}

// UpdateDomainRecordRequest Any values not provided will be retained. Provide empty strings to clear existing string values, nulls to retain the existing values.
type UpdateDomainRecordRequest struct {
	// Data A general data field that has different functions depending on the record type.
	Data *string `json:"data"`

	// Flags An unsigned integer between 0-255 that is only relevant for CAA records.
	Flags *int32 `json:"flags"`

	// Name The subdomain for this record. Use @ for records on the domain itself, and * to create a wildcard record.
	Name *string `json:"name"`

	// Port A port value that is only relevant for SRV records.
	Port *int32 `json:"port"`

	// Priority A priority value that is only relevant for SRV and MX records.
	Priority *int32 `json:"priority"`

	// Tag A parameter tag that is only relevant for CAA records.
	Tag *string `json:"tag"`

	// Ttl This value is the time to live for the record, in seconds.
	Ttl *int32 `json:"ttl"`

	// Type The type of the DNS record.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | A | Map an IPv4 address to a hostname. |
	// | AAAA | Map an IPv6 address to a hostname. |
	// | CAA | Restrict which certificate authorities are permitted to issue certificates for a domain. |
	// | CNAME | Define an alias for your canonical hostname. |
	// | MX | Define the mail exchanges that handle mail for the domain. |
	// | NS | Define the nameservers that manage the domain. |
	// | SOA | The Start of Authority record for the zone. |
	// | SRV | Specify a server by hostname and port to handle a service or services. |
	// | TXT | Define a string of text that is associated with a hostname. |
	//
	Type *DomainRecordType `json:"type"`

	// Weight The weight value that is only relevant for SRV records.
	Weight *int32 `json:"weight"`
}

// UpdateLoadBalancerRequest defines model for UpdateLoadBalancerRequest.
type UpdateLoadBalancerRequest struct {
	// ForwardingRules The rules that control which traffic the load balancer will forward to servers in the pool. Leave null to accept a default "HTTP" only forwarding rule.
	ForwardingRules *[]ForwardingRule `json:"forwarding_rules"`

	// HealthCheck The rules that determine which servers are considered 'healthy' and in the server pool for the load balancer. Leave this null to accept appropriate defaults based on the forwarding_rules.
	HealthCheck *HealthCheck `json:"health_check"`

	// Name The hostname of the load balancer.
	Name string `json:"name"`

	// ServerIds A list of server IDs to assign to this load balancer.
	ServerIds *[]int64 `json:"server_ids"`
}

// UpdateLoadBalancerResponse defines model for UpdateLoadBalancerResponse.
type UpdateLoadBalancerResponse struct {
	Links        *ActionsLinks `json:"links"`
	LoadBalancer *LoadBalancer `json:"load_balancer,omitempty"`
}

// UpdateSshKeyRequest defines model for UpdateSshKeyRequest.
type UpdateSshKeyRequest struct {
	// Default Do not provide or leave null to leave the default status of the key unchanged.
	// Optional: If true this will be added to all new server installations (if we support SSH Key injection for the server's operating system).
	Default *bool `json:"default"`

	// Name A name to help you identify the key.
	Name string `json:"name"`
}

// UpdateVpcRequest Any properties that are not included will be cleared.
type UpdateVpcRequest struct {
	// Name A name to help identify this VPC.
	Name string `json:"name"`

	// RouteEntries The route entries that control how network traffic is directed through the VPC environment.
	RouteEntries *[]RouteEntryRequest `json:"route_entries"`
}

// UploadImageRequest defines model for UploadImageRequest.
type UploadImageRequest struct {
	// BackupIdToReplace If replacement_strategy is 'specified' this property must be set to an existing backup.
	BackupIdToReplace *int64 `json:"backup_id_to_replace"`

	// BackupType If replacement_strategy is anything other than 'specified', this must be provided.
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | daily | A backup which is scheduled to be taken each day. |
	// | weekly | A backup which is scheduled to be taken each week. |
	// | monthly | A backup which is scheduled to be taken each month. |
	// | temporary | A backup which is created on demand and only retained for a maximum of seven days. |
	//
	BackupType *BackupSlot `json:"backup_type"`

	// Label An optional label to identify the backup.
	Label *string `json:"label"`

	// ReplacementStrategy The strategy for selecting which backup to replace (if any).
	//
	// | Value | Description |
	// | ----- | ----------- |
	// | none | Do not replace any existing backup: use a free slot of the provided backup type. If there are no free slots an error will occur. |
	// | specified | Replace the specific backup id provided. |
	// | oldest | Use any free slots of the provided backup type, and if there are no free slots replace the oldest unlocked and un-attached backup of the provided backup type. |
	// | newest | Use any free slots of the provided backup type, and if there are no free slots replace the newest unlocked and un-attached backup of the provided backup type. |
	//
	ReplacementStrategy BackupReplacementStrategy `json:"replacement_strategy"`

	// Url The source URL for the image to upload. Only HTTP and HTTPS sources are currently supported.
	Url string `json:"url"`
}

// Uptime Check the Uptime of a Server
type Uptime struct {
	Type UptimeType `json:"type"`
}

// UptimeType defines model for Uptime.Type.
type UptimeType string

// UserData defines model for UserData.
type UserData struct {
	// UserData The UserData that was last used to initialise the server.
	UserData *string `json:"user_data"`
}

// UserInteractionRequired defines model for UserInteractionRequired.
type UserInteractionRequired struct {
	InteractionType *UserInteractionType `json:"interaction_type,omitempty"`
}

// UserInteractionType
// | Value | Description |
// | ----- | ----------- |
// | continue-after-ping-failure | Whether we should assume the server creation was successful despite failing to ping the server. |
// | allow-unclean-power-off | Whether we are permitted to perform an un-clean power off after the server failed to perform a clean shutdown. |
type UserInteractionType string

// VideoDevice
// | Value | Description |
// | ----- | ----------- |
// | cirrus-logic | Cirrus Logic GD5446 |
// | standard | Standard VGA with VESA 2.0 extensions |
// | virtio | Virtio VGA (800x600) |
// | virtio-wide | Virtio VGA (1600x900) |
type VideoDevice string

// VmMachineType
// | Value | Description |
// | ----- | ----------- |
// | pc_i440fx_1point5 | PC i440FX 1.5 |
// | pc_i440fx_2point11 | PC i440FX 2.11 |
// | pc_i440fx_4point1 | PC i440FX 4.1 |
// | pc_i440fx_4point2 | PC i440FX 4.2 |
// | pc_i440fx_5point0 | PC i440FX 5.0 |
// | pc_i440fx_5point1 | PC i440FX 5.1 |
// | pc_i440fx_7point2 | PC i440FX 7.2 |
// | pc_i440fx_8point2 | PC i440FX 8.2 |
type VmMachineType string

// Vpc defines model for Vpc.
type Vpc struct {
	// Id The ID of this VPC.
	Id *int64 `json:"id,omitempty"`

	// IpRange The IPv4 range for this VPC in CIDR format.
	IpRange *string `json:"ip_range,omitempty"`

	// Name The name of this VPC.
	Name *string `json:"name,omitempty"`

	// RouteEntries The route entries that control how network traffic is directed through the VPC environment.
	RouteEntries *[]RouteEntry `json:"route_entries,omitempty"`
}

// VpcMember defines model for VpcMember.
type VpcMember struct {
	// CreatedAt The date and time in ISO8601 format of this resource's initial creation.
	CreatedAt *time.Time `json:"created_at"`

	// Name The name of this VPC member.
	Name *string `json:"name,omitempty"`

	// ResourceId The resource ID of this VPC member.
	ResourceId   *string       `json:"resource_id,omitempty"`
	ResourceType *ResourceType `json:"resource_type,omitempty"`
}

// VpcMembersResponse defines model for VpcMembersResponse.
type VpcMembersResponse struct {
	Links   *Links       `json:"links"`
	Members *[]VpcMember `json:"members,omitempty"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta `json:"meta"`
}

// VpcResponse defines model for VpcResponse.
type VpcResponse struct {
	Vpc *Vpc `json:"vpc,omitempty"`
}

// VpcsResponse defines model for VpcsResponse.
type VpcsResponse struct {
	Links *Links `json:"links"`

	// Meta Contains metadata about the response, currently this includes the total number of items.
	Meta Meta   `json:"meta"`
	Vpcs *[]Vpc `json:"vpcs,omitempty"`
}

// GetAccountKeysParams defines parameters for GetAccountKeys.
type GetAccountKeysParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostAccountKeysJSONBody defines parameters for PostAccountKeys.
type PostAccountKeysJSONBody = SshKeyRequest

// PutAccountKeysKeyIdJSONBody defines parameters for PutAccountKeysKeyId.
type PutAccountKeysKeyIdJSONBody = UpdateSshKeyRequest

// GetActionsParams defines parameters for GetActions.
type GetActionsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostActionsActionIdProceedJSONBody defines parameters for PostActionsActionIdProceed.
type PostActionsActionIdProceedJSONBody = ProceedRequest

// GetCustomersMyInvoicesParams defines parameters for GetCustomersMyInvoices.
type GetCustomersMyInvoicesParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetDataUsagesCurrentParams defines parameters for GetDataUsagesCurrent.
type GetDataUsagesCurrentParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetDomainsParams defines parameters for GetDomains.
type GetDomainsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostDomainsJSONBody defines parameters for PostDomains.
type PostDomainsJSONBody = DomainRequest

// PostDomainsRefreshNameserverCacheJSONBody defines parameters for PostDomainsRefreshNameserverCache.
type PostDomainsRefreshNameserverCacheJSONBody = DomainRefreshRequest

// DeleteDomainsDomainNameParamsDomainName0 defines parameters for DeleteDomainsDomainName.
type DeleteDomainsDomainNameParamsDomainName0 = int

// DeleteDomainsDomainNameParamsDomainName1 defines parameters for DeleteDomainsDomainName.
type DeleteDomainsDomainNameParamsDomainName1 = string

// GetDomainsDomainNameParamsDomainName0 defines parameters for GetDomainsDomainName.
type GetDomainsDomainNameParamsDomainName0 = int

// GetDomainsDomainNameParamsDomainName1 defines parameters for GetDomainsDomainName.
type GetDomainsDomainNameParamsDomainName1 = string

// GetDomainsDomainNameRecordsParams defines parameters for GetDomainsDomainNameRecords.
type GetDomainsDomainNameRecordsParams struct {
	// Type
	// | Value | Description |
	// | ----- | ----------- |
	// | A | Map an IPv4 address to a hostname. |
	// | AAAA | Map an IPv6 address to a hostname. |
	// | CAA | Restrict which certificate authorities are permitted to issue certificates for a domain. |
	// | CNAME | Define an alias for your canonical hostname. |
	// | MX | Define the mail exchanges that handle mail for the domain. |
	// | NS | Define the nameservers that manage the domain. |
	// | SOA | The Start of Authority record for the zone. |
	// | SRV | Specify a server by hostname and port to handle a service or services. |
	// | TXT | Define a string of text that is associated with a hostname. |
	//
	Type *DomainRecordType `form:"type,omitempty" json:"type,omitempty"`

	// Name Only return records for this subdomain name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetDomainsDomainNameRecordsParamsDomainName0 defines parameters for GetDomainsDomainNameRecords.
type GetDomainsDomainNameRecordsParamsDomainName0 = int

// GetDomainsDomainNameRecordsParamsDomainName1 defines parameters for GetDomainsDomainNameRecords.
type GetDomainsDomainNameRecordsParamsDomainName1 = string

// PostDomainsDomainNameRecordsJSONBody defines parameters for PostDomainsDomainNameRecords.
type PostDomainsDomainNameRecordsJSONBody = DomainRecordRequest

// PostDomainsDomainNameRecordsParamsDomainName0 defines parameters for PostDomainsDomainNameRecords.
type PostDomainsDomainNameRecordsParamsDomainName0 = int

// PostDomainsDomainNameRecordsParamsDomainName1 defines parameters for PostDomainsDomainNameRecords.
type PostDomainsDomainNameRecordsParamsDomainName1 = string

// DeleteDomainsDomainNameRecordsRecordIdParamsDomainName0 defines parameters for DeleteDomainsDomainNameRecordsRecordId.
type DeleteDomainsDomainNameRecordsRecordIdParamsDomainName0 = int

// DeleteDomainsDomainNameRecordsRecordIdParamsDomainName1 defines parameters for DeleteDomainsDomainNameRecordsRecordId.
type DeleteDomainsDomainNameRecordsRecordIdParamsDomainName1 = string

// GetDomainsDomainNameRecordsRecordIdParamsDomainName0 defines parameters for GetDomainsDomainNameRecordsRecordId.
type GetDomainsDomainNameRecordsRecordIdParamsDomainName0 = int

// GetDomainsDomainNameRecordsRecordIdParamsDomainName1 defines parameters for GetDomainsDomainNameRecordsRecordId.
type GetDomainsDomainNameRecordsRecordIdParamsDomainName1 = string

// PutDomainsDomainNameRecordsRecordIdJSONBody defines parameters for PutDomainsDomainNameRecordsRecordId.
type PutDomainsDomainNameRecordsRecordIdJSONBody = UpdateDomainRecordRequest

// PutDomainsDomainNameRecordsRecordIdParamsDomainName0 defines parameters for PutDomainsDomainNameRecordsRecordId.
type PutDomainsDomainNameRecordsRecordIdParamsDomainName0 = int

// PutDomainsDomainNameRecordsRecordIdParamsDomainName1 defines parameters for PutDomainsDomainNameRecordsRecordId.
type PutDomainsDomainNameRecordsRecordIdParamsDomainName1 = string

// GetImagesParams defines parameters for GetImages.
type GetImagesParams struct {
	// Type Queries for distribution will include images that have pre-installed applications.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Private Provide 'true' to only list private images. 'false' has no effect.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetImagesImageIdOrSlugParamsImageIdOrSlug0 defines parameters for GetImagesImageIdOrSlug.
type GetImagesImageIdOrSlugParamsImageIdOrSlug0 = int

// GetImagesImageIdOrSlugParamsImageIdOrSlug1 defines parameters for GetImagesImageIdOrSlug.
type GetImagesImageIdOrSlugParamsImageIdOrSlug1 = string

// GetLoadBalancersParams defines parameters for GetLoadBalancers.
type GetLoadBalancersParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostLoadBalancersJSONBody defines parameters for PostLoadBalancers.
type PostLoadBalancersJSONBody = CreateLoadBalancerRequest

// PutLoadBalancersLoadBalancerIdJSONBody defines parameters for PutLoadBalancersLoadBalancerId.
type PutLoadBalancersLoadBalancerIdJSONBody = UpdateLoadBalancerRequest

// DeleteLoadBalancersLoadBalancerIdForwardingRulesJSONBody defines parameters for DeleteLoadBalancersLoadBalancerIdForwardingRules.
type DeleteLoadBalancersLoadBalancerIdForwardingRulesJSONBody = ForwardingRulesRequest

// PostLoadBalancersLoadBalancerIdForwardingRulesJSONBody defines parameters for PostLoadBalancersLoadBalancerIdForwardingRules.
type PostLoadBalancersLoadBalancerIdForwardingRulesJSONBody = ForwardingRulesRequest

// DeleteLoadBalancersLoadBalancerIdServersJSONBody defines parameters for DeleteLoadBalancersLoadBalancerIdServers.
type DeleteLoadBalancersLoadBalancerIdServersJSONBody = ServerIdsRequest

// PostLoadBalancersLoadBalancerIdServersJSONBody defines parameters for PostLoadBalancersLoadBalancerIdServers.
type PostLoadBalancersLoadBalancerIdServersJSONBody = ServerIdsRequest

// GetRegionsParams defines parameters for GetRegions.
type GetRegionsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetReverseNamesIpv6Params defines parameters for GetReverseNamesIpv6.
type GetReverseNamesIpv6Params struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostReverseNamesIpv6JSONBody defines parameters for PostReverseNamesIpv6.
type PostReverseNamesIpv6JSONBody = ReverseNameserversRequest

// GetSamplesetsServerIdParams defines parameters for GetSamplesetsServerId.
type GetSamplesetsServerIdParams struct {
	// DataInterval
	// | Value | Description |
	// | ----- | ----------- |
	// | five-minute | 5 Minutes |
	// | half-hour | 30 Minutes |
	// | four-hour | 4 Hours |
	// | day | 1 Day |
	// | week | 7 Days |
	// | month | 1 Month |
	//
	DataInterval *DataInterval `form:"data_interval,omitempty" json:"data_interval,omitempty"`

	// Start The start of the window of samples to retrieve, ISO8601 format (eg 2022-12-30T22:50:00Z). Defaults to 1 week before end for intervals larger than 5 minutes, or 1 day for 5 minute intervals.
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End The start of the window of samples to retrieve, ISO8601 format (eg 2022-12-30T22:50:00Z). Defaults to 1 week or 1 day after start date depending on the selected data interval (or the current time if start is not provided). Can't be more than 1 year from start.
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSamplesetsServerIdLatestParams defines parameters for GetSamplesetsServerIdLatest.
type GetSamplesetsServerIdLatestParams struct {
	// DataInterval
	// | Value | Description |
	// | ----- | ----------- |
	// | five-minute | 5 Minutes |
	// | half-hour | 30 Minutes |
	// | four-hour | 4 Hours |
	// | day | 1 Day |
	// | week | 7 Days |
	// | month | 1 Month |
	//
	DataInterval *DataInterval `form:"data_interval,omitempty" json:"data_interval,omitempty"`
}

// GetServersParams defines parameters for GetServers.
type GetServersParams struct {
	// Hostname Providing a hostname restricts the results to the server that has this hostname (case insensitive). If this parameter is provided at most 1 server will be returned.
	Hostname *string `form:"hostname,omitempty" json:"hostname,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostServersJSONBody defines parameters for PostServers.
type PostServersJSONBody = CreateServerRequest

// DeleteServersServerIdParams defines parameters for DeleteServersServerId.
type DeleteServersServerIdParams struct {
	// Reason The reason for cancelling the server.
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`
}

// GetServersServerIdActionsParams defines parameters for GetServersServerIdActions.
type GetServersServerIdActionsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostServersServerIdActionsJSONBody defines parameters for PostServersServerIdActions.
type PostServersServerIdActionsJSONBody = ServerAction

// GetServersServerIdBackupsParams defines parameters for GetServersServerIdBackups.
type GetServersServerIdBackupsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostServersServerIdBackupsJSONBody defines parameters for PostServersServerIdBackups.
type PostServersServerIdBackupsJSONBody = UploadImageRequest

// GetServersServerIdKernelsParams defines parameters for GetServersServerIdKernels.
type GetServersServerIdKernelsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetServersServerIdSnapshotsParams defines parameters for GetServersServerIdSnapshots.
type GetServersServerIdSnapshotsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetServersServerIdSoftwareParams defines parameters for GetServersServerIdSoftware.
type GetServersServerIdSoftwareParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSizesParams defines parameters for GetSizes.
type GetSizesParams struct {
	// ServerId If supplied only sizes available for a resize the specified server will be returned. This parameter is only available when authenticated.
	ServerId *int64 `form:"server_id,omitempty" json:"server_id,omitempty"`

	// Image If null or not provided regions that support the size are included in the returned objects regardless of operating system. If this is provided it must be the id or slug of an operating system image and will cause only valid regions for the size and operating system to be included in the returned objects.
	Image *string `form:"image,omitempty" json:"image,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSoftwareParams defines parameters for GetSoftware.
type GetSoftwareParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSoftwareOperatingSystemOperatingSystemIdOrSlugParams defines parameters for GetSoftwareOperatingSystemOperatingSystemIdOrSlug.
type GetSoftwareOperatingSystemOperatingSystemIdOrSlugParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetSoftwareOperatingSystemOperatingSystemIdOrSlugParamsOperatingSystemIdOrSlug0 defines parameters for GetSoftwareOperatingSystemOperatingSystemIdOrSlug.
type GetSoftwareOperatingSystemOperatingSystemIdOrSlugParamsOperatingSystemIdOrSlug0 = int

// GetSoftwareOperatingSystemOperatingSystemIdOrSlugParamsOperatingSystemIdOrSlug1 defines parameters for GetSoftwareOperatingSystemOperatingSystemIdOrSlug.
type GetSoftwareOperatingSystemOperatingSystemIdOrSlugParamsOperatingSystemIdOrSlug1 = string

// GetVpcsParams defines parameters for GetVpcs.
type GetVpcsParams struct {
	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostVpcsJSONBody defines parameters for PostVpcs.
type PostVpcsJSONBody = CreateVpcRequest

// PatchVpcsVpcIdJSONBody defines parameters for PatchVpcsVpcId.
type PatchVpcsVpcIdJSONBody = PatchVpcRequest

// PutVpcsVpcIdJSONBody defines parameters for PutVpcsVpcId.
type PutVpcsVpcIdJSONBody = UpdateVpcRequest

// GetVpcsVpcIdMembersParams defines parameters for GetVpcsVpcIdMembers.
type GetVpcsVpcIdMembersParams struct {
	// ResourceType
	// | Value | Description |
	// | ----- | ----------- |
	// | server | Server |
	// | load-balancer | Load Balancer |
	// | ssh-key | SSH Key |
	// | vpc | Virtual Private Network |
	// | image | Backup or Operating System Image |
	// | registered-domain-name | Registered Domain Name |
	//
	ResourceType *ResourceType `form:"resource_type,omitempty" json:"resource_type,omitempty"`

	// Page The selected page. Page numbering starts at 1
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of results to show per page.
	PerPage *int32 `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// PostAccountKeysJSONRequestBody defines body for PostAccountKeys for application/json ContentType.
type PostAccountKeysJSONRequestBody = PostAccountKeysJSONBody

// PutAccountKeysKeyIdJSONRequestBody defines body for PutAccountKeysKeyId for application/json ContentType.
type PutAccountKeysKeyIdJSONRequestBody = PutAccountKeysKeyIdJSONBody

// PostActionsActionIdProceedJSONRequestBody defines body for PostActionsActionIdProceed for application/json ContentType.
type PostActionsActionIdProceedJSONRequestBody = PostActionsActionIdProceedJSONBody

// PostDomainsJSONRequestBody defines body for PostDomains for application/json ContentType.
type PostDomainsJSONRequestBody = PostDomainsJSONBody

// PostDomainsRefreshNameserverCacheJSONRequestBody defines body for PostDomainsRefreshNameserverCache for application/json ContentType.
type PostDomainsRefreshNameserverCacheJSONRequestBody = PostDomainsRefreshNameserverCacheJSONBody

// PostDomainsDomainNameRecordsJSONRequestBody defines body for PostDomainsDomainNameRecords for application/json ContentType.
type PostDomainsDomainNameRecordsJSONRequestBody = PostDomainsDomainNameRecordsJSONBody

// PutDomainsDomainNameRecordsRecordIdJSONRequestBody defines body for PutDomainsDomainNameRecordsRecordId for application/json ContentType.
type PutDomainsDomainNameRecordsRecordIdJSONRequestBody = PutDomainsDomainNameRecordsRecordIdJSONBody

// PostLoadBalancersJSONRequestBody defines body for PostLoadBalancers for application/json ContentType.
type PostLoadBalancersJSONRequestBody = PostLoadBalancersJSONBody

// PutLoadBalancersLoadBalancerIdJSONRequestBody defines body for PutLoadBalancersLoadBalancerId for application/json ContentType.
type PutLoadBalancersLoadBalancerIdJSONRequestBody = PutLoadBalancersLoadBalancerIdJSONBody

// DeleteLoadBalancersLoadBalancerIdForwardingRulesJSONRequestBody defines body for DeleteLoadBalancersLoadBalancerIdForwardingRules for application/json ContentType.
type DeleteLoadBalancersLoadBalancerIdForwardingRulesJSONRequestBody = DeleteLoadBalancersLoadBalancerIdForwardingRulesJSONBody

// PostLoadBalancersLoadBalancerIdForwardingRulesJSONRequestBody defines body for PostLoadBalancersLoadBalancerIdForwardingRules for application/json ContentType.
type PostLoadBalancersLoadBalancerIdForwardingRulesJSONRequestBody = PostLoadBalancersLoadBalancerIdForwardingRulesJSONBody

// DeleteLoadBalancersLoadBalancerIdServersJSONRequestBody defines body for DeleteLoadBalancersLoadBalancerIdServers for application/json ContentType.
type DeleteLoadBalancersLoadBalancerIdServersJSONRequestBody = DeleteLoadBalancersLoadBalancerIdServersJSONBody

// PostLoadBalancersLoadBalancerIdServersJSONRequestBody defines body for PostLoadBalancersLoadBalancerIdServers for application/json ContentType.
type PostLoadBalancersLoadBalancerIdServersJSONRequestBody = PostLoadBalancersLoadBalancerIdServersJSONBody

// PostReverseNamesIpv6JSONRequestBody defines body for PostReverseNamesIpv6 for application/json ContentType.
type PostReverseNamesIpv6JSONRequestBody = PostReverseNamesIpv6JSONBody

// PostServersJSONRequestBody defines body for PostServers for application/json ContentType.
type PostServersJSONRequestBody = PostServersJSONBody

// PostServersServerIdActionsJSONRequestBody defines body for PostServersServerIdActions for application/json ContentType.
type PostServersServerIdActionsJSONRequestBody = PostServersServerIdActionsJSONBody

// PostServersServerIdActionsAddDiskJSONRequestBody defines body for PostServersServerIdActionsAddDisk for application/json ContentType.
type PostServersServerIdActionsAddDiskJSONRequestBody = AddDisk

// PostServersServerIdActionsAttachBackupJSONRequestBody defines body for PostServersServerIdActionsAttachBackup for application/json ContentType.
type PostServersServerIdActionsAttachBackupJSONRequestBody = AttachBackup

// PostServersServerIdActionsChangeAdvancedFeaturesJSONRequestBody defines body for PostServersServerIdActionsChangeAdvancedFeatures for application/json ContentType.
type PostServersServerIdActionsChangeAdvancedFeaturesJSONRequestBody = ChangeAdvancedFeatures

// PostServersServerIdActionsChangeAdvancedFirewallRulesJSONRequestBody defines body for PostServersServerIdActionsChangeAdvancedFirewallRules for application/json ContentType.
type PostServersServerIdActionsChangeAdvancedFirewallRulesJSONRequestBody = ChangeAdvancedFirewallRules

// PostServersServerIdActionsChangeBackupScheduleJSONRequestBody defines body for PostServersServerIdActionsChangeBackupSchedule for application/json ContentType.
type PostServersServerIdActionsChangeBackupScheduleJSONRequestBody = ChangeBackupSchedule

// PostServersServerIdActionsChangeIpv6JSONRequestBody defines body for PostServersServerIdActionsChangeIpv6 for application/json ContentType.
type PostServersServerIdActionsChangeIpv6JSONRequestBody = ChangeIpv6

// PostServersServerIdActionsChangeIpv6ReverseNameserversJSONRequestBody defines body for PostServersServerIdActionsChangeIpv6ReverseNameservers for application/json ContentType.
type PostServersServerIdActionsChangeIpv6ReverseNameserversJSONRequestBody = ChangeIpv6ReverseNameservers

// PostServersServerIdActionsChangeKernelJSONRequestBody defines body for PostServersServerIdActionsChangeKernel for application/json ContentType.
type PostServersServerIdActionsChangeKernelJSONRequestBody = ChangeKernel

// PostServersServerIdActionsChangeManageOffsiteBackupCopiesJSONRequestBody defines body for PostServersServerIdActionsChangeManageOffsiteBackupCopies for application/json ContentType.
type PostServersServerIdActionsChangeManageOffsiteBackupCopiesJSONRequestBody = ChangeManageOffsiteBackupCopies

// PostServersServerIdActionsChangeNetworkJSONRequestBody defines body for PostServersServerIdActionsChangeNetwork for application/json ContentType.
type PostServersServerIdActionsChangeNetworkJSONRequestBody = ChangeNetwork

// PostServersServerIdActionsChangeOffsiteBackupLocationJSONRequestBody defines body for PostServersServerIdActionsChangeOffsiteBackupLocation for application/json ContentType.
type PostServersServerIdActionsChangeOffsiteBackupLocationJSONRequestBody = ChangeOffsiteBackupLocation

// PostServersServerIdActionsChangePartnerJSONRequestBody defines body for PostServersServerIdActionsChangePartner for application/json ContentType.
type PostServersServerIdActionsChangePartnerJSONRequestBody = ChangePartner

// PostServersServerIdActionsChangePortBlockingJSONRequestBody defines body for PostServersServerIdActionsChangePortBlocking for application/json ContentType.
type PostServersServerIdActionsChangePortBlockingJSONRequestBody = ChangePortBlocking

// PostServersServerIdActionsChangeRegionJSONRequestBody defines body for PostServersServerIdActionsChangeRegion for application/json ContentType.
type PostServersServerIdActionsChangeRegionJSONRequestBody = ChangeRegion

// PostServersServerIdActionsChangeReverseNameJSONRequestBody defines body for PostServersServerIdActionsChangeReverseName for application/json ContentType.
type PostServersServerIdActionsChangeReverseNameJSONRequestBody = ChangeReverseName

// PostServersServerIdActionsChangeSeparatePrivateNetworkInterfaceJSONRequestBody defines body for PostServersServerIdActionsChangeSeparatePrivateNetworkInterface for application/json ContentType.
type PostServersServerIdActionsChangeSeparatePrivateNetworkInterfaceJSONRequestBody = ChangeSeparatePrivateNetworkInterface

// PostServersServerIdActionsChangeSourceAndDestinationCheckJSONRequestBody defines body for PostServersServerIdActionsChangeSourceAndDestinationCheck for application/json ContentType.
type PostServersServerIdActionsChangeSourceAndDestinationCheckJSONRequestBody = ChangeSourceAndDestinationCheck

// PostServersServerIdActionsChangeThresholdAlertsJSONRequestBody defines body for PostServersServerIdActionsChangeThresholdAlerts for application/json ContentType.
type PostServersServerIdActionsChangeThresholdAlertsJSONRequestBody = ChangeThresholdAlerts

// PostServersServerIdActionsChangeVpcIpv4JSONRequestBody defines body for PostServersServerIdActionsChangeVpcIpv4 for application/json ContentType.
type PostServersServerIdActionsChangeVpcIpv4JSONRequestBody = ChangeVpcIpv4

// PostServersServerIdActionsCloneUsingBackupJSONRequestBody defines body for PostServersServerIdActionsCloneUsingBackup for application/json ContentType.
type PostServersServerIdActionsCloneUsingBackupJSONRequestBody = CloneUsingBackup

// PostServersServerIdActionsDeleteDiskJSONRequestBody defines body for PostServersServerIdActionsDeleteDisk for application/json ContentType.
type PostServersServerIdActionsDeleteDiskJSONRequestBody = DeleteDisk

// PostServersServerIdActionsDetachBackupJSONRequestBody defines body for PostServersServerIdActionsDetachBackup for application/json ContentType.
type PostServersServerIdActionsDetachBackupJSONRequestBody = DetachBackup

// PostServersServerIdActionsDisableBackupsJSONRequestBody defines body for PostServersServerIdActionsDisableBackups for application/json ContentType.
type PostServersServerIdActionsDisableBackupsJSONRequestBody = DisableBackups

// PostServersServerIdActionsDisableSelinuxJSONRequestBody defines body for PostServersServerIdActionsDisableSelinux for application/json ContentType.
type PostServersServerIdActionsDisableSelinuxJSONRequestBody = DisableSelinux

// PostServersServerIdActionsEnableBackupsJSONRequestBody defines body for PostServersServerIdActionsEnableBackups for application/json ContentType.
type PostServersServerIdActionsEnableBackupsJSONRequestBody = EnableBackups

// PostServersServerIdActionsEnableIpv6JSONRequestBody defines body for PostServersServerIdActionsEnableIpv6 for application/json ContentType.
type PostServersServerIdActionsEnableIpv6JSONRequestBody = EnableIpv6

// PostServersServerIdActionsIsRunningJSONRequestBody defines body for PostServersServerIdActionsIsRunning for application/json ContentType.
type PostServersServerIdActionsIsRunningJSONRequestBody = IsRunning

// PostServersServerIdActionsPasswordResetJSONRequestBody defines body for PostServersServerIdActionsPasswordReset for application/json ContentType.
type PostServersServerIdActionsPasswordResetJSONRequestBody = PasswordReset

// PostServersServerIdActionsPingJSONRequestBody defines body for PostServersServerIdActionsPing for application/json ContentType.
type PostServersServerIdActionsPingJSONRequestBody = Ping

// PostServersServerIdActionsPowerCycleJSONRequestBody defines body for PostServersServerIdActionsPowerCycle for application/json ContentType.
type PostServersServerIdActionsPowerCycleJSONRequestBody = PowerCycle

// PostServersServerIdActionsPowerOffJSONRequestBody defines body for PostServersServerIdActionsPowerOff for application/json ContentType.
type PostServersServerIdActionsPowerOffJSONRequestBody = PowerOff

// PostServersServerIdActionsPowerOnJSONRequestBody defines body for PostServersServerIdActionsPowerOn for application/json ContentType.
type PostServersServerIdActionsPowerOnJSONRequestBody = PowerOn

// PostServersServerIdActionsRebootJSONRequestBody defines body for PostServersServerIdActionsReboot for application/json ContentType.
type PostServersServerIdActionsRebootJSONRequestBody = Reboot

// PostServersServerIdActionsRebuildJSONRequestBody defines body for PostServersServerIdActionsRebuild for application/json ContentType.
type PostServersServerIdActionsRebuildJSONRequestBody = Rebuild

// PostServersServerIdActionsRenameJSONRequestBody defines body for PostServersServerIdActionsRename for application/json ContentType.
type PostServersServerIdActionsRenameJSONRequestBody = Rename

// PostServersServerIdActionsResizeJSONRequestBody defines body for PostServersServerIdActionsResize for application/json ContentType.
type PostServersServerIdActionsResizeJSONRequestBody = Resize

// PostServersServerIdActionsResizeDiskJSONRequestBody defines body for PostServersServerIdActionsResizeDisk for application/json ContentType.
type PostServersServerIdActionsResizeDiskJSONRequestBody = ResizeDisk

// PostServersServerIdActionsRestoreJSONRequestBody defines body for PostServersServerIdActionsRestore for application/json ContentType.
type PostServersServerIdActionsRestoreJSONRequestBody = Restore

// PostServersServerIdActionsShutdownJSONRequestBody defines body for PostServersServerIdActionsShutdown for application/json ContentType.
type PostServersServerIdActionsShutdownJSONRequestBody = Shutdown

// PostServersServerIdActionsTakeBackupJSONRequestBody defines body for PostServersServerIdActionsTakeBackup for application/json ContentType.
type PostServersServerIdActionsTakeBackupJSONRequestBody = TakeBackup

// PostServersServerIdActionsUncancelJSONRequestBody defines body for PostServersServerIdActionsUncancel for application/json ContentType.
type PostServersServerIdActionsUncancelJSONRequestBody = Uncancel

// PostServersServerIdActionsUptimeJSONRequestBody defines body for PostServersServerIdActionsUptime for application/json ContentType.
type PostServersServerIdActionsUptimeJSONRequestBody = Uptime

// PostServersServerIdBackupsJSONRequestBody defines body for PostServersServerIdBackups for application/json ContentType.
type PostServersServerIdBackupsJSONRequestBody = PostServersServerIdBackupsJSONBody

// PostVpcsJSONRequestBody defines body for PostVpcs for application/json ContentType.
type PostVpcsJSONRequestBody = PostVpcsJSONBody

// PatchVpcsVpcIdJSONRequestBody defines body for PatchVpcsVpcId for application/json ContentType.
type PatchVpcsVpcIdJSONRequestBody = PatchVpcsVpcIdJSONBody

// PutVpcsVpcIdJSONRequestBody defines body for PutVpcsVpcId for application/json ContentType.
type PutVpcsVpcIdJSONRequestBody = PutVpcsVpcIdJSONBody

// AsNetworkNetmask0 returns the union data inside the Network_Netmask as a NetworkNetmask0
func (t Network_Netmask) AsNetworkNetmask0() (NetworkNetmask0, error) {
	var body NetworkNetmask0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkNetmask0 overwrites any union data inside the Network_Netmask as the provided NetworkNetmask0
func (t *Network_Netmask) FromNetworkNetmask0(v NetworkNetmask0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkNetmask0 performs a merge with any union data inside the Network_Netmask, using the provided NetworkNetmask0
func (t *Network_Netmask) MergeNetworkNetmask0(v NetworkNetmask0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkNetmask1 returns the union data inside the Network_Netmask as a NetworkNetmask1
func (t Network_Netmask) AsNetworkNetmask1() (NetworkNetmask1, error) {
	var body NetworkNetmask1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkNetmask1 overwrites any union data inside the Network_Netmask as the provided NetworkNetmask1
func (t *Network_Netmask) FromNetworkNetmask1(v NetworkNetmask1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkNetmask1 performs a merge with any union data inside the Network_Netmask, using the provided NetworkNetmask1
func (t *Network_Netmask) MergeNetworkNetmask1(v NetworkNetmask1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Network_Netmask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Network_Netmask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRestoreImage0 returns the union data inside the Restore_Image as a RestoreImage0
func (t Restore_Image) AsRestoreImage0() (RestoreImage0, error) {
	var body RestoreImage0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestoreImage0 overwrites any union data inside the Restore_Image as the provided RestoreImage0
func (t *Restore_Image) FromRestoreImage0(v RestoreImage0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestoreImage0 performs a merge with any union data inside the Restore_Image, using the provided RestoreImage0
func (t *Restore_Image) MergeRestoreImage0(v RestoreImage0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRestoreImage1 returns the union data inside the Restore_Image as a RestoreImage1
func (t Restore_Image) AsRestoreImage1() (RestoreImage1, error) {
	var body RestoreImage1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestoreImage1 overwrites any union data inside the Restore_Image as the provided RestoreImage1
func (t *Restore_Image) FromRestoreImage1(v RestoreImage1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestoreImage1 performs a merge with any union data inside the Restore_Image, using the provided RestoreImage1
func (t *Restore_Image) MergeRestoreImage1(v RestoreImage1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Restore_Image) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Restore_Image) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAddDisk returns the union data inside the ServerAction as a AddDisk
func (t ServerAction) AsAddDisk() (AddDisk, error) {
	var body AddDisk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAddDisk overwrites any union data inside the ServerAction as the provided AddDisk
func (t *ServerAction) FromAddDisk(v AddDisk) error {
	t.Type = "add_disk"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAddDisk performs a merge with any union data inside the ServerAction, using the provided AddDisk
func (t *ServerAction) MergeAddDisk(v AddDisk) error {
	t.Type = "add_disk"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAttachBackup returns the union data inside the ServerAction as a AttachBackup
func (t ServerAction) AsAttachBackup() (AttachBackup, error) {
	var body AttachBackup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAttachBackup overwrites any union data inside the ServerAction as the provided AttachBackup
func (t *ServerAction) FromAttachBackup(v AttachBackup) error {
	t.Type = "attach_backup"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAttachBackup performs a merge with any union data inside the ServerAction, using the provided AttachBackup
func (t *ServerAction) MergeAttachBackup(v AttachBackup) error {
	t.Type = "attach_backup"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeAdvancedFeatures returns the union data inside the ServerAction as a ChangeAdvancedFeatures
func (t ServerAction) AsChangeAdvancedFeatures() (ChangeAdvancedFeatures, error) {
	var body ChangeAdvancedFeatures
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeAdvancedFeatures overwrites any union data inside the ServerAction as the provided ChangeAdvancedFeatures
func (t *ServerAction) FromChangeAdvancedFeatures(v ChangeAdvancedFeatures) error {
	t.Type = "change_advanced_features"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeAdvancedFeatures performs a merge with any union data inside the ServerAction, using the provided ChangeAdvancedFeatures
func (t *ServerAction) MergeChangeAdvancedFeatures(v ChangeAdvancedFeatures) error {
	t.Type = "change_advanced_features"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeAdvancedFirewallRules returns the union data inside the ServerAction as a ChangeAdvancedFirewallRules
func (t ServerAction) AsChangeAdvancedFirewallRules() (ChangeAdvancedFirewallRules, error) {
	var body ChangeAdvancedFirewallRules
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeAdvancedFirewallRules overwrites any union data inside the ServerAction as the provided ChangeAdvancedFirewallRules
func (t *ServerAction) FromChangeAdvancedFirewallRules(v ChangeAdvancedFirewallRules) error {
	t.Type = "change_advanced_firewall_rules"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeAdvancedFirewallRules performs a merge with any union data inside the ServerAction, using the provided ChangeAdvancedFirewallRules
func (t *ServerAction) MergeChangeAdvancedFirewallRules(v ChangeAdvancedFirewallRules) error {
	t.Type = "change_advanced_firewall_rules"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeBackupSchedule returns the union data inside the ServerAction as a ChangeBackupSchedule
func (t ServerAction) AsChangeBackupSchedule() (ChangeBackupSchedule, error) {
	var body ChangeBackupSchedule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeBackupSchedule overwrites any union data inside the ServerAction as the provided ChangeBackupSchedule
func (t *ServerAction) FromChangeBackupSchedule(v ChangeBackupSchedule) error {
	t.Type = "change_backup_schedule"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeBackupSchedule performs a merge with any union data inside the ServerAction, using the provided ChangeBackupSchedule
func (t *ServerAction) MergeChangeBackupSchedule(v ChangeBackupSchedule) error {
	t.Type = "change_backup_schedule"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeIpv6 returns the union data inside the ServerAction as a ChangeIpv6
func (t ServerAction) AsChangeIpv6() (ChangeIpv6, error) {
	var body ChangeIpv6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeIpv6 overwrites any union data inside the ServerAction as the provided ChangeIpv6
func (t *ServerAction) FromChangeIpv6(v ChangeIpv6) error {
	t.Type = "change_ipv6"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeIpv6 performs a merge with any union data inside the ServerAction, using the provided ChangeIpv6
func (t *ServerAction) MergeChangeIpv6(v ChangeIpv6) error {
	t.Type = "change_ipv6"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeIpv6ReverseNameservers returns the union data inside the ServerAction as a ChangeIpv6ReverseNameservers
func (t ServerAction) AsChangeIpv6ReverseNameservers() (ChangeIpv6ReverseNameservers, error) {
	var body ChangeIpv6ReverseNameservers
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeIpv6ReverseNameservers overwrites any union data inside the ServerAction as the provided ChangeIpv6ReverseNameservers
func (t *ServerAction) FromChangeIpv6ReverseNameservers(v ChangeIpv6ReverseNameservers) error {
	t.Type = "change_ipv6_reverse_nameservers"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeIpv6ReverseNameservers performs a merge with any union data inside the ServerAction, using the provided ChangeIpv6ReverseNameservers
func (t *ServerAction) MergeChangeIpv6ReverseNameservers(v ChangeIpv6ReverseNameservers) error {
	t.Type = "change_ipv6_reverse_nameservers"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeKernel returns the union data inside the ServerAction as a ChangeKernel
func (t ServerAction) AsChangeKernel() (ChangeKernel, error) {
	var body ChangeKernel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeKernel overwrites any union data inside the ServerAction as the provided ChangeKernel
func (t *ServerAction) FromChangeKernel(v ChangeKernel) error {
	t.Type = "change_kernel"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeKernel performs a merge with any union data inside the ServerAction, using the provided ChangeKernel
func (t *ServerAction) MergeChangeKernel(v ChangeKernel) error {
	t.Type = "change_kernel"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeManageOffsiteBackupCopies returns the union data inside the ServerAction as a ChangeManageOffsiteBackupCopies
func (t ServerAction) AsChangeManageOffsiteBackupCopies() (ChangeManageOffsiteBackupCopies, error) {
	var body ChangeManageOffsiteBackupCopies
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeManageOffsiteBackupCopies overwrites any union data inside the ServerAction as the provided ChangeManageOffsiteBackupCopies
func (t *ServerAction) FromChangeManageOffsiteBackupCopies(v ChangeManageOffsiteBackupCopies) error {
	t.Type = "change_manage_offsite_backup_copies"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeManageOffsiteBackupCopies performs a merge with any union data inside the ServerAction, using the provided ChangeManageOffsiteBackupCopies
func (t *ServerAction) MergeChangeManageOffsiteBackupCopies(v ChangeManageOffsiteBackupCopies) error {
	t.Type = "change_manage_offsite_backup_copies"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeNetwork returns the union data inside the ServerAction as a ChangeNetwork
func (t ServerAction) AsChangeNetwork() (ChangeNetwork, error) {
	var body ChangeNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeNetwork overwrites any union data inside the ServerAction as the provided ChangeNetwork
func (t *ServerAction) FromChangeNetwork(v ChangeNetwork) error {
	t.Type = "change_network"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeNetwork performs a merge with any union data inside the ServerAction, using the provided ChangeNetwork
func (t *ServerAction) MergeChangeNetwork(v ChangeNetwork) error {
	t.Type = "change_network"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeOffsiteBackupLocation returns the union data inside the ServerAction as a ChangeOffsiteBackupLocation
func (t ServerAction) AsChangeOffsiteBackupLocation() (ChangeOffsiteBackupLocation, error) {
	var body ChangeOffsiteBackupLocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeOffsiteBackupLocation overwrites any union data inside the ServerAction as the provided ChangeOffsiteBackupLocation
func (t *ServerAction) FromChangeOffsiteBackupLocation(v ChangeOffsiteBackupLocation) error {
	t.Type = "change_offsite_backup_location"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeOffsiteBackupLocation performs a merge with any union data inside the ServerAction, using the provided ChangeOffsiteBackupLocation
func (t *ServerAction) MergeChangeOffsiteBackupLocation(v ChangeOffsiteBackupLocation) error {
	t.Type = "change_offsite_backup_location"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangePartner returns the union data inside the ServerAction as a ChangePartner
func (t ServerAction) AsChangePartner() (ChangePartner, error) {
	var body ChangePartner
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangePartner overwrites any union data inside the ServerAction as the provided ChangePartner
func (t *ServerAction) FromChangePartner(v ChangePartner) error {
	t.Type = "change_partner"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangePartner performs a merge with any union data inside the ServerAction, using the provided ChangePartner
func (t *ServerAction) MergeChangePartner(v ChangePartner) error {
	t.Type = "change_partner"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangePortBlocking returns the union data inside the ServerAction as a ChangePortBlocking
func (t ServerAction) AsChangePortBlocking() (ChangePortBlocking, error) {
	var body ChangePortBlocking
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangePortBlocking overwrites any union data inside the ServerAction as the provided ChangePortBlocking
func (t *ServerAction) FromChangePortBlocking(v ChangePortBlocking) error {
	t.Type = "change_port_blocking"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangePortBlocking performs a merge with any union data inside the ServerAction, using the provided ChangePortBlocking
func (t *ServerAction) MergeChangePortBlocking(v ChangePortBlocking) error {
	t.Type = "change_port_blocking"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeRegion returns the union data inside the ServerAction as a ChangeRegion
func (t ServerAction) AsChangeRegion() (ChangeRegion, error) {
	var body ChangeRegion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeRegion overwrites any union data inside the ServerAction as the provided ChangeRegion
func (t *ServerAction) FromChangeRegion(v ChangeRegion) error {
	t.Type = "change_region"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeRegion performs a merge with any union data inside the ServerAction, using the provided ChangeRegion
func (t *ServerAction) MergeChangeRegion(v ChangeRegion) error {
	t.Type = "change_region"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeReverseName returns the union data inside the ServerAction as a ChangeReverseName
func (t ServerAction) AsChangeReverseName() (ChangeReverseName, error) {
	var body ChangeReverseName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeReverseName overwrites any union data inside the ServerAction as the provided ChangeReverseName
func (t *ServerAction) FromChangeReverseName(v ChangeReverseName) error {
	t.Type = "change_reverse_name"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeReverseName performs a merge with any union data inside the ServerAction, using the provided ChangeReverseName
func (t *ServerAction) MergeChangeReverseName(v ChangeReverseName) error {
	t.Type = "change_reverse_name"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeSeparatePrivateNetworkInterface returns the union data inside the ServerAction as a ChangeSeparatePrivateNetworkInterface
func (t ServerAction) AsChangeSeparatePrivateNetworkInterface() (ChangeSeparatePrivateNetworkInterface, error) {
	var body ChangeSeparatePrivateNetworkInterface
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeSeparatePrivateNetworkInterface overwrites any union data inside the ServerAction as the provided ChangeSeparatePrivateNetworkInterface
func (t *ServerAction) FromChangeSeparatePrivateNetworkInterface(v ChangeSeparatePrivateNetworkInterface) error {
	t.Type = "change_separate_private_network_interface"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeSeparatePrivateNetworkInterface performs a merge with any union data inside the ServerAction, using the provided ChangeSeparatePrivateNetworkInterface
func (t *ServerAction) MergeChangeSeparatePrivateNetworkInterface(v ChangeSeparatePrivateNetworkInterface) error {
	t.Type = "change_separate_private_network_interface"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeSourceAndDestinationCheck returns the union data inside the ServerAction as a ChangeSourceAndDestinationCheck
func (t ServerAction) AsChangeSourceAndDestinationCheck() (ChangeSourceAndDestinationCheck, error) {
	var body ChangeSourceAndDestinationCheck
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeSourceAndDestinationCheck overwrites any union data inside the ServerAction as the provided ChangeSourceAndDestinationCheck
func (t *ServerAction) FromChangeSourceAndDestinationCheck(v ChangeSourceAndDestinationCheck) error {
	t.Type = "change_source_and_destination_check"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeSourceAndDestinationCheck performs a merge with any union data inside the ServerAction, using the provided ChangeSourceAndDestinationCheck
func (t *ServerAction) MergeChangeSourceAndDestinationCheck(v ChangeSourceAndDestinationCheck) error {
	t.Type = "change_source_and_destination_check"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeThresholdAlerts returns the union data inside the ServerAction as a ChangeThresholdAlerts
func (t ServerAction) AsChangeThresholdAlerts() (ChangeThresholdAlerts, error) {
	var body ChangeThresholdAlerts
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeThresholdAlerts overwrites any union data inside the ServerAction as the provided ChangeThresholdAlerts
func (t *ServerAction) FromChangeThresholdAlerts(v ChangeThresholdAlerts) error {
	t.Type = "change_threshold_alerts"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeThresholdAlerts performs a merge with any union data inside the ServerAction, using the provided ChangeThresholdAlerts
func (t *ServerAction) MergeChangeThresholdAlerts(v ChangeThresholdAlerts) error {
	t.Type = "change_threshold_alerts"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsChangeVpcIpv4 returns the union data inside the ServerAction as a ChangeVpcIpv4
func (t ServerAction) AsChangeVpcIpv4() (ChangeVpcIpv4, error) {
	var body ChangeVpcIpv4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChangeVpcIpv4 overwrites any union data inside the ServerAction as the provided ChangeVpcIpv4
func (t *ServerAction) FromChangeVpcIpv4(v ChangeVpcIpv4) error {
	t.Type = "change_vpc_ipv4"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChangeVpcIpv4 performs a merge with any union data inside the ServerAction, using the provided ChangeVpcIpv4
func (t *ServerAction) MergeChangeVpcIpv4(v ChangeVpcIpv4) error {
	t.Type = "change_vpc_ipv4"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCloneUsingBackup returns the union data inside the ServerAction as a CloneUsingBackup
func (t ServerAction) AsCloneUsingBackup() (CloneUsingBackup, error) {
	var body CloneUsingBackup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCloneUsingBackup overwrites any union data inside the ServerAction as the provided CloneUsingBackup
func (t *ServerAction) FromCloneUsingBackup(v CloneUsingBackup) error {
	t.Type = "clone_using_backup"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCloneUsingBackup performs a merge with any union data inside the ServerAction, using the provided CloneUsingBackup
func (t *ServerAction) MergeCloneUsingBackup(v CloneUsingBackup) error {
	t.Type = "clone_using_backup"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDeleteDisk returns the union data inside the ServerAction as a DeleteDisk
func (t ServerAction) AsDeleteDisk() (DeleteDisk, error) {
	var body DeleteDisk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeleteDisk overwrites any union data inside the ServerAction as the provided DeleteDisk
func (t *ServerAction) FromDeleteDisk(v DeleteDisk) error {
	t.Type = "delete_disk"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeleteDisk performs a merge with any union data inside the ServerAction, using the provided DeleteDisk
func (t *ServerAction) MergeDeleteDisk(v DeleteDisk) error {
	t.Type = "delete_disk"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDetachBackup returns the union data inside the ServerAction as a DetachBackup
func (t ServerAction) AsDetachBackup() (DetachBackup, error) {
	var body DetachBackup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDetachBackup overwrites any union data inside the ServerAction as the provided DetachBackup
func (t *ServerAction) FromDetachBackup(v DetachBackup) error {
	t.Type = "detach_backup"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDetachBackup performs a merge with any union data inside the ServerAction, using the provided DetachBackup
func (t *ServerAction) MergeDetachBackup(v DetachBackup) error {
	t.Type = "detach_backup"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDisableBackups returns the union data inside the ServerAction as a DisableBackups
func (t ServerAction) AsDisableBackups() (DisableBackups, error) {
	var body DisableBackups
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDisableBackups overwrites any union data inside the ServerAction as the provided DisableBackups
func (t *ServerAction) FromDisableBackups(v DisableBackups) error {
	t.Type = "disable_backups"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDisableBackups performs a merge with any union data inside the ServerAction, using the provided DisableBackups
func (t *ServerAction) MergeDisableBackups(v DisableBackups) error {
	t.Type = "disable_backups"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDisableSelinux returns the union data inside the ServerAction as a DisableSelinux
func (t ServerAction) AsDisableSelinux() (DisableSelinux, error) {
	var body DisableSelinux
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDisableSelinux overwrites any union data inside the ServerAction as the provided DisableSelinux
func (t *ServerAction) FromDisableSelinux(v DisableSelinux) error {
	t.Type = "disable_selinux"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDisableSelinux performs a merge with any union data inside the ServerAction, using the provided DisableSelinux
func (t *ServerAction) MergeDisableSelinux(v DisableSelinux) error {
	t.Type = "disable_selinux"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnableBackups returns the union data inside the ServerAction as a EnableBackups
func (t ServerAction) AsEnableBackups() (EnableBackups, error) {
	var body EnableBackups
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnableBackups overwrites any union data inside the ServerAction as the provided EnableBackups
func (t *ServerAction) FromEnableBackups(v EnableBackups) error {
	t.Type = "enable_backups"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnableBackups performs a merge with any union data inside the ServerAction, using the provided EnableBackups
func (t *ServerAction) MergeEnableBackups(v EnableBackups) error {
	t.Type = "enable_backups"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnableIpv6 returns the union data inside the ServerAction as a EnableIpv6
func (t ServerAction) AsEnableIpv6() (EnableIpv6, error) {
	var body EnableIpv6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnableIpv6 overwrites any union data inside the ServerAction as the provided EnableIpv6
func (t *ServerAction) FromEnableIpv6(v EnableIpv6) error {
	t.Type = "enable_ipv6"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnableIpv6 performs a merge with any union data inside the ServerAction, using the provided EnableIpv6
func (t *ServerAction) MergeEnableIpv6(v EnableIpv6) error {
	t.Type = "enable_ipv6"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIsRunning returns the union data inside the ServerAction as a IsRunning
func (t ServerAction) AsIsRunning() (IsRunning, error) {
	var body IsRunning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIsRunning overwrites any union data inside the ServerAction as the provided IsRunning
func (t *ServerAction) FromIsRunning(v IsRunning) error {
	t.Type = "is_running"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIsRunning performs a merge with any union data inside the ServerAction, using the provided IsRunning
func (t *ServerAction) MergeIsRunning(v IsRunning) error {
	t.Type = "is_running"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPasswordReset returns the union data inside the ServerAction as a PasswordReset
func (t ServerAction) AsPasswordReset() (PasswordReset, error) {
	var body PasswordReset
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPasswordReset overwrites any union data inside the ServerAction as the provided PasswordReset
func (t *ServerAction) FromPasswordReset(v PasswordReset) error {
	t.Type = "password_reset"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePasswordReset performs a merge with any union data inside the ServerAction, using the provided PasswordReset
func (t *ServerAction) MergePasswordReset(v PasswordReset) error {
	t.Type = "password_reset"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPing returns the union data inside the ServerAction as a Ping
func (t ServerAction) AsPing() (Ping, error) {
	var body Ping
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPing overwrites any union data inside the ServerAction as the provided Ping
func (t *ServerAction) FromPing(v Ping) error {
	t.Type = "ping"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePing performs a merge with any union data inside the ServerAction, using the provided Ping
func (t *ServerAction) MergePing(v Ping) error {
	t.Type = "ping"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerCycle returns the union data inside the ServerAction as a PowerCycle
func (t ServerAction) AsPowerCycle() (PowerCycle, error) {
	var body PowerCycle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerCycle overwrites any union data inside the ServerAction as the provided PowerCycle
func (t *ServerAction) FromPowerCycle(v PowerCycle) error {
	t.Type = "power_cycle"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerCycle performs a merge with any union data inside the ServerAction, using the provided PowerCycle
func (t *ServerAction) MergePowerCycle(v PowerCycle) error {
	t.Type = "power_cycle"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerOff returns the union data inside the ServerAction as a PowerOff
func (t ServerAction) AsPowerOff() (PowerOff, error) {
	var body PowerOff
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerOff overwrites any union data inside the ServerAction as the provided PowerOff
func (t *ServerAction) FromPowerOff(v PowerOff) error {
	t.Type = "power_off"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerOff performs a merge with any union data inside the ServerAction, using the provided PowerOff
func (t *ServerAction) MergePowerOff(v PowerOff) error {
	t.Type = "power_off"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPowerOn returns the union data inside the ServerAction as a PowerOn
func (t ServerAction) AsPowerOn() (PowerOn, error) {
	var body PowerOn
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPowerOn overwrites any union data inside the ServerAction as the provided PowerOn
func (t *ServerAction) FromPowerOn(v PowerOn) error {
	t.Type = "power_on"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePowerOn performs a merge with any union data inside the ServerAction, using the provided PowerOn
func (t *ServerAction) MergePowerOn(v PowerOn) error {
	t.Type = "power_on"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReboot returns the union data inside the ServerAction as a Reboot
func (t ServerAction) AsReboot() (Reboot, error) {
	var body Reboot
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReboot overwrites any union data inside the ServerAction as the provided Reboot
func (t *ServerAction) FromReboot(v Reboot) error {
	t.Type = "reboot"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReboot performs a merge with any union data inside the ServerAction, using the provided Reboot
func (t *ServerAction) MergeReboot(v Reboot) error {
	t.Type = "reboot"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRebuild returns the union data inside the ServerAction as a Rebuild
func (t ServerAction) AsRebuild() (Rebuild, error) {
	var body Rebuild
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRebuild overwrites any union data inside the ServerAction as the provided Rebuild
func (t *ServerAction) FromRebuild(v Rebuild) error {
	t.Type = "rebuild"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRebuild performs a merge with any union data inside the ServerAction, using the provided Rebuild
func (t *ServerAction) MergeRebuild(v Rebuild) error {
	t.Type = "rebuild"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRename returns the union data inside the ServerAction as a Rename
func (t ServerAction) AsRename() (Rename, error) {
	var body Rename
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRename overwrites any union data inside the ServerAction as the provided Rename
func (t *ServerAction) FromRename(v Rename) error {
	t.Type = "rename"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRename performs a merge with any union data inside the ServerAction, using the provided Rename
func (t *ServerAction) MergeRename(v Rename) error {
	t.Type = "rename"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResize returns the union data inside the ServerAction as a Resize
func (t ServerAction) AsResize() (Resize, error) {
	var body Resize
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResize overwrites any union data inside the ServerAction as the provided Resize
func (t *ServerAction) FromResize(v Resize) error {
	t.Type = "resize"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResize performs a merge with any union data inside the ServerAction, using the provided Resize
func (t *ServerAction) MergeResize(v Resize) error {
	t.Type = "resize"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResizeDisk returns the union data inside the ServerAction as a ResizeDisk
func (t ServerAction) AsResizeDisk() (ResizeDisk, error) {
	var body ResizeDisk
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResizeDisk overwrites any union data inside the ServerAction as the provided ResizeDisk
func (t *ServerAction) FromResizeDisk(v ResizeDisk) error {
	t.Type = "resize_disk"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResizeDisk performs a merge with any union data inside the ServerAction, using the provided ResizeDisk
func (t *ServerAction) MergeResizeDisk(v ResizeDisk) error {
	t.Type = "resize_disk"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRestore returns the union data inside the ServerAction as a Restore
func (t ServerAction) AsRestore() (Restore, error) {
	var body Restore
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRestore overwrites any union data inside the ServerAction as the provided Restore
func (t *ServerAction) FromRestore(v Restore) error {
	t.Type = "restore"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRestore performs a merge with any union data inside the ServerAction, using the provided Restore
func (t *ServerAction) MergeRestore(v Restore) error {
	t.Type = "restore"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsShutdown returns the union data inside the ServerAction as a Shutdown
func (t ServerAction) AsShutdown() (Shutdown, error) {
	var body Shutdown
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromShutdown overwrites any union data inside the ServerAction as the provided Shutdown
func (t *ServerAction) FromShutdown(v Shutdown) error {
	t.Type = "shutdown"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeShutdown performs a merge with any union data inside the ServerAction, using the provided Shutdown
func (t *ServerAction) MergeShutdown(v Shutdown) error {
	t.Type = "shutdown"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTakeBackup returns the union data inside the ServerAction as a TakeBackup
func (t ServerAction) AsTakeBackup() (TakeBackup, error) {
	var body TakeBackup
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTakeBackup overwrites any union data inside the ServerAction as the provided TakeBackup
func (t *ServerAction) FromTakeBackup(v TakeBackup) error {
	t.Type = "take_backup"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTakeBackup performs a merge with any union data inside the ServerAction, using the provided TakeBackup
func (t *ServerAction) MergeTakeBackup(v TakeBackup) error {
	t.Type = "take_backup"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUncancel returns the union data inside the ServerAction as a Uncancel
func (t ServerAction) AsUncancel() (Uncancel, error) {
	var body Uncancel
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUncancel overwrites any union data inside the ServerAction as the provided Uncancel
func (t *ServerAction) FromUncancel(v Uncancel) error {
	t.Type = "uncancel"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUncancel performs a merge with any union data inside the ServerAction, using the provided Uncancel
func (t *ServerAction) MergeUncancel(v Uncancel) error {
	t.Type = "uncancel"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUptime returns the union data inside the ServerAction as a Uptime
func (t ServerAction) AsUptime() (Uptime, error) {
	var body Uptime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUptime overwrites any union data inside the ServerAction as the provided Uptime
func (t *ServerAction) FromUptime(v Uptime) error {
	t.Type = "uptime"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUptime performs a merge with any union data inside the ServerAction, using the provided Uptime
func (t *ServerAction) MergeUptime(v Uptime) error {
	t.Type = "uptime"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServerAction) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ServerAction) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "add_disk":
		return t.AsAddDisk()
	case "attach_backup":
		return t.AsAttachBackup()
	case "change_advanced_features":
		return t.AsChangeAdvancedFeatures()
	case "change_advanced_firewall_rules":
		return t.AsChangeAdvancedFirewallRules()
	case "change_backup_schedule":
		return t.AsChangeBackupSchedule()
	case "change_ipv6":
		return t.AsChangeIpv6()
	case "change_ipv6_reverse_nameservers":
		return t.AsChangeIpv6ReverseNameservers()
	case "change_kernel":
		return t.AsChangeKernel()
	case "change_manage_offsite_backup_copies":
		return t.AsChangeManageOffsiteBackupCopies()
	case "change_network":
		return t.AsChangeNetwork()
	case "change_offsite_backup_location":
		return t.AsChangeOffsiteBackupLocation()
	case "change_partner":
		return t.AsChangePartner()
	case "change_port_blocking":
		return t.AsChangePortBlocking()
	case "change_region":
		return t.AsChangeRegion()
	case "change_reverse_name":
		return t.AsChangeReverseName()
	case "change_separate_private_network_interface":
		return t.AsChangeSeparatePrivateNetworkInterface()
	case "change_source_and_destination_check":
		return t.AsChangeSourceAndDestinationCheck()
	case "change_threshold_alerts":
		return t.AsChangeThresholdAlerts()
	case "change_vpc_ipv4":
		return t.AsChangeVpcIpv4()
	case "clone_using_backup":
		return t.AsCloneUsingBackup()
	case "delete_disk":
		return t.AsDeleteDisk()
	case "detach_backup":
		return t.AsDetachBackup()
	case "disable_backups":
		return t.AsDisableBackups()
	case "disable_selinux":
		return t.AsDisableSelinux()
	case "enable_backups":
		return t.AsEnableBackups()
	case "enable_ipv6":
		return t.AsEnableIpv6()
	case "is_running":
		return t.AsIsRunning()
	case "password_reset":
		return t.AsPasswordReset()
	case "ping":
		return t.AsPing()
	case "power_cycle":
		return t.AsPowerCycle()
	case "power_off":
		return t.AsPowerOff()
	case "power_on":
		return t.AsPowerOn()
	case "reboot":
		return t.AsReboot()
	case "rebuild":
		return t.AsRebuild()
	case "rename":
		return t.AsRename()
	case "resize":
		return t.AsResize()
	case "resize_disk":
		return t.AsResizeDisk()
	case "restore":
		return t.AsRestore()
	case "shutdown":
		return t.AsShutdown()
	case "take_backup":
		return t.AsTakeBackup()
	case "uncancel":
		return t.AsUncancel()
	case "uptime":
		return t.AsUptime()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ServerAction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *ServerAction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}
