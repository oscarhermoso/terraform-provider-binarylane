// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package data_sources

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func SizesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"image": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If null or not provided regions that support the size are included in the returned objects regardless of operating system. If this is provided it must be the id or slug of an operating system image and will cause only valid regions for the size and operating system to be included in the returned objects.",
				MarkdownDescription: "If null or not provided regions that support the size are included in the returned objects regardless of operating system. If this is provided it must be the id or slug of an operating system image and will cause only valid regions for the size and operating system to be included in the returned objects.",
			},
			"server_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "If supplied only sizes available for a resize the specified server will be returned. This parameter is only available when authenticated.",
				MarkdownDescription: "If supplied only sizes available for a resize the specified server will be returned. This parameter is only available when authenticated.",
			},
			"sizes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"available": schema.BoolAttribute{
							Computed:            true,
							Description:         "If this is false the size is not available for new servers.",
							MarkdownDescription: "If this is false the size is not available for new servers.",
						},
						"cpu_description": schema.StringAttribute{
							Computed:            true,
							Description:         "A description of the CPU provided in this size.",
							MarkdownDescription: "A description of the CPU provided in this size.",
						},
						"description": schema.StringAttribute{
							Computed:            true,
							Description:         "A description of this size.",
							MarkdownDescription: "A description of this size.",
						},
						"disk": schema.Int64Attribute{
							Computed:            true,
							Description:         "The included storage for this size in GB.",
							MarkdownDescription: "The included storage for this size in GB.",
						},
						"excess_transfer_cost_per_gigabyte": schema.Float64Attribute{
							Computed:            true,
							Description:         "The excess charged for any transfer above the included data transfer in AU$ per GB.",
							MarkdownDescription: "The excess charged for any transfer above the included data transfer in AU$ per GB.",
						},
						"memory": schema.Int64Attribute{
							Computed:            true,
							Description:         "The included memory for this size in MB.",
							MarkdownDescription: "The included memory for this size in MB.",
						},
						"options1": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"backups_cost_per_backup_per_gigabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The cost per GB of storage of each selected backup. See the API support document for how to calculate the final cost of backups based on the options selected.",
									MarkdownDescription: "The cost per GB of storage of each selected backup. See the API support document for how to calculate the final cost of backups based on the options selected.",
								},
								"daily_backups": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of daily backups included in the base size cost.",
									MarkdownDescription: "The number of daily backups included in the base size cost.",
								},
								"discount_for_no_public_ipv4": schema.Float64Attribute{
									Computed:            true,
									Description:         "This is the discount (if any) that is applied if no public IPv4 addresses are selected.",
									MarkdownDescription: "This is the discount (if any) that is applied if no public IPv4 addresses are selected.",
								},
								"disk_cost_per_additional_gigabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per GB per month for additional storage space.",
									MarkdownDescription: "The additional cost per GB per month for additional storage space.",
								},
								"disk_max": schema.Int64Attribute{
									Computed:            true,
									Description:         "The maximum storage in GB permitted on this size.",
									MarkdownDescription: "The maximum storage in GB permitted on this size.",
								},
								"disk_min": schema.Int64Attribute{
									Computed:            true,
									Description:         "The minimum storage in GB permitted on this size.",
									MarkdownDescription: "The minimum storage in GB permitted on this size.",
								},
								"ipv4_addresses_cost_per_address": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per public IPv4 address per month for additional IPv4 addresses.",
									MarkdownDescription: "The additional cost per public IPv4 address per month for additional IPv4 addresses.",
								},
								"ipv4_addresses_max": schema.Int64Attribute{
									Computed:            true,
									Description:         "The maximum number of IPv4 addresses permitted on this size.",
									MarkdownDescription: "The maximum number of IPv4 addresses permitted on this size.",
								},
								"memory_cost_per_additional_megabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per MB per month for additional memory.",
									MarkdownDescription: "The additional cost per MB per month for additional memory.",
								},
								"memory_max": schema.Int64Attribute{
									Computed:            true,
									Description:         "The maximum memory in MB permitted on this size.",
									MarkdownDescription: "The maximum memory in MB permitted on this size.",
								},
								"monthly_backups": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of monthly backups included in the base size cost.",
									MarkdownDescription: "The number of monthly backups included in the base size cost.",
								},
								"offsite_backup_frequency_cost": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"daily_per_gigabyte": schema.Float64Attribute{
											Computed:            true,
											Description:         "The additional cost per GB per month for enabling daily offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											MarkdownDescription: "The additional cost per GB per month for enabling daily offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
										},
										"monthly_per_gigabyte": schema.Float64Attribute{
											Computed:            true,
											Description:         "The additional cost per GB per month for enabling monthly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											MarkdownDescription: "The additional cost per GB per month for enabling monthly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
										},
										"weekly_per_gigabyte": schema.Float64Attribute{
											Computed:            true,
											Description:         "The additional cost per GB per month for enabling weekly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											MarkdownDescription: "The additional cost per GB per month for enabling weekly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
										},
									},
									CustomType: OffsiteBackupFrequencyCostType{
										ObjectType: types.ObjectType{
											AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "The additional cost per GB of storage for enabling offsite backups based on highest frequency of backups currently enabled. All costs are in AU$.",
									MarkdownDescription: "The additional cost per GB of storage for enabling offsite backups based on highest frequency of backups currently enabled. All costs are in AU$.",
								},
								"offsite_backups_cost_per_gigabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per GB of storage for enabling offsite backups. See the API support document for how to calculate the final cost of backups based on the options selected.",
									MarkdownDescription: "The additional cost per GB of storage for enabling offsite backups. See the API support document for how to calculate the final cost of backups based on the options selected.",
								},
								"restricted_disk_values": schema.ListAttribute{
									ElementType:         types.Int64Type,
									Computed:            true,
									Description:         "If this is null the normal valid values in the documentation for SizeOptionsRequest are used, otherwise only these values (in GB) are permitted.",
									MarkdownDescription: "If this is null the normal valid values in the documentation for SizeOptionsRequest are used, otherwise only these values (in GB) are permitted.",
								},
								"transfer_cost_per_additional_gigabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per GB per month for additional included transfer.",
									MarkdownDescription: "The additional cost per GB per month for additional included transfer.",
								},
								"transfer_max": schema.Float64Attribute{
									Computed:            true,
									Description:         "The maximum transfer in TB permitted for this size.",
									MarkdownDescription: "The maximum transfer in TB permitted for this size.",
								},
								"weekly_backups": schema.Int64Attribute{
									Computed:            true,
									Description:         "The number of weekly backups included in the base size cost.",
									MarkdownDescription: "The number of weekly backups included in the base size cost.",
								},
							},
							CustomType: Options1Type{
								ObjectType: types.ObjectType{
									AttrTypes: Options1Value{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "Available add-ons (optional features not included in the base price) for the size. All costs are in AU$ per month (pro-rated).",
							MarkdownDescription: "Available add-ons (optional features not included in the base price) for the size. All costs are in AU$ per month (pro-rated).",
						},
						"price_hourly": schema.Float64Attribute{
							Computed:            true,
							Description:         "Hourly price in AU$.",
							MarkdownDescription: "Hourly price in AU$.",
						},
						"price_monthly": schema.Float64Attribute{
							Computed:            true,
							Description:         "Monthly Price in AU$.",
							MarkdownDescription: "Monthly Price in AU$.",
						},
						"regions": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "A list of region slugs where this size is available regardless of stock.\nIf this a response to a query that included a selected operating system this response will only include regions where that operating system is available on this size,\notherwise not all regions listed will support all operating systems on this size.",
							MarkdownDescription: "A list of region slugs where this size is available regardless of stock.\nIf this a response to a query that included a selected operating system this response will only include regions where that operating system is available on this size,\notherwise not all regions listed will support all operating systems on this size.",
						},
						"regions_out_of_stock": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "A list of region slugs where the size is normally available but is currently not available due to lack of stock.",
							MarkdownDescription: "A list of region slugs where the size is normally available but is currently not available due to lack of stock.",
						},
						"size_type": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "The description of this size type, generally used to indicate the intended use case for sizes of this type.",
									MarkdownDescription: "The description of this size type, generally used to indicate the intended use case for sizes of this type.",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of this size type.",
									MarkdownDescription: "The name of this size type.",
								},
								"slug": schema.StringAttribute{
									Computed:            true,
									Description:         "The slug of this size type.",
									MarkdownDescription: "The slug of this size type.",
								},
							},
							CustomType: SizeTypeType{
								ObjectType: types.ObjectType{
									AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "The type of this size, generally used to differentiate sizes optimized for different usages.",
							MarkdownDescription: "The type of this size, generally used to differentiate sizes optimized for different usages.",
						},
						"slug": schema.StringAttribute{
							Computed:            true,
							Description:         "The slug of this size.",
							MarkdownDescription: "The slug of this size.",
						},
						"storage_description": schema.StringAttribute{
							Computed:            true,
							Description:         "A description of the storage provided in this size.",
							MarkdownDescription: "A description of the storage provided in this size.",
						},
						"transfer": schema.Float64Attribute{
							Computed:            true,
							Description:         "The included data transfer for this size in TB.",
							MarkdownDescription: "The included data transfer for this size in TB.",
						},
						"vcpu_units": schema.StringAttribute{
							Computed:            true,
							Description:         "This is the unit that the vcpus field counts, e.g. \"core\" or \"thread\".",
							MarkdownDescription: "This is the unit that the vcpus field counts, e.g. \"core\" or \"thread\".",
						},
						"vcpus": schema.Int64Attribute{
							Computed:            true,
							Description:         "The count of virtual CPUs for this size. See vcpu_units for a description of how each virtual CPU maps to the underlying hardware.",
							MarkdownDescription: "The count of virtual CPUs for this size. See vcpu_units for a description of how each virtual CPU maps to the underlying hardware.",
						},
					},
					CustomType: SizesType{
						ObjectType: types.ObjectType{
							AttrTypes: SizesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type SizesModel struct {
	Image    types.String `tfsdk:"image"`
	ServerId types.Int64  `tfsdk:"server_id"`
	Sizes    types.List   `tfsdk:"sizes"`
}

var _ basetypes.ObjectTypable = SizesType{}

type SizesType struct {
	basetypes.ObjectType
}

func (t SizesType) Equal(o attr.Type) bool {
	other, ok := o.(SizesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SizesType) String() string {
	return "SizesType"
}

func (t SizesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	cpuDescriptionAttribute, ok := attributes["cpu_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_description is missing from object`)

		return nil, diags
	}

	cpuDescriptionVal, ok := cpuDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_description expected to be basetypes.StringValue, was: %T`, cpuDescriptionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	excessTransferCostPerGigabyteAttribute, ok := attributes["excess_transfer_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excess_transfer_cost_per_gigabyte is missing from object`)

		return nil, diags
	}

	excessTransferCostPerGigabyteVal, ok := excessTransferCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excess_transfer_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, excessTransferCostPerGigabyteAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	options1Attribute, ok := attributes["options1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options1 is missing from object`)

		return nil, diags
	}

	options1Val, ok := options1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options1 expected to be basetypes.ObjectValue, was: %T`, options1Attribute))
	}

	priceHourlyAttribute, ok := attributes["price_hourly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_hourly is missing from object`)

		return nil, diags
	}

	priceHourlyVal, ok := priceHourlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_hourly expected to be basetypes.Float64Value, was: %T`, priceHourlyAttribute))
	}

	priceMonthlyAttribute, ok := attributes["price_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_monthly is missing from object`)

		return nil, diags
	}

	priceMonthlyVal, ok := priceMonthlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_monthly expected to be basetypes.Float64Value, was: %T`, priceMonthlyAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return nil, diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	regionsOutOfStockAttribute, ok := attributes["regions_out_of_stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions_out_of_stock is missing from object`)

		return nil, diags
	}

	regionsOutOfStockVal, ok := regionsOutOfStockAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions_out_of_stock expected to be basetypes.ListValue, was: %T`, regionsOutOfStockAttribute))
	}

	sizeTypeAttribute, ok := attributes["size_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_type is missing from object`)

		return nil, diags
	}

	sizeTypeVal, ok := sizeTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_type expected to be basetypes.ObjectValue, was: %T`, sizeTypeAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	storageDescriptionAttribute, ok := attributes["storage_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_description is missing from object`)

		return nil, diags
	}

	storageDescriptionVal, ok := storageDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_description expected to be basetypes.StringValue, was: %T`, storageDescriptionAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return nil, diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	vcpuUnitsAttribute, ok := attributes["vcpu_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_units is missing from object`)

		return nil, diags
	}

	vcpuUnitsVal, ok := vcpuUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_units expected to be basetypes.StringValue, was: %T`, vcpuUnitsAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SizesValue{
		Available:                     availableVal,
		CpuDescription:                cpuDescriptionVal,
		Description:                   descriptionVal,
		Disk:                          diskVal,
		ExcessTransferCostPerGigabyte: excessTransferCostPerGigabyteVal,
		Memory:                        memoryVal,
		Options1:                      options1Val,
		PriceHourly:                   priceHourlyVal,
		PriceMonthly:                  priceMonthlyVal,
		Regions:                       regionsVal,
		RegionsOutOfStock:             regionsOutOfStockVal,
		SizeType:                      sizeTypeVal,
		Slug:                          slugVal,
		StorageDescription:            storageDescriptionVal,
		Transfer:                      transferVal,
		VcpuUnits:                     vcpuUnitsVal,
		Vcpus:                         vcpusVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSizesValueNull() SizesValue {
	return SizesValue{
		state: attr.ValueStateNull,
	}
}

func NewSizesValueUnknown() SizesValue {
	return SizesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSizesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SizesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SizesValue Attribute Value",
				"While creating a SizesValue value, a missing attribute value was detected. "+
					"A SizesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SizesValue Attribute Type",
				"While creating a SizesValue value, an invalid attribute value was detected. "+
					"A SizesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SizesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SizesValue Attribute Value",
				"While creating a SizesValue value, an extra attribute value was detected. "+
					"A SizesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SizesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSizesValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	cpuDescriptionAttribute, ok := attributes["cpu_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_description is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	cpuDescriptionVal, ok := cpuDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_description expected to be basetypes.StringValue, was: %T`, cpuDescriptionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	excessTransferCostPerGigabyteAttribute, ok := attributes["excess_transfer_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excess_transfer_cost_per_gigabyte is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	excessTransferCostPerGigabyteVal, ok := excessTransferCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excess_transfer_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, excessTransferCostPerGigabyteAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	options1Attribute, ok := attributes["options1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options1 is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	options1Val, ok := options1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options1 expected to be basetypes.ObjectValue, was: %T`, options1Attribute))
	}

	priceHourlyAttribute, ok := attributes["price_hourly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_hourly is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	priceHourlyVal, ok := priceHourlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_hourly expected to be basetypes.Float64Value, was: %T`, priceHourlyAttribute))
	}

	priceMonthlyAttribute, ok := attributes["price_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_monthly is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	priceMonthlyVal, ok := priceMonthlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_monthly expected to be basetypes.Float64Value, was: %T`, priceMonthlyAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	regionsOutOfStockAttribute, ok := attributes["regions_out_of_stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions_out_of_stock is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	regionsOutOfStockVal, ok := regionsOutOfStockAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions_out_of_stock expected to be basetypes.ListValue, was: %T`, regionsOutOfStockAttribute))
	}

	sizeTypeAttribute, ok := attributes["size_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_type is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	sizeTypeVal, ok := sizeTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_type expected to be basetypes.ObjectValue, was: %T`, sizeTypeAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	storageDescriptionAttribute, ok := attributes["storage_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_description is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	storageDescriptionVal, ok := storageDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_description expected to be basetypes.StringValue, was: %T`, storageDescriptionAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	vcpuUnitsAttribute, ok := attributes["vcpu_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_units is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	vcpuUnitsVal, ok := vcpuUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_units expected to be basetypes.StringValue, was: %T`, vcpuUnitsAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewSizesValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewSizesValueUnknown(), diags
	}

	return SizesValue{
		Available:                     availableVal,
		CpuDescription:                cpuDescriptionVal,
		Description:                   descriptionVal,
		Disk:                          diskVal,
		ExcessTransferCostPerGigabyte: excessTransferCostPerGigabyteVal,
		Memory:                        memoryVal,
		Options1:                      options1Val,
		PriceHourly:                   priceHourlyVal,
		PriceMonthly:                  priceMonthlyVal,
		Regions:                       regionsVal,
		RegionsOutOfStock:             regionsOutOfStockVal,
		SizeType:                      sizeTypeVal,
		Slug:                          slugVal,
		StorageDescription:            storageDescriptionVal,
		Transfer:                      transferVal,
		VcpuUnits:                     vcpuUnitsVal,
		Vcpus:                         vcpusVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSizesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SizesValue {
	object, diags := NewSizesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSizesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SizesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSizesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSizesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSizesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSizesValueMust(SizesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SizesType) ValueType(ctx context.Context) attr.Value {
	return SizesValue{}
}

var _ basetypes.ObjectValuable = SizesValue{}

type SizesValue struct {
	Available                     basetypes.BoolValue    `tfsdk:"available"`
	CpuDescription                basetypes.StringValue  `tfsdk:"cpu_description"`
	Description                   basetypes.StringValue  `tfsdk:"description"`
	Disk                          basetypes.Int64Value   `tfsdk:"disk"`
	ExcessTransferCostPerGigabyte basetypes.Float64Value `tfsdk:"excess_transfer_cost_per_gigabyte"`
	Memory                        basetypes.Int64Value   `tfsdk:"memory"`
	Options1                      basetypes.ObjectValue  `tfsdk:"options1"`
	PriceHourly                   basetypes.Float64Value `tfsdk:"price_hourly"`
	PriceMonthly                  basetypes.Float64Value `tfsdk:"price_monthly"`
	Regions                       basetypes.ListValue    `tfsdk:"regions"`
	RegionsOutOfStock             basetypes.ListValue    `tfsdk:"regions_out_of_stock"`
	SizeType                      basetypes.ObjectValue  `tfsdk:"size_type"`
	Slug                          basetypes.StringValue  `tfsdk:"slug"`
	StorageDescription            basetypes.StringValue  `tfsdk:"storage_description"`
	Transfer                      basetypes.Float64Value `tfsdk:"transfer"`
	VcpuUnits                     basetypes.StringValue  `tfsdk:"vcpu_units"`
	Vcpus                         basetypes.Int64Value   `tfsdk:"vcpus"`
	state                         attr.ValueState
}

func (v SizesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cpu_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["excess_transfer_cost_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options1"] = basetypes.ObjectType{
		AttrTypes: Options1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["price_hourly"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["price_monthly"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["regions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["regions_out_of_stock"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["size_type"] = basetypes.ObjectType{
		AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["transfer"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["vcpu_units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.CpuDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_description"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.ExcessTransferCostPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["excess_transfer_cost_per_gigabyte"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Options1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options1"] = val

		val, err = v.PriceHourly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price_hourly"] = val

		val, err = v.PriceMonthly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price_monthly"] = val

		val, err = v.Regions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions"] = val

		val, err = v.RegionsOutOfStock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions_out_of_stock"] = val

		val, err = v.SizeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_type"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.StorageDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_description"] = val

		val, err = v.Transfer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer"] = val

		val, err = v.VcpuUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpu_units"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SizesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SizesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SizesValue) String() string {
	return "SizesValue"
}

func (v SizesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var options1 basetypes.ObjectValue

	if v.Options1.IsNull() {
		options1 = types.ObjectNull(
			Options1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Options1.IsUnknown() {
		options1 = types.ObjectUnknown(
			Options1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Options1.IsNull() && !v.Options1.IsUnknown() {
		options1 = types.ObjectValueMust(
			Options1Value{}.AttributeTypes(ctx),
			v.Options1.Attributes(),
		)
	}

	var sizeType basetypes.ObjectValue

	if v.SizeType.IsNull() {
		sizeType = types.ObjectNull(
			SizeTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.SizeType.IsUnknown() {
		sizeType = types.ObjectUnknown(
			SizeTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SizeType.IsNull() && !v.SizeType.IsUnknown() {
		sizeType = types.ObjectValueMust(
			SizeTypeValue{}.AttributeTypes(ctx),
			v.SizeType.Attributes(),
		)
	}

	var regionsVal basetypes.ListValue
	switch {
	case v.Regions.IsUnknown():
		regionsVal = types.ListUnknown(types.StringType)
	case v.Regions.IsNull():
		regionsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		regionsVal, d = types.ListValue(types.StringType, v.Regions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available":                         basetypes.BoolType{},
			"cpu_description":                   basetypes.StringType{},
			"description":                       basetypes.StringType{},
			"disk":                              basetypes.Int64Type{},
			"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
			"memory":                            basetypes.Int64Type{},
			"options1": basetypes.ObjectType{
				AttrTypes: Options1Value{}.AttributeTypes(ctx),
			},
			"price_hourly":  basetypes.Float64Type{},
			"price_monthly": basetypes.Float64Type{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"regions_out_of_stock": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_type": basetypes.ObjectType{
				AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
			},
			"slug":                basetypes.StringType{},
			"storage_description": basetypes.StringType{},
			"transfer":            basetypes.Float64Type{},
			"vcpu_units":          basetypes.StringType{},
			"vcpus":               basetypes.Int64Type{},
		}), diags
	}

	var regionsOutOfStockVal basetypes.ListValue
	switch {
	case v.RegionsOutOfStock.IsUnknown():
		regionsOutOfStockVal = types.ListUnknown(types.StringType)
	case v.RegionsOutOfStock.IsNull():
		regionsOutOfStockVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		regionsOutOfStockVal, d = types.ListValue(types.StringType, v.RegionsOutOfStock.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available":                         basetypes.BoolType{},
			"cpu_description":                   basetypes.StringType{},
			"description":                       basetypes.StringType{},
			"disk":                              basetypes.Int64Type{},
			"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
			"memory":                            basetypes.Int64Type{},
			"options1": basetypes.ObjectType{
				AttrTypes: Options1Value{}.AttributeTypes(ctx),
			},
			"price_hourly":  basetypes.Float64Type{},
			"price_monthly": basetypes.Float64Type{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"regions_out_of_stock": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_type": basetypes.ObjectType{
				AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
			},
			"slug":                basetypes.StringType{},
			"storage_description": basetypes.StringType{},
			"transfer":            basetypes.Float64Type{},
			"vcpu_units":          basetypes.StringType{},
			"vcpus":               basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"available":                         basetypes.BoolType{},
		"cpu_description":                   basetypes.StringType{},
		"description":                       basetypes.StringType{},
		"disk":                              basetypes.Int64Type{},
		"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
		"memory":                            basetypes.Int64Type{},
		"options1": basetypes.ObjectType{
			AttrTypes: Options1Value{}.AttributeTypes(ctx),
		},
		"price_hourly":  basetypes.Float64Type{},
		"price_monthly": basetypes.Float64Type{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"regions_out_of_stock": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_type": basetypes.ObjectType{
			AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
		},
		"slug":                basetypes.StringType{},
		"storage_description": basetypes.StringType{},
		"transfer":            basetypes.Float64Type{},
		"vcpu_units":          basetypes.StringType{},
		"vcpus":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"available":                         v.Available,
			"cpu_description":                   v.CpuDescription,
			"description":                       v.Description,
			"disk":                              v.Disk,
			"excess_transfer_cost_per_gigabyte": v.ExcessTransferCostPerGigabyte,
			"memory":                            v.Memory,
			"options1":                          options1,
			"price_hourly":                      v.PriceHourly,
			"price_monthly":                     v.PriceMonthly,
			"regions":                           regionsVal,
			"regions_out_of_stock":              regionsOutOfStockVal,
			"size_type":                         sizeType,
			"slug":                              v.Slug,
			"storage_description":               v.StorageDescription,
			"transfer":                          v.Transfer,
			"vcpu_units":                        v.VcpuUnits,
			"vcpus":                             v.Vcpus,
		})

	return objVal, diags
}

func (v SizesValue) Equal(o attr.Value) bool {
	other, ok := o.(SizesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.CpuDescription.Equal(other.CpuDescription) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.ExcessTransferCostPerGigabyte.Equal(other.ExcessTransferCostPerGigabyte) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Options1.Equal(other.Options1) {
		return false
	}

	if !v.PriceHourly.Equal(other.PriceHourly) {
		return false
	}

	if !v.PriceMonthly.Equal(other.PriceMonthly) {
		return false
	}

	if !v.Regions.Equal(other.Regions) {
		return false
	}

	if !v.RegionsOutOfStock.Equal(other.RegionsOutOfStock) {
		return false
	}

	if !v.SizeType.Equal(other.SizeType) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.StorageDescription.Equal(other.StorageDescription) {
		return false
	}

	if !v.Transfer.Equal(other.Transfer) {
		return false
	}

	if !v.VcpuUnits.Equal(other.VcpuUnits) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v SizesValue) Type(ctx context.Context) attr.Type {
	return SizesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SizesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available":                         basetypes.BoolType{},
		"cpu_description":                   basetypes.StringType{},
		"description":                       basetypes.StringType{},
		"disk":                              basetypes.Int64Type{},
		"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
		"memory":                            basetypes.Int64Type{},
		"options1": basetypes.ObjectType{
			AttrTypes: Options1Value{}.AttributeTypes(ctx),
		},
		"price_hourly":  basetypes.Float64Type{},
		"price_monthly": basetypes.Float64Type{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"regions_out_of_stock": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_type": basetypes.ObjectType{
			AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
		},
		"slug":                basetypes.StringType{},
		"storage_description": basetypes.StringType{},
		"transfer":            basetypes.Float64Type{},
		"vcpu_units":          basetypes.StringType{},
		"vcpus":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Options1Type{}

type Options1Type struct {
	basetypes.ObjectType
}

func (t Options1Type) Equal(o attr.Type) bool {
	other, ok := o.(Options1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Options1Type) String() string {
	return "Options1Type"
}

func (t Options1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupsCostPerBackupPerGigabyteAttribute, ok := attributes["backups_cost_per_backup_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backups_cost_per_backup_per_gigabyte is missing from object`)

		return nil, diags
	}

	backupsCostPerBackupPerGigabyteVal, ok := backupsCostPerBackupPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backups_cost_per_backup_per_gigabyte expected to be basetypes.Float64Value, was: %T`, backupsCostPerBackupPerGigabyteAttribute))
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return nil, diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	discountForNoPublicIpv4Attribute, ok := attributes["discount_for_no_public_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_for_no_public_ipv4 is missing from object`)

		return nil, diags
	}

	discountForNoPublicIpv4Val, ok := discountForNoPublicIpv4Attribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_for_no_public_ipv4 expected to be basetypes.Float64Value, was: %T`, discountForNoPublicIpv4Attribute))
	}

	diskCostPerAdditionalGigabyteAttribute, ok := attributes["disk_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_cost_per_additional_gigabyte is missing from object`)

		return nil, diags
	}

	diskCostPerAdditionalGigabyteVal, ok := diskCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, diskCostPerAdditionalGigabyteAttribute))
	}

	diskMaxAttribute, ok := attributes["disk_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_max is missing from object`)

		return nil, diags
	}

	diskMaxVal, ok := diskMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_max expected to be basetypes.Int64Value, was: %T`, diskMaxAttribute))
	}

	diskMinAttribute, ok := attributes["disk_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_min is missing from object`)

		return nil, diags
	}

	diskMinVal, ok := diskMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_min expected to be basetypes.Int64Value, was: %T`, diskMinAttribute))
	}

	ipv4AddressesCostPerAddressAttribute, ok := attributes["ipv4_addresses_cost_per_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_cost_per_address is missing from object`)

		return nil, diags
	}

	ipv4AddressesCostPerAddressVal, ok := ipv4AddressesCostPerAddressAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_cost_per_address expected to be basetypes.Float64Value, was: %T`, ipv4AddressesCostPerAddressAttribute))
	}

	ipv4AddressesMaxAttribute, ok := attributes["ipv4_addresses_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_max is missing from object`)

		return nil, diags
	}

	ipv4AddressesMaxVal, ok := ipv4AddressesMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_max expected to be basetypes.Int64Value, was: %T`, ipv4AddressesMaxAttribute))
	}

	memoryCostPerAdditionalMegabyteAttribute, ok := attributes["memory_cost_per_additional_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_cost_per_additional_megabyte is missing from object`)

		return nil, diags
	}

	memoryCostPerAdditionalMegabyteVal, ok := memoryCostPerAdditionalMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_cost_per_additional_megabyte expected to be basetypes.Float64Value, was: %T`, memoryCostPerAdditionalMegabyteAttribute))
	}

	memoryMaxAttribute, ok := attributes["memory_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_max is missing from object`)

		return nil, diags
	}

	memoryMaxVal, ok := memoryMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_max expected to be basetypes.Int64Value, was: %T`, memoryMaxAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return nil, diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupFrequencyCostAttribute, ok := attributes["offsite_backup_frequency_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_frequency_cost is missing from object`)

		return nil, diags
	}

	offsiteBackupFrequencyCostVal, ok := offsiteBackupFrequencyCostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_frequency_cost expected to be basetypes.ObjectValue, was: %T`, offsiteBackupFrequencyCostAttribute))
	}

	offsiteBackupsCostPerGigabyteAttribute, ok := attributes["offsite_backups_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups_cost_per_gigabyte is missing from object`)

		return nil, diags
	}

	offsiteBackupsCostPerGigabyteVal, ok := offsiteBackupsCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, offsiteBackupsCostPerGigabyteAttribute))
	}

	restrictedDiskValuesAttribute, ok := attributes["restricted_disk_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted_disk_values is missing from object`)

		return nil, diags
	}

	restrictedDiskValuesVal, ok := restrictedDiskValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted_disk_values expected to be basetypes.ListValue, was: %T`, restrictedDiskValuesAttribute))
	}

	transferCostPerAdditionalGigabyteAttribute, ok := attributes["transfer_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_cost_per_additional_gigabyte is missing from object`)

		return nil, diags
	}

	transferCostPerAdditionalGigabyteVal, ok := transferCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, transferCostPerAdditionalGigabyteAttribute))
	}

	transferMaxAttribute, ok := attributes["transfer_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_max is missing from object`)

		return nil, diags
	}

	transferMaxVal, ok := transferMaxAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_max expected to be basetypes.Float64Value, was: %T`, transferMaxAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return nil, diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Options1Value{
		BackupsCostPerBackupPerGigabyte:   backupsCostPerBackupPerGigabyteVal,
		DailyBackups:                      dailyBackupsVal,
		DiscountForNoPublicIpv4:           discountForNoPublicIpv4Val,
		DiskCostPerAdditionalGigabyte:     diskCostPerAdditionalGigabyteVal,
		DiskMax:                           diskMaxVal,
		DiskMin:                           diskMinVal,
		Ipv4AddressesCostPerAddress:       ipv4AddressesCostPerAddressVal,
		Ipv4AddressesMax:                  ipv4AddressesMaxVal,
		MemoryCostPerAdditionalMegabyte:   memoryCostPerAdditionalMegabyteVal,
		MemoryMax:                         memoryMaxVal,
		MonthlyBackups:                    monthlyBackupsVal,
		OffsiteBackupFrequencyCost:        offsiteBackupFrequencyCostVal,
		OffsiteBackupsCostPerGigabyte:     offsiteBackupsCostPerGigabyteVal,
		RestrictedDiskValues:              restrictedDiskValuesVal,
		TransferCostPerAdditionalGigabyte: transferCostPerAdditionalGigabyteVal,
		TransferMax:                       transferMaxVal,
		WeeklyBackups:                     weeklyBackupsVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewOptions1ValueNull() Options1Value {
	return Options1Value{
		state: attr.ValueStateNull,
	}
}

func NewOptions1ValueUnknown() Options1Value {
	return Options1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOptions1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Options1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Options1Value Attribute Value",
				"While creating a Options1Value value, a missing attribute value was detected. "+
					"A Options1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Options1Value Attribute Type",
				"While creating a Options1Value value, an invalid attribute value was detected. "+
					"A Options1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Options1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Options1Value Attribute Value",
				"While creating a Options1Value value, an extra attribute value was detected. "+
					"A Options1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Options1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptions1ValueUnknown(), diags
	}

	backupsCostPerBackupPerGigabyteAttribute, ok := attributes["backups_cost_per_backup_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backups_cost_per_backup_per_gigabyte is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	backupsCostPerBackupPerGigabyteVal, ok := backupsCostPerBackupPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backups_cost_per_backup_per_gigabyte expected to be basetypes.Float64Value, was: %T`, backupsCostPerBackupPerGigabyteAttribute))
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	discountForNoPublicIpv4Attribute, ok := attributes["discount_for_no_public_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_for_no_public_ipv4 is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	discountForNoPublicIpv4Val, ok := discountForNoPublicIpv4Attribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_for_no_public_ipv4 expected to be basetypes.Float64Value, was: %T`, discountForNoPublicIpv4Attribute))
	}

	diskCostPerAdditionalGigabyteAttribute, ok := attributes["disk_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_cost_per_additional_gigabyte is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	diskCostPerAdditionalGigabyteVal, ok := diskCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, diskCostPerAdditionalGigabyteAttribute))
	}

	diskMaxAttribute, ok := attributes["disk_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_max is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	diskMaxVal, ok := diskMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_max expected to be basetypes.Int64Value, was: %T`, diskMaxAttribute))
	}

	diskMinAttribute, ok := attributes["disk_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_min is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	diskMinVal, ok := diskMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_min expected to be basetypes.Int64Value, was: %T`, diskMinAttribute))
	}

	ipv4AddressesCostPerAddressAttribute, ok := attributes["ipv4_addresses_cost_per_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_cost_per_address is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	ipv4AddressesCostPerAddressVal, ok := ipv4AddressesCostPerAddressAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_cost_per_address expected to be basetypes.Float64Value, was: %T`, ipv4AddressesCostPerAddressAttribute))
	}

	ipv4AddressesMaxAttribute, ok := attributes["ipv4_addresses_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_max is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	ipv4AddressesMaxVal, ok := ipv4AddressesMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_max expected to be basetypes.Int64Value, was: %T`, ipv4AddressesMaxAttribute))
	}

	memoryCostPerAdditionalMegabyteAttribute, ok := attributes["memory_cost_per_additional_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_cost_per_additional_megabyte is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	memoryCostPerAdditionalMegabyteVal, ok := memoryCostPerAdditionalMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_cost_per_additional_megabyte expected to be basetypes.Float64Value, was: %T`, memoryCostPerAdditionalMegabyteAttribute))
	}

	memoryMaxAttribute, ok := attributes["memory_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_max is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	memoryMaxVal, ok := memoryMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_max expected to be basetypes.Int64Value, was: %T`, memoryMaxAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupFrequencyCostAttribute, ok := attributes["offsite_backup_frequency_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_frequency_cost is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	offsiteBackupFrequencyCostVal, ok := offsiteBackupFrequencyCostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_frequency_cost expected to be basetypes.ObjectValue, was: %T`, offsiteBackupFrequencyCostAttribute))
	}

	offsiteBackupsCostPerGigabyteAttribute, ok := attributes["offsite_backups_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups_cost_per_gigabyte is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	offsiteBackupsCostPerGigabyteVal, ok := offsiteBackupsCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, offsiteBackupsCostPerGigabyteAttribute))
	}

	restrictedDiskValuesAttribute, ok := attributes["restricted_disk_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted_disk_values is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	restrictedDiskValuesVal, ok := restrictedDiskValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted_disk_values expected to be basetypes.ListValue, was: %T`, restrictedDiskValuesAttribute))
	}

	transferCostPerAdditionalGigabyteAttribute, ok := attributes["transfer_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_cost_per_additional_gigabyte is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	transferCostPerAdditionalGigabyteVal, ok := transferCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, transferCostPerAdditionalGigabyteAttribute))
	}

	transferMaxAttribute, ok := attributes["transfer_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_max is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	transferMaxVal, ok := transferMaxAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_max expected to be basetypes.Float64Value, was: %T`, transferMaxAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return NewOptions1ValueUnknown(), diags
	}

	return Options1Value{
		BackupsCostPerBackupPerGigabyte:   backupsCostPerBackupPerGigabyteVal,
		DailyBackups:                      dailyBackupsVal,
		DiscountForNoPublicIpv4:           discountForNoPublicIpv4Val,
		DiskCostPerAdditionalGigabyte:     diskCostPerAdditionalGigabyteVal,
		DiskMax:                           diskMaxVal,
		DiskMin:                           diskMinVal,
		Ipv4AddressesCostPerAddress:       ipv4AddressesCostPerAddressVal,
		Ipv4AddressesMax:                  ipv4AddressesMaxVal,
		MemoryCostPerAdditionalMegabyte:   memoryCostPerAdditionalMegabyteVal,
		MemoryMax:                         memoryMaxVal,
		MonthlyBackups:                    monthlyBackupsVal,
		OffsiteBackupFrequencyCost:        offsiteBackupFrequencyCostVal,
		OffsiteBackupsCostPerGigabyte:     offsiteBackupsCostPerGigabyteVal,
		RestrictedDiskValues:              restrictedDiskValuesVal,
		TransferCostPerAdditionalGigabyte: transferCostPerAdditionalGigabyteVal,
		TransferMax:                       transferMaxVal,
		WeeklyBackups:                     weeklyBackupsVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewOptions1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Options1Value {
	object, diags := NewOptions1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptions1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Options1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptions1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptions1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptions1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptions1ValueMust(Options1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Options1Type) ValueType(ctx context.Context) attr.Value {
	return Options1Value{}
}

var _ basetypes.ObjectValuable = Options1Value{}

type Options1Value struct {
	BackupsCostPerBackupPerGigabyte   basetypes.Float64Value `tfsdk:"backups_cost_per_backup_per_gigabyte"`
	DailyBackups                      basetypes.Int64Value   `tfsdk:"daily_backups"`
	DiscountForNoPublicIpv4           basetypes.Float64Value `tfsdk:"discount_for_no_public_ipv4"`
	DiskCostPerAdditionalGigabyte     basetypes.Float64Value `tfsdk:"disk_cost_per_additional_gigabyte"`
	DiskMax                           basetypes.Int64Value   `tfsdk:"disk_max"`
	DiskMin                           basetypes.Int64Value   `tfsdk:"disk_min"`
	Ipv4AddressesCostPerAddress       basetypes.Float64Value `tfsdk:"ipv4_addresses_cost_per_address"`
	Ipv4AddressesMax                  basetypes.Int64Value   `tfsdk:"ipv4_addresses_max"`
	MemoryCostPerAdditionalMegabyte   basetypes.Float64Value `tfsdk:"memory_cost_per_additional_megabyte"`
	MemoryMax                         basetypes.Int64Value   `tfsdk:"memory_max"`
	MonthlyBackups                    basetypes.Int64Value   `tfsdk:"monthly_backups"`
	OffsiteBackupFrequencyCost        basetypes.ObjectValue  `tfsdk:"offsite_backup_frequency_cost"`
	OffsiteBackupsCostPerGigabyte     basetypes.Float64Value `tfsdk:"offsite_backups_cost_per_gigabyte"`
	RestrictedDiskValues              basetypes.ListValue    `tfsdk:"restricted_disk_values"`
	TransferCostPerAdditionalGigabyte basetypes.Float64Value `tfsdk:"transfer_cost_per_additional_gigabyte"`
	TransferMax                       basetypes.Float64Value `tfsdk:"transfer_max"`
	WeeklyBackups                     basetypes.Int64Value   `tfsdk:"weekly_backups"`
	state                             attr.ValueState
}

func (v Options1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["backups_cost_per_backup_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["daily_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["discount_for_no_public_ipv4"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["disk_cost_per_additional_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["disk_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses_cost_per_address"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory_cost_per_additional_megabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["memory_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monthly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["offsite_backup_frequency_cost"] = basetypes.ObjectType{
		AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["offsite_backups_cost_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["restricted_disk_values"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["transfer_cost_per_additional_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["transfer_max"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.BackupsCostPerBackupPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backups_cost_per_backup_per_gigabyte"] = val

		val, err = v.DailyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_backups"] = val

		val, err = v.DiscountForNoPublicIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount_for_no_public_ipv4"] = val

		val, err = v.DiskCostPerAdditionalGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_cost_per_additional_gigabyte"] = val

		val, err = v.DiskMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_max"] = val

		val, err = v.DiskMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_min"] = val

		val, err = v.Ipv4AddressesCostPerAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses_cost_per_address"] = val

		val, err = v.Ipv4AddressesMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses_max"] = val

		val, err = v.MemoryCostPerAdditionalMegabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_cost_per_additional_megabyte"] = val

		val, err = v.MemoryMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_max"] = val

		val, err = v.MonthlyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_backups"] = val

		val, err = v.OffsiteBackupFrequencyCost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backup_frequency_cost"] = val

		val, err = v.OffsiteBackupsCostPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backups_cost_per_gigabyte"] = val

		val, err = v.RestrictedDiskValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted_disk_values"] = val

		val, err = v.TransferCostPerAdditionalGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer_cost_per_additional_gigabyte"] = val

		val, err = v.TransferMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer_max"] = val

		val, err = v.WeeklyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_backups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Options1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Options1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Options1Value) String() string {
	return "Options1Value"
}

func (v Options1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var offsiteBackupFrequencyCost basetypes.ObjectValue

	if v.OffsiteBackupFrequencyCost.IsNull() {
		offsiteBackupFrequencyCost = types.ObjectNull(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		)
	}

	if v.OffsiteBackupFrequencyCost.IsUnknown() {
		offsiteBackupFrequencyCost = types.ObjectUnknown(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OffsiteBackupFrequencyCost.IsNull() && !v.OffsiteBackupFrequencyCost.IsUnknown() {
		offsiteBackupFrequencyCost = types.ObjectValueMust(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
			v.OffsiteBackupFrequencyCost.Attributes(),
		)
	}

	var restrictedDiskValuesVal basetypes.ListValue
	switch {
	case v.RestrictedDiskValues.IsUnknown():
		restrictedDiskValuesVal = types.ListUnknown(types.Int64Type)
	case v.RestrictedDiskValues.IsNull():
		restrictedDiskValuesVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		restrictedDiskValuesVal, d = types.ListValue(types.Int64Type, v.RestrictedDiskValues.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
			"daily_backups":                        basetypes.Int64Type{},
			"discount_for_no_public_ipv4":          basetypes.Float64Type{},
			"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
			"disk_max":                             basetypes.Int64Type{},
			"disk_min":                             basetypes.Int64Type{},
			"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
			"ipv4_addresses_max":                   basetypes.Int64Type{},
			"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
			"memory_max":                           basetypes.Int64Type{},
			"monthly_backups":                      basetypes.Int64Type{},
			"offsite_backup_frequency_cost": basetypes.ObjectType{
				AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
			},
			"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
			"restricted_disk_values": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
			"transfer_max":                          basetypes.Float64Type{},
			"weekly_backups":                        basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
		"daily_backups":                        basetypes.Int64Type{},
		"discount_for_no_public_ipv4":          basetypes.Float64Type{},
		"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
		"disk_max":                             basetypes.Int64Type{},
		"disk_min":                             basetypes.Int64Type{},
		"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
		"ipv4_addresses_max":                   basetypes.Int64Type{},
		"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
		"memory_max":                           basetypes.Int64Type{},
		"monthly_backups":                      basetypes.Int64Type{},
		"offsite_backup_frequency_cost": basetypes.ObjectType{
			AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		},
		"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
		"restricted_disk_values": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
		"transfer_max":                          basetypes.Float64Type{},
		"weekly_backups":                        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backups_cost_per_backup_per_gigabyte":  v.BackupsCostPerBackupPerGigabyte,
			"daily_backups":                         v.DailyBackups,
			"discount_for_no_public_ipv4":           v.DiscountForNoPublicIpv4,
			"disk_cost_per_additional_gigabyte":     v.DiskCostPerAdditionalGigabyte,
			"disk_max":                              v.DiskMax,
			"disk_min":                              v.DiskMin,
			"ipv4_addresses_cost_per_address":       v.Ipv4AddressesCostPerAddress,
			"ipv4_addresses_max":                    v.Ipv4AddressesMax,
			"memory_cost_per_additional_megabyte":   v.MemoryCostPerAdditionalMegabyte,
			"memory_max":                            v.MemoryMax,
			"monthly_backups":                       v.MonthlyBackups,
			"offsite_backup_frequency_cost":         offsiteBackupFrequencyCost,
			"offsite_backups_cost_per_gigabyte":     v.OffsiteBackupsCostPerGigabyte,
			"restricted_disk_values":                restrictedDiskValuesVal,
			"transfer_cost_per_additional_gigabyte": v.TransferCostPerAdditionalGigabyte,
			"transfer_max":                          v.TransferMax,
			"weekly_backups":                        v.WeeklyBackups,
		})

	return objVal, diags
}

func (v Options1Value) Equal(o attr.Value) bool {
	other, ok := o.(Options1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupsCostPerBackupPerGigabyte.Equal(other.BackupsCostPerBackupPerGigabyte) {
		return false
	}

	if !v.DailyBackups.Equal(other.DailyBackups) {
		return false
	}

	if !v.DiscountForNoPublicIpv4.Equal(other.DiscountForNoPublicIpv4) {
		return false
	}

	if !v.DiskCostPerAdditionalGigabyte.Equal(other.DiskCostPerAdditionalGigabyte) {
		return false
	}

	if !v.DiskMax.Equal(other.DiskMax) {
		return false
	}

	if !v.DiskMin.Equal(other.DiskMin) {
		return false
	}

	if !v.Ipv4AddressesCostPerAddress.Equal(other.Ipv4AddressesCostPerAddress) {
		return false
	}

	if !v.Ipv4AddressesMax.Equal(other.Ipv4AddressesMax) {
		return false
	}

	if !v.MemoryCostPerAdditionalMegabyte.Equal(other.MemoryCostPerAdditionalMegabyte) {
		return false
	}

	if !v.MemoryMax.Equal(other.MemoryMax) {
		return false
	}

	if !v.MonthlyBackups.Equal(other.MonthlyBackups) {
		return false
	}

	if !v.OffsiteBackupFrequencyCost.Equal(other.OffsiteBackupFrequencyCost) {
		return false
	}

	if !v.OffsiteBackupsCostPerGigabyte.Equal(other.OffsiteBackupsCostPerGigabyte) {
		return false
	}

	if !v.RestrictedDiskValues.Equal(other.RestrictedDiskValues) {
		return false
	}

	if !v.TransferCostPerAdditionalGigabyte.Equal(other.TransferCostPerAdditionalGigabyte) {
		return false
	}

	if !v.TransferMax.Equal(other.TransferMax) {
		return false
	}

	if !v.WeeklyBackups.Equal(other.WeeklyBackups) {
		return false
	}

	return true
}

func (v Options1Value) Type(ctx context.Context) attr.Type {
	return Options1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Options1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
		"daily_backups":                        basetypes.Int64Type{},
		"discount_for_no_public_ipv4":          basetypes.Float64Type{},
		"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
		"disk_max":                             basetypes.Int64Type{},
		"disk_min":                             basetypes.Int64Type{},
		"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
		"ipv4_addresses_max":                   basetypes.Int64Type{},
		"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
		"memory_max":                           basetypes.Int64Type{},
		"monthly_backups":                      basetypes.Int64Type{},
		"offsite_backup_frequency_cost": basetypes.ObjectType{
			AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		},
		"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
		"restricted_disk_values": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
		"transfer_max":                          basetypes.Float64Type{},
		"weekly_backups":                        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OffsiteBackupFrequencyCostType{}

type OffsiteBackupFrequencyCostType struct {
	basetypes.ObjectType
}

func (t OffsiteBackupFrequencyCostType) Equal(o attr.Type) bool {
	other, ok := o.(OffsiteBackupFrequencyCostType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OffsiteBackupFrequencyCostType) String() string {
	return "OffsiteBackupFrequencyCostType"
}

func (t OffsiteBackupFrequencyCostType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dailyPerGigabyteAttribute, ok := attributes["daily_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_per_gigabyte is missing from object`)

		return nil, diags
	}

	dailyPerGigabyteVal, ok := dailyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_per_gigabyte expected to be basetypes.Float64Value, was: %T`, dailyPerGigabyteAttribute))
	}

	monthlyPerGigabyteAttribute, ok := attributes["monthly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_per_gigabyte is missing from object`)

		return nil, diags
	}

	monthlyPerGigabyteVal, ok := monthlyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, monthlyPerGigabyteAttribute))
	}

	weeklyPerGigabyteAttribute, ok := attributes["weekly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_per_gigabyte is missing from object`)

		return nil, diags
	}

	weeklyPerGigabyteVal, ok := weeklyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, weeklyPerGigabyteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OffsiteBackupFrequencyCostValue{
		DailyPerGigabyte:   dailyPerGigabyteVal,
		MonthlyPerGigabyte: monthlyPerGigabyteVal,
		WeeklyPerGigabyte:  weeklyPerGigabyteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupFrequencyCostValueNull() OffsiteBackupFrequencyCostValue {
	return OffsiteBackupFrequencyCostValue{
		state: attr.ValueStateNull,
	}
}

func NewOffsiteBackupFrequencyCostValueUnknown() OffsiteBackupFrequencyCostValue {
	return OffsiteBackupFrequencyCostValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOffsiteBackupFrequencyCostValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OffsiteBackupFrequencyCostValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OffsiteBackupFrequencyCostValue Attribute Value",
				"While creating a OffsiteBackupFrequencyCostValue value, a missing attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OffsiteBackupFrequencyCostValue Attribute Type",
				"While creating a OffsiteBackupFrequencyCostValue value, an invalid attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OffsiteBackupFrequencyCostValue Attribute Value",
				"While creating a OffsiteBackupFrequencyCostValue value, an extra attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OffsiteBackupFrequencyCostValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	dailyPerGigabyteAttribute, ok := attributes["daily_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	dailyPerGigabyteVal, ok := dailyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_per_gigabyte expected to be basetypes.Float64Value, was: %T`, dailyPerGigabyteAttribute))
	}

	monthlyPerGigabyteAttribute, ok := attributes["monthly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	monthlyPerGigabyteVal, ok := monthlyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, monthlyPerGigabyteAttribute))
	}

	weeklyPerGigabyteAttribute, ok := attributes["weekly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	weeklyPerGigabyteVal, ok := weeklyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, weeklyPerGigabyteAttribute))
	}

	if diags.HasError() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	return OffsiteBackupFrequencyCostValue{
		DailyPerGigabyte:   dailyPerGigabyteVal,
		MonthlyPerGigabyte: monthlyPerGigabyteVal,
		WeeklyPerGigabyte:  weeklyPerGigabyteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupFrequencyCostValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OffsiteBackupFrequencyCostValue {
	object, diags := NewOffsiteBackupFrequencyCostValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOffsiteBackupFrequencyCostValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OffsiteBackupFrequencyCostType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOffsiteBackupFrequencyCostValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOffsiteBackupFrequencyCostValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOffsiteBackupFrequencyCostValueMust(OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OffsiteBackupFrequencyCostType) ValueType(ctx context.Context) attr.Value {
	return OffsiteBackupFrequencyCostValue{}
}

var _ basetypes.ObjectValuable = OffsiteBackupFrequencyCostValue{}

type OffsiteBackupFrequencyCostValue struct {
	DailyPerGigabyte   basetypes.Float64Value `tfsdk:"daily_per_gigabyte"`
	MonthlyPerGigabyte basetypes.Float64Value `tfsdk:"monthly_per_gigabyte"`
	WeeklyPerGigabyte  basetypes.Float64Value `tfsdk:"weekly_per_gigabyte"`
	state              attr.ValueState
}

func (v OffsiteBackupFrequencyCostValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["daily_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["monthly_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DailyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_per_gigabyte"] = val

		val, err = v.MonthlyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_per_gigabyte"] = val

		val, err = v.WeeklyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_per_gigabyte"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OffsiteBackupFrequencyCostValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OffsiteBackupFrequencyCostValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OffsiteBackupFrequencyCostValue) String() string {
	return "OffsiteBackupFrequencyCostValue"
}

func (v OffsiteBackupFrequencyCostValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"daily_per_gigabyte":   basetypes.Float64Type{},
		"monthly_per_gigabyte": basetypes.Float64Type{},
		"weekly_per_gigabyte":  basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daily_per_gigabyte":   v.DailyPerGigabyte,
			"monthly_per_gigabyte": v.MonthlyPerGigabyte,
			"weekly_per_gigabyte":  v.WeeklyPerGigabyte,
		})

	return objVal, diags
}

func (v OffsiteBackupFrequencyCostValue) Equal(o attr.Value) bool {
	other, ok := o.(OffsiteBackupFrequencyCostValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DailyPerGigabyte.Equal(other.DailyPerGigabyte) {
		return false
	}

	if !v.MonthlyPerGigabyte.Equal(other.MonthlyPerGigabyte) {
		return false
	}

	if !v.WeeklyPerGigabyte.Equal(other.WeeklyPerGigabyte) {
		return false
	}

	return true
}

func (v OffsiteBackupFrequencyCostValue) Type(ctx context.Context) attr.Type {
	return OffsiteBackupFrequencyCostType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OffsiteBackupFrequencyCostValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daily_per_gigabyte":   basetypes.Float64Type{},
		"monthly_per_gigabyte": basetypes.Float64Type{},
		"weekly_per_gigabyte":  basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = SizeTypeType{}

type SizeTypeType struct {
	basetypes.ObjectType
}

func (t SizeTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SizeTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SizeTypeType) String() string {
	return "SizeTypeType"
}

func (t SizeTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SizeTypeValue{
		Description: descriptionVal,
		Name:        nameVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSizeTypeValueNull() SizeTypeValue {
	return SizeTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSizeTypeValueUnknown() SizeTypeValue {
	return SizeTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSizeTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SizeTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SizeTypeValue Attribute Value",
				"While creating a SizeTypeValue value, a missing attribute value was detected. "+
					"A SizeTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SizeTypeValue Attribute Type",
				"While creating a SizeTypeValue value, an invalid attribute value was detected. "+
					"A SizeTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SizeTypeValue Attribute Value",
				"While creating a SizeTypeValue value, an extra attribute value was detected. "+
					"A SizeTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SizeTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSizeTypeValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return NewSizeTypeValueUnknown(), diags
	}

	return SizeTypeValue{
		Description: descriptionVal,
		Name:        nameVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSizeTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SizeTypeValue {
	object, diags := NewSizeTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSizeTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SizeTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSizeTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSizeTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSizeTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSizeTypeValueMust(SizeTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SizeTypeType) ValueType(ctx context.Context) attr.Value {
	return SizeTypeValue{}
}

var _ basetypes.ObjectValuable = SizeTypeValue{}

type SizeTypeValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	state       attr.ValueState
}

func (v SizeTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SizeTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SizeTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SizeTypeValue) String() string {
	return "SizeTypeValue"
}

func (v SizeTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"name":        v.Name,
			"slug":        v.Slug,
		})

	return objVal, diags
}

func (v SizeTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SizeTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	return true
}

func (v SizeTypeValue) Type(ctx context.Context) attr.Type {
	return SizeTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SizeTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
	}
}
