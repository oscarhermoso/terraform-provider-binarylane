// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package data_sources

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func ImagesDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"images": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"backup_info": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"backup_disks": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"description": schema.StringAttribute{
												Computed:            true,
												Description:         "A description of this disk.",
												MarkdownDescription: "A description of this disk.",
											},
											"id": schema.Int64Attribute{
												Computed:            true,
												Description:         "The ID of this backup disk.",
												MarkdownDescription: "The ID of this backup disk.",
											},
											"min_disk_size": schema.Int64Attribute{
												Computed:            true,
												Description:         "This is the minimum disk size in GB required to restore this disk image.",
												MarkdownDescription: "This is the minimum disk size in GB required to restore this disk image.",
											},
											"size_gigabytes": schema.Float64Attribute{
												Computed:            true,
												Description:         "This is the compressed size of the disk image in GB.",
												MarkdownDescription: "This is the compressed size of the disk image in GB.",
											},
										},
										CustomType: BackupDisksType{
											ObjectType: types.ObjectType{
												AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "A list of the individual disks that make up this backup.",
									MarkdownDescription: "A list of the individual disks that make up this backup.",
								},
								"iso": schema.BoolAttribute{
									Computed:            true,
									Description:         "If this is true the backup is an ISO image and cannot be restored or downloaded. ISO images may only be attached for use as a boot disk or an additional disk.",
									MarkdownDescription: "If this is true the backup is an ISO image and cannot be restored or downloaded. ISO images may only be attached for use as a boot disk or an additional disk.",
								},
								"locked": schema.BoolAttribute{
									Computed:            true,
									Description:         "If this is true the backup is locked and cannot be replaced.",
									MarkdownDescription: "If this is true the backup is locked and cannot be replaced.",
								},
								"offsite": schema.BoolAttribute{
									Computed:            true,
									Description:         "If this is true, an attempt to create an offsite copy was made. This does not mean that the offsite copy attempt was successful or that the copy still exists.",
									MarkdownDescription: "If this is true, an attempt to create an offsite copy was made. This does not mean that the offsite copy attempt was successful or that the copy still exists.",
								},
								"server_id": schema.Int64Attribute{
									Computed:            true,
									Description:         "The server ID that was used to create this backup.",
									MarkdownDescription: "The server ID that was used to create this backup.",
								},
								"type": schema.StringAttribute{
									Computed:            true,
									Description:         "\n| Value | Description |\n| ----- | ----------- |\n| daily | A backup which is scheduled to be taken each day. |\n| weekly | A backup which is scheduled to be taken each week. |\n| monthly | A backup which is scheduled to be taken each month. |\n| temporary | A backup which is created on demand and only retained for a maximum of seven days. |\n\n",
									MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| daily | A backup which is scheduled to be taken each day. |\n| weekly | A backup which is scheduled to be taken each week. |\n| monthly | A backup which is scheduled to be taken each month. |\n| temporary | A backup which is created on demand and only retained for a maximum of seven days. |\n\n",
								},
							},
							CustomType: BackupInfoType{
								ObjectType: types.ObjectType{
									AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "If this image is a backup, this object will provide further information.",
							MarkdownDescription: "If this image is a backup, this object will provide further information.",
						},
						"created_at": schema.StringAttribute{
							Computed:            true,
							Description:         "If this is a backup image this is the date and time in ISO8601 format when the image was created.",
							MarkdownDescription: "If this is a backup image this is the date and time in ISO8601 format when the image was created.",
						},
						"description": schema.StringAttribute{
							Computed:            true,
							Description:         "A description that may provide further details or warnings about the image.",
							MarkdownDescription: "A description that may provide further details or warnings about the image.",
						},
						"distribution": schema.StringAttribute{
							Computed:            true,
							Description:         "If this is an operating system image, this is the name of the distribution. If this is a backup image, this is the name of the distribution the server is using.",
							MarkdownDescription: "If this is an operating system image, this is the name of the distribution. If this is a backup image, this is the name of the distribution the server is using.",
						},
						"distribution_info": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"features": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Features supported by this distribution.",
									MarkdownDescription: "Features supported by this distribution.",
								},
								"image_id": schema.Int64Attribute{
									Computed:            true,
									Description:         "If this is a backup image, the operating system ID of the server at the time the backup was created.",
									MarkdownDescription: "If this is a backup image, the operating system ID of the server at the time the backup was created.",
								},
								"password_recovery": schema.StringAttribute{
									Computed:            true,
									Description:         "Supported methods of password recovery.\n\n| Value | Description |\n| ----- | ----------- |\n| manual | Password must be reset manually using the recovery console and rescue disk. |\n| offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |\n| offline-change | Password can be reset and new credentials sent (Requires restart). |\n| online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |\n\n",
									MarkdownDescription: "Supported methods of password recovery.\n\n| Value | Description |\n| ----- | ----------- |\n| manual | Password must be reset manually using the recovery console and rescue disk. |\n| offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |\n| offline-change | Password can be reset and new credentials sent (Requires restart). |\n| online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |\n\n",
								},
								"remote_access_user": schema.StringAttribute{
									Computed:            true,
									Description:         "User name to use when connecting via remote access (RDP or SSH).",
									MarkdownDescription: "User name to use when connecting via remote access (RDP or SSH).",
								},
							},
							CustomType: DistributionInfoType{
								ObjectType: types.ObjectType{
									AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "This object may provide further information about the distribution.",
							MarkdownDescription: "This object may provide further information about the distribution.",
						},
						"distribution_surcharges": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"surcharge_base_cost": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost for using this operating system as the base image for a size.",
									MarkdownDescription: "The additional cost for using this operating system as the base image for a size.",
								},
								"surcharge_min_vcpu": schema.Int64Attribute{
									Computed:            true,
									Description:         "The minimum vcpu count for surcharge calculations.",
									MarkdownDescription: "The minimum vcpu count for surcharge calculations.",
								},
								"surcharge_per_memory_max_megabytes": schema.Int64Attribute{
									Computed:            true,
									Description:         "The maximum memory in MB that counts towards the surcharge_per_memory_mb. Any memory above this cap does not attract the surcharge.",
									MarkdownDescription: "The maximum memory in MB that counts towards the surcharge_per_memory_mb. Any memory above this cap does not attract the surcharge.",
								},
								"surcharge_per_memory_megabyte": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per MB for using this operating system as the base image for a size.",
									MarkdownDescription: "The additional cost per MB for using this operating system as the base image for a size.",
								},
								"surcharge_per_vcpu": schema.Float64Attribute{
									Computed:            true,
									Description:         "The additional cost per vcpu for using this operating system as the base image for a size.",
									MarkdownDescription: "The additional cost per vcpu for using this operating system as the base image for a size.",
								},
							},
							CustomType: DistributionSurchargesType{
								ObjectType: types.ObjectType{
									AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "If this is not null the use of this image may incur surcharges above the base cost of the server. All costs are in AU$.",
							MarkdownDescription: "If this is not null the use of this image may incur surcharges above the base cost of the server. All costs are in AU$.",
						},
						"error_message": schema.StringAttribute{
							Computed:            true,
							Description:         "If the image creation failed this may provide further information.",
							MarkdownDescription: "If the image creation failed this may provide further information.",
						},
						"full_name": schema.StringAttribute{
							Computed:            true,
							Description:         "If this is an operating system image, this is the name and version of the distribution. If this is a backup image, this is the server hostname and label of the backup if it exists, otherwise it is the server hostname and UTC timestamp of the creation of the image.",
							MarkdownDescription: "If this is an operating system image, this is the name and version of the distribution. If this is a backup image, this is the server hostname and label of the backup if it exists, otherwise it is the server hostname and UTC timestamp of the creation of the image.",
						},
						"id": schema.Int64Attribute{
							Computed:            true,
							Description:         "The ID of this image.",
							MarkdownDescription: "The ID of this image.",
						},
						"min_disk_size": schema.Int64Attribute{
							Computed:            true,
							Description:         "For a distribution image this is the minimum disk size in GB required to install the operating system. For a backup image this is the minimum total disk size in GB required to restore the backup.",
							MarkdownDescription: "For a distribution image this is the minimum disk size in GB required to install the operating system. For a backup image this is the minimum total disk size in GB required to restore the backup.",
						},
						"min_memory_megabytes": schema.Int64Attribute{
							Computed:            true,
							Description:         "This is minimum memory in MB necessary to support this operating system (or the base operating system for a backup image).",
							MarkdownDescription: "This is minimum memory in MB necessary to support this operating system (or the base operating system for a backup image).",
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "If this is an operating system image, this is the name of the operating system version. If this is a backup image, this is the label of the backup if it exists, otherwise it is the UTC timestamp of the creation of the image.",
							MarkdownDescription: "If this is an operating system image, this is the name of the operating system version. If this is a backup image, this is the label of the backup if it exists, otherwise it is the UTC timestamp of the creation of the image.",
						},
						"public": schema.BoolAttribute{
							Computed:            true,
							Description:         "A public image is available to all users. A private image is available only to the account that created the image.",
							MarkdownDescription: "A public image is available to all users. A private image is available only to the account that created the image.",
						},
						"regions": schema.ListAttribute{
							ElementType:         types.StringType,
							Computed:            true,
							Description:         "The slugs of the regions where the image is available for use.",
							MarkdownDescription: "The slugs of the regions where the image is available for use.",
						},
						"size_gigabytes": schema.Float64Attribute{
							Computed:            true,
							Description:         "For a distribution image this is the disk size used in GB by the operating system on initial install. For a backup image this is the size of the compressed backup image in GB.",
							MarkdownDescription: "For a distribution image this is the disk size used in GB by the operating system on initial install. For a backup image this is the size of the compressed backup image in GB.",
						},
						"slug": schema.StringAttribute{
							Computed:            true,
							Description:         "If this is an operating system image this is a slug which may be used as an alternative to the ID as a reference.",
							MarkdownDescription: "If this is an operating system image this is a slug which may be used as an alternative to the ID as a reference.",
						},
						"status": schema.StringAttribute{
							Computed:            true,
							Description:         "\n| Value | Description |\n| ----- | ----------- |\n| NEW | The image is new. |\n| available | The image is available for use. |\n| pending | The image is pending and is not yet available for use. |\n| deleted | The image has been deleted and is no longer available for use. |\n\n",
							MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| NEW | The image is new. |\n| available | The image is available for use. |\n| pending | The image is pending and is not yet available for use. |\n| deleted | The image has been deleted and is no longer available for use. |\n\n",
						},
						"type": schema.StringAttribute{
							Computed:            true,
							Description:         "\n| Value | Description |\n| ----- | ----------- |\n| custom | An image uploaded by a user. |\n| snapshot | A snapshot. Snapshot creation is not currently supported so only distribution images will have this value. |\n| backup | A backup of a server. |\n\n",
							MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| custom | An image uploaded by a user. |\n| snapshot | A snapshot. Snapshot creation is not currently supported so only distribution images will have this value. |\n| backup | A backup of a server. |\n\n",
						},
					},
					CustomType: ImagesType{
						ObjectType: types.ObjectType{
							AttrTypes: ImagesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Queries for distribution will include images that have pre-installed applications.",
				MarkdownDescription: "Queries for distribution will include images that have pre-installed applications.",
			},
		},
	}
}

type ImagesModel struct {
	Images types.List   `tfsdk:"images"`
	Type   types.String `tfsdk:"type"`
}

var _ basetypes.ObjectTypable = ImagesType{}

type ImagesType struct {
	basetypes.ObjectType
}

func (t ImagesType) Equal(o attr.Type) bool {
	other, ok := o.(ImagesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImagesType) String() string {
	return "ImagesType"
}

func (t ImagesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupInfoAttribute, ok := attributes["backup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_info is missing from object`)

		return nil, diags
	}

	backupInfoVal, ok := backupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_info expected to be basetypes.ObjectValue, was: %T`, backupInfoAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	distributionAttribute, ok := attributes["distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution is missing from object`)

		return nil, diags
	}

	distributionVal, ok := distributionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution expected to be basetypes.StringValue, was: %T`, distributionAttribute))
	}

	distributionInfoAttribute, ok := attributes["distribution_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_info is missing from object`)

		return nil, diags
	}

	distributionInfoVal, ok := distributionInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_info expected to be basetypes.ObjectValue, was: %T`, distributionInfoAttribute))
	}

	distributionSurchargesAttribute, ok := attributes["distribution_surcharges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_surcharges is missing from object`)

		return nil, diags
	}

	distributionSurchargesVal, ok := distributionSurchargesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_surcharges expected to be basetypes.ObjectValue, was: %T`, distributionSurchargesAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return nil, diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return nil, diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	minMemoryMegabytesAttribute, ok := attributes["min_memory_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_memory_megabytes is missing from object`)

		return nil, diags
	}

	minMemoryMegabytesVal, ok := minMemoryMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_memory_megabytes expected to be basetypes.Int64Value, was: %T`, minMemoryMegabytesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return nil, diags
	}

	publicVal, ok := publicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.BoolValue, was: %T`, publicAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return nil, diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return nil, diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImagesValue{
		BackupInfo:             backupInfoVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Distribution:           distributionVal,
		DistributionInfo:       distributionInfoVal,
		DistributionSurcharges: distributionSurchargesVal,
		ErrorMessage:           errorMessageVal,
		FullName:               fullNameVal,
		Id:                     idVal,
		MinDiskSize:            minDiskSizeVal,
		MinMemoryMegabytes:     minMemoryMegabytesVal,
		Name:                   nameVal,
		Public:                 publicVal,
		Regions:                regionsVal,
		SizeGigabytes:          sizeGigabytesVal,
		Slug:                   slugVal,
		Status:                 statusVal,
		ImagesType:             typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewImagesValueNull() ImagesValue {
	return ImagesValue{
		state: attr.ValueStateNull,
	}
}

func NewImagesValueUnknown() ImagesValue {
	return ImagesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImagesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImagesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImagesValue Attribute Value",
				"While creating a ImagesValue value, a missing attribute value was detected. "+
					"A ImagesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImagesValue Attribute Type",
				"While creating a ImagesValue value, an invalid attribute value was detected. "+
					"A ImagesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImagesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImagesValue Attribute Value",
				"While creating a ImagesValue value, an extra attribute value was detected. "+
					"A ImagesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImagesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImagesValueUnknown(), diags
	}

	backupInfoAttribute, ok := attributes["backup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_info is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	backupInfoVal, ok := backupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_info expected to be basetypes.ObjectValue, was: %T`, backupInfoAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	distributionAttribute, ok := attributes["distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	distributionVal, ok := distributionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution expected to be basetypes.StringValue, was: %T`, distributionAttribute))
	}

	distributionInfoAttribute, ok := attributes["distribution_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_info is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	distributionInfoVal, ok := distributionInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_info expected to be basetypes.ObjectValue, was: %T`, distributionInfoAttribute))
	}

	distributionSurchargesAttribute, ok := attributes["distribution_surcharges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_surcharges is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	distributionSurchargesVal, ok := distributionSurchargesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_surcharges expected to be basetypes.ObjectValue, was: %T`, distributionSurchargesAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	minMemoryMegabytesAttribute, ok := attributes["min_memory_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_memory_megabytes is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	minMemoryMegabytesVal, ok := minMemoryMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_memory_megabytes expected to be basetypes.Int64Value, was: %T`, minMemoryMegabytesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	publicVal, ok := publicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.BoolValue, was: %T`, publicAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewImagesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewImagesValueUnknown(), diags
	}

	return ImagesValue{
		BackupInfo:             backupInfoVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Distribution:           distributionVal,
		DistributionInfo:       distributionInfoVal,
		DistributionSurcharges: distributionSurchargesVal,
		ErrorMessage:           errorMessageVal,
		FullName:               fullNameVal,
		Id:                     idVal,
		MinDiskSize:            minDiskSizeVal,
		MinMemoryMegabytes:     minMemoryMegabytesVal,
		Name:                   nameVal,
		Public:                 publicVal,
		Regions:                regionsVal,
		SizeGigabytes:          sizeGigabytesVal,
		Slug:                   slugVal,
		Status:                 statusVal,
		ImagesType:             typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewImagesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImagesValue {
	object, diags := NewImagesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImagesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImagesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImagesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImagesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImagesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImagesValueMust(ImagesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImagesType) ValueType(ctx context.Context) attr.Value {
	return ImagesValue{}
}

var _ basetypes.ObjectValuable = ImagesValue{}

type ImagesValue struct {
	BackupInfo             basetypes.ObjectValue  `tfsdk:"backup_info"`
	CreatedAt              basetypes.StringValue  `tfsdk:"created_at"`
	Description            basetypes.StringValue  `tfsdk:"description"`
	Distribution           basetypes.StringValue  `tfsdk:"distribution"`
	DistributionInfo       basetypes.ObjectValue  `tfsdk:"distribution_info"`
	DistributionSurcharges basetypes.ObjectValue  `tfsdk:"distribution_surcharges"`
	ErrorMessage           basetypes.StringValue  `tfsdk:"error_message"`
	FullName               basetypes.StringValue  `tfsdk:"full_name"`
	Id                     basetypes.Int64Value   `tfsdk:"id"`
	MinDiskSize            basetypes.Int64Value   `tfsdk:"min_disk_size"`
	MinMemoryMegabytes     basetypes.Int64Value   `tfsdk:"min_memory_megabytes"`
	Name                   basetypes.StringValue  `tfsdk:"name"`
	Public                 basetypes.BoolValue    `tfsdk:"public"`
	Regions                basetypes.ListValue    `tfsdk:"regions"`
	SizeGigabytes          basetypes.Float64Value `tfsdk:"size_gigabytes"`
	Slug                   basetypes.StringValue  `tfsdk:"slug"`
	Status                 basetypes.StringValue  `tfsdk:"status"`
	ImagesType             basetypes.StringValue  `tfsdk:"type"`
	state                  attr.ValueState
}

func (v ImagesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["backup_info"] = basetypes.ObjectType{
		AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["distribution"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["distribution_info"] = basetypes.ObjectType{
		AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["distribution_surcharges"] = basetypes.ObjectType{
		AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["full_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_disk_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_memory_megabytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["regions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["size_gigabytes"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.BackupInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_info"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Distribution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution"] = val

		val, err = v.DistributionInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution_info"] = val

		val, err = v.DistributionSurcharges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution_surcharges"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.FullName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MinDiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_disk_size"] = val

		val, err = v.MinMemoryMegabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_memory_megabytes"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Public.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public"] = val

		val, err = v.Regions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions"] = val

		val, err = v.SizeGigabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_gigabytes"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.ImagesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImagesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImagesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImagesValue) String() string {
	return "ImagesValue"
}

func (v ImagesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var backupInfo basetypes.ObjectValue

	if v.BackupInfo.IsNull() {
		backupInfo = types.ObjectNull(
			BackupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.BackupInfo.IsUnknown() {
		backupInfo = types.ObjectUnknown(
			BackupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BackupInfo.IsNull() && !v.BackupInfo.IsUnknown() {
		backupInfo = types.ObjectValueMust(
			BackupInfoValue{}.AttributeTypes(ctx),
			v.BackupInfo.Attributes(),
		)
	}

	var distributionInfo basetypes.ObjectValue

	if v.DistributionInfo.IsNull() {
		distributionInfo = types.ObjectNull(
			DistributionInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.DistributionInfo.IsUnknown() {
		distributionInfo = types.ObjectUnknown(
			DistributionInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DistributionInfo.IsNull() && !v.DistributionInfo.IsUnknown() {
		distributionInfo = types.ObjectValueMust(
			DistributionInfoValue{}.AttributeTypes(ctx),
			v.DistributionInfo.Attributes(),
		)
	}

	var distributionSurcharges basetypes.ObjectValue

	if v.DistributionSurcharges.IsNull() {
		distributionSurcharges = types.ObjectNull(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
		)
	}

	if v.DistributionSurcharges.IsUnknown() {
		distributionSurcharges = types.ObjectUnknown(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DistributionSurcharges.IsNull() && !v.DistributionSurcharges.IsUnknown() {
		distributionSurcharges = types.ObjectValueMust(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
			v.DistributionSurcharges.Attributes(),
		)
	}

	var regionsVal basetypes.ListValue
	switch {
	case v.Regions.IsUnknown():
		regionsVal = types.ListUnknown(types.StringType)
	case v.Regions.IsNull():
		regionsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		regionsVal, d = types.ListValue(types.StringType, v.Regions.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"backup_info": basetypes.ObjectType{
				AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
			},
			"created_at":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"distribution": basetypes.StringType{},
			"distribution_info": basetypes.ObjectType{
				AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
			},
			"distribution_surcharges": basetypes.ObjectType{
				AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
			},
			"error_message":        basetypes.StringType{},
			"full_name":            basetypes.StringType{},
			"id":                   basetypes.Int64Type{},
			"min_disk_size":        basetypes.Int64Type{},
			"min_memory_megabytes": basetypes.Int64Type{},
			"name":                 basetypes.StringType{},
			"public":               basetypes.BoolType{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_gigabytes": basetypes.Float64Type{},
			"slug":           basetypes.StringType{},
			"status":         basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"backup_info": basetypes.ObjectType{
			AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
		},
		"created_at":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"distribution": basetypes.StringType{},
		"distribution_info": basetypes.ObjectType{
			AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
		},
		"distribution_surcharges": basetypes.ObjectType{
			AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
		},
		"error_message":        basetypes.StringType{},
		"full_name":            basetypes.StringType{},
		"id":                   basetypes.Int64Type{},
		"min_disk_size":        basetypes.Int64Type{},
		"min_memory_megabytes": basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"public":               basetypes.BoolType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_gigabytes": basetypes.Float64Type{},
		"slug":           basetypes.StringType{},
		"status":         basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_info":             backupInfo,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"distribution":            v.Distribution,
			"distribution_info":       distributionInfo,
			"distribution_surcharges": distributionSurcharges,
			"error_message":           v.ErrorMessage,
			"full_name":               v.FullName,
			"id":                      v.Id,
			"min_disk_size":           v.MinDiskSize,
			"min_memory_megabytes":    v.MinMemoryMegabytes,
			"name":                    v.Name,
			"public":                  v.Public,
			"regions":                 regionsVal,
			"size_gigabytes":          v.SizeGigabytes,
			"slug":                    v.Slug,
			"status":                  v.Status,
			"type":                    v.ImagesType,
		})

	return objVal, diags
}

func (v ImagesValue) Equal(o attr.Value) bool {
	other, ok := o.(ImagesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupInfo.Equal(other.BackupInfo) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Distribution.Equal(other.Distribution) {
		return false
	}

	if !v.DistributionInfo.Equal(other.DistributionInfo) {
		return false
	}

	if !v.DistributionSurcharges.Equal(other.DistributionSurcharges) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.FullName.Equal(other.FullName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MinDiskSize.Equal(other.MinDiskSize) {
		return false
	}

	if !v.MinMemoryMegabytes.Equal(other.MinMemoryMegabytes) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Public.Equal(other.Public) {
		return false
	}

	if !v.Regions.Equal(other.Regions) {
		return false
	}

	if !v.SizeGigabytes.Equal(other.SizeGigabytes) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.ImagesType.Equal(other.ImagesType) {
		return false
	}

	return true
}

func (v ImagesValue) Type(ctx context.Context) attr.Type {
	return ImagesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImagesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_info": basetypes.ObjectType{
			AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
		},
		"created_at":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"distribution": basetypes.StringType{},
		"distribution_info": basetypes.ObjectType{
			AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
		},
		"distribution_surcharges": basetypes.ObjectType{
			AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
		},
		"error_message":        basetypes.StringType{},
		"full_name":            basetypes.StringType{},
		"id":                   basetypes.Int64Type{},
		"min_disk_size":        basetypes.Int64Type{},
		"min_memory_megabytes": basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"public":               basetypes.BoolType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_gigabytes": basetypes.Float64Type{},
		"slug":           basetypes.StringType{},
		"status":         basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BackupInfoType{}

type BackupInfoType struct {
	basetypes.ObjectType
}

func (t BackupInfoType) Equal(o attr.Type) bool {
	other, ok := o.(BackupInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BackupInfoType) String() string {
	return "BackupInfoType"
}

func (t BackupInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupDisksAttribute, ok := attributes["backup_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_disks is missing from object`)

		return nil, diags
	}

	backupDisksVal, ok := backupDisksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_disks expected to be basetypes.ListValue, was: %T`, backupDisksAttribute))
	}

	isoAttribute, ok := attributes["iso"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iso is missing from object`)

		return nil, diags
	}

	isoVal, ok := isoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iso expected to be basetypes.BoolValue, was: %T`, isoAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return nil, diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	offsiteAttribute, ok := attributes["offsite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite is missing from object`)

		return nil, diags
	}

	offsiteVal, ok := offsiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite expected to be basetypes.BoolValue, was: %T`, offsiteAttribute))
	}

	serverIdAttribute, ok := attributes["server_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id is missing from object`)

		return nil, diags
	}

	serverIdVal, ok := serverIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id expected to be basetypes.Int64Value, was: %T`, serverIdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BackupInfoValue{
		BackupDisks:    backupDisksVal,
		Iso:            isoVal,
		Locked:         lockedVal,
		Offsite:        offsiteVal,
		ServerId:       serverIdVal,
		BackupInfoType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewBackupInfoValueNull() BackupInfoValue {
	return BackupInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewBackupInfoValueUnknown() BackupInfoValue {
	return BackupInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBackupInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BackupInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BackupInfoValue Attribute Value",
				"While creating a BackupInfoValue value, a missing attribute value was detected. "+
					"A BackupInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BackupInfoValue Attribute Type",
				"While creating a BackupInfoValue value, an invalid attribute value was detected. "+
					"A BackupInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BackupInfoValue Attribute Value",
				"While creating a BackupInfoValue value, an extra attribute value was detected. "+
					"A BackupInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BackupInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBackupInfoValueUnknown(), diags
	}

	backupDisksAttribute, ok := attributes["backup_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_disks is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	backupDisksVal, ok := backupDisksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_disks expected to be basetypes.ListValue, was: %T`, backupDisksAttribute))
	}

	isoAttribute, ok := attributes["iso"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iso is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	isoVal, ok := isoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iso expected to be basetypes.BoolValue, was: %T`, isoAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	offsiteAttribute, ok := attributes["offsite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	offsiteVal, ok := offsiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite expected to be basetypes.BoolValue, was: %T`, offsiteAttribute))
	}

	serverIdAttribute, ok := attributes["server_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	serverIdVal, ok := serverIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id expected to be basetypes.Int64Value, was: %T`, serverIdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewBackupInfoValueUnknown(), diags
	}

	return BackupInfoValue{
		BackupDisks:    backupDisksVal,
		Iso:            isoVal,
		Locked:         lockedVal,
		Offsite:        offsiteVal,
		ServerId:       serverIdVal,
		BackupInfoType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewBackupInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BackupInfoValue {
	object, diags := NewBackupInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBackupInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BackupInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBackupInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBackupInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBackupInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBackupInfoValueMust(BackupInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BackupInfoType) ValueType(ctx context.Context) attr.Value {
	return BackupInfoValue{}
}

var _ basetypes.ObjectValuable = BackupInfoValue{}

type BackupInfoValue struct {
	BackupDisks    basetypes.ListValue   `tfsdk:"backup_disks"`
	Iso            basetypes.BoolValue   `tfsdk:"iso"`
	Locked         basetypes.BoolValue   `tfsdk:"locked"`
	Offsite        basetypes.BoolValue   `tfsdk:"offsite"`
	ServerId       basetypes.Int64Value  `tfsdk:"server_id"`
	BackupInfoType basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v BackupInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["backup_disks"] = basetypes.ListType{
		ElemType: BackupDisksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["iso"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["locked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["offsite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["server_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.BackupDisks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_disks"] = val

		val, err = v.Iso.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iso"] = val

		val, err = v.Locked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locked"] = val

		val, err = v.Offsite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite"] = val

		val, err = v.ServerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id"] = val

		val, err = v.BackupInfoType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BackupInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BackupInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BackupInfoValue) String() string {
	return "BackupInfoValue"
}

func (v BackupInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	backupDisks := types.ListValueMust(
		BackupDisksType{
			basetypes.ObjectType{
				AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
			},
		},
		v.BackupDisks.Elements(),
	)

	if v.BackupDisks.IsNull() {
		backupDisks = types.ListNull(
			BackupDisksType{
				basetypes.ObjectType{
					AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BackupDisks.IsUnknown() {
		backupDisks = types.ListUnknown(
			BackupDisksType{
				basetypes.ObjectType{
					AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_disks": basetypes.ListType{
			ElemType: BackupDisksValue{}.Type(ctx),
		},
		"iso":       basetypes.BoolType{},
		"locked":    basetypes.BoolType{},
		"offsite":   basetypes.BoolType{},
		"server_id": basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_disks": backupDisks,
			"iso":          v.Iso,
			"locked":       v.Locked,
			"offsite":      v.Offsite,
			"server_id":    v.ServerId,
			"type":         v.BackupInfoType,
		})

	return objVal, diags
}

func (v BackupInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(BackupInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupDisks.Equal(other.BackupDisks) {
		return false
	}

	if !v.Iso.Equal(other.Iso) {
		return false
	}

	if !v.Locked.Equal(other.Locked) {
		return false
	}

	if !v.Offsite.Equal(other.Offsite) {
		return false
	}

	if !v.ServerId.Equal(other.ServerId) {
		return false
	}

	if !v.BackupInfoType.Equal(other.BackupInfoType) {
		return false
	}

	return true
}

func (v BackupInfoValue) Type(ctx context.Context) attr.Type {
	return BackupInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BackupInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_disks": basetypes.ListType{
			ElemType: BackupDisksValue{}.Type(ctx),
		},
		"iso":       basetypes.BoolType{},
		"locked":    basetypes.BoolType{},
		"offsite":   basetypes.BoolType{},
		"server_id": basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BackupDisksType{}

type BackupDisksType struct {
	basetypes.ObjectType
}

func (t BackupDisksType) Equal(o attr.Type) bool {
	other, ok := o.(BackupDisksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BackupDisksType) String() string {
	return "BackupDisksType"
}

func (t BackupDisksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return nil, diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return nil, diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BackupDisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		MinDiskSize:   minDiskSizeVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBackupDisksValueNull() BackupDisksValue {
	return BackupDisksValue{
		state: attr.ValueStateNull,
	}
}

func NewBackupDisksValueUnknown() BackupDisksValue {
	return BackupDisksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBackupDisksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BackupDisksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BackupDisksValue Attribute Value",
				"While creating a BackupDisksValue value, a missing attribute value was detected. "+
					"A BackupDisksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BackupDisksValue Attribute Type",
				"While creating a BackupDisksValue value, an invalid attribute value was detected. "+
					"A BackupDisksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BackupDisksValue Attribute Value",
				"While creating a BackupDisksValue value, an extra attribute value was detected. "+
					"A BackupDisksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BackupDisksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBackupDisksValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return NewBackupDisksValueUnknown(), diags
	}

	return BackupDisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		MinDiskSize:   minDiskSizeVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBackupDisksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BackupDisksValue {
	object, diags := NewBackupDisksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBackupDisksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BackupDisksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBackupDisksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBackupDisksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBackupDisksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBackupDisksValueMust(BackupDisksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BackupDisksType) ValueType(ctx context.Context) attr.Value {
	return BackupDisksValue{}
}

var _ basetypes.ObjectValuable = BackupDisksValue{}

type BackupDisksValue struct {
	Description   basetypes.StringValue  `tfsdk:"description"`
	Id            basetypes.Int64Value   `tfsdk:"id"`
	MinDiskSize   basetypes.Int64Value   `tfsdk:"min_disk_size"`
	SizeGigabytes basetypes.Float64Value `tfsdk:"size_gigabytes"`
	state         attr.ValueState
}

func (v BackupDisksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_disk_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size_gigabytes"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MinDiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_disk_size"] = val

		val, err = v.SizeGigabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_gigabytes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BackupDisksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BackupDisksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BackupDisksValue) String() string {
	return "BackupDisksValue"
}

func (v BackupDisksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"min_disk_size":  basetypes.Int64Type{},
		"size_gigabytes": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":    v.Description,
			"id":             v.Id,
			"min_disk_size":  v.MinDiskSize,
			"size_gigabytes": v.SizeGigabytes,
		})

	return objVal, diags
}

func (v BackupDisksValue) Equal(o attr.Value) bool {
	other, ok := o.(BackupDisksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MinDiskSize.Equal(other.MinDiskSize) {
		return false
	}

	if !v.SizeGigabytes.Equal(other.SizeGigabytes) {
		return false
	}

	return true
}

func (v BackupDisksValue) Type(ctx context.Context) attr.Type {
	return BackupDisksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BackupDisksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"min_disk_size":  basetypes.Int64Type{},
		"size_gigabytes": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = DistributionInfoType{}

type DistributionInfoType struct {
	basetypes.ObjectType
}

func (t DistributionInfoType) Equal(o attr.Type) bool {
	other, ok := o.(DistributionInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DistributionInfoType) String() string {
	return "DistributionInfoType"
}

func (t DistributionInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return nil, diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.Int64Value, was: %T`, imageIdAttribute))
	}

	passwordRecoveryAttribute, ok := attributes["password_recovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_recovery is missing from object`)

		return nil, diags
	}

	passwordRecoveryVal, ok := passwordRecoveryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_recovery expected to be basetypes.StringValue, was: %T`, passwordRecoveryAttribute))
	}

	remoteAccessUserAttribute, ok := attributes["remote_access_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_access_user is missing from object`)

		return nil, diags
	}

	remoteAccessUserVal, ok := remoteAccessUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_access_user expected to be basetypes.StringValue, was: %T`, remoteAccessUserAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DistributionInfoValue{
		Features:         featuresVal,
		ImageId:          imageIdVal,
		PasswordRecovery: passwordRecoveryVal,
		RemoteAccessUser: remoteAccessUserVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDistributionInfoValueNull() DistributionInfoValue {
	return DistributionInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewDistributionInfoValueUnknown() DistributionInfoValue {
	return DistributionInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDistributionInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DistributionInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DistributionInfoValue Attribute Value",
				"While creating a DistributionInfoValue value, a missing attribute value was detected. "+
					"A DistributionInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DistributionInfoValue Attribute Type",
				"While creating a DistributionInfoValue value, an invalid attribute value was detected. "+
					"A DistributionInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DistributionInfoValue Attribute Value",
				"While creating a DistributionInfoValue value, an extra attribute value was detected. "+
					"A DistributionInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DistributionInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDistributionInfoValueUnknown(), diags
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.Int64Value, was: %T`, imageIdAttribute))
	}

	passwordRecoveryAttribute, ok := attributes["password_recovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_recovery is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	passwordRecoveryVal, ok := passwordRecoveryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_recovery expected to be basetypes.StringValue, was: %T`, passwordRecoveryAttribute))
	}

	remoteAccessUserAttribute, ok := attributes["remote_access_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_access_user is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	remoteAccessUserVal, ok := remoteAccessUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_access_user expected to be basetypes.StringValue, was: %T`, remoteAccessUserAttribute))
	}

	if diags.HasError() {
		return NewDistributionInfoValueUnknown(), diags
	}

	return DistributionInfoValue{
		Features:         featuresVal,
		ImageId:          imageIdVal,
		PasswordRecovery: passwordRecoveryVal,
		RemoteAccessUser: remoteAccessUserVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDistributionInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DistributionInfoValue {
	object, diags := NewDistributionInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDistributionInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DistributionInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDistributionInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDistributionInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDistributionInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDistributionInfoValueMust(DistributionInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DistributionInfoType) ValueType(ctx context.Context) attr.Value {
	return DistributionInfoValue{}
}

var _ basetypes.ObjectValuable = DistributionInfoValue{}

type DistributionInfoValue struct {
	Features         basetypes.ListValue   `tfsdk:"features"`
	ImageId          basetypes.Int64Value  `tfsdk:"image_id"`
	PasswordRecovery basetypes.StringValue `tfsdk:"password_recovery"`
	RemoteAccessUser basetypes.StringValue `tfsdk:"remote_access_user"`
	state            attr.ValueState
}

func (v DistributionInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["features"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["image_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["password_recovery"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_access_user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.ImageId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_id"] = val

		val, err = v.PasswordRecovery.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password_recovery"] = val

		val, err = v.RemoteAccessUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_access_user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DistributionInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DistributionInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DistributionInfoValue) String() string {
	return "DistributionInfoValue"
}

func (v DistributionInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var featuresVal basetypes.ListValue
	switch {
	case v.Features.IsUnknown():
		featuresVal = types.ListUnknown(types.StringType)
	case v.Features.IsNull():
		featuresVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		featuresVal, d = types.ListValue(types.StringType, v.Features.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"image_id":           basetypes.Int64Type{},
			"password_recovery":  basetypes.StringType{},
			"remote_access_user": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"image_id":           basetypes.Int64Type{},
		"password_recovery":  basetypes.StringType{},
		"remote_access_user": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"features":           featuresVal,
			"image_id":           v.ImageId,
			"password_recovery":  v.PasswordRecovery,
			"remote_access_user": v.RemoteAccessUser,
		})

	return objVal, diags
}

func (v DistributionInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(DistributionInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.ImageId.Equal(other.ImageId) {
		return false
	}

	if !v.PasswordRecovery.Equal(other.PasswordRecovery) {
		return false
	}

	if !v.RemoteAccessUser.Equal(other.RemoteAccessUser) {
		return false
	}

	return true
}

func (v DistributionInfoValue) Type(ctx context.Context) attr.Type {
	return DistributionInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DistributionInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"image_id":           basetypes.Int64Type{},
		"password_recovery":  basetypes.StringType{},
		"remote_access_user": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DistributionSurchargesType{}

type DistributionSurchargesType struct {
	basetypes.ObjectType
}

func (t DistributionSurchargesType) Equal(o attr.Type) bool {
	other, ok := o.(DistributionSurchargesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DistributionSurchargesType) String() string {
	return "DistributionSurchargesType"
}

func (t DistributionSurchargesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	surchargeBaseCostAttribute, ok := attributes["surcharge_base_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_base_cost is missing from object`)

		return nil, diags
	}

	surchargeBaseCostVal, ok := surchargeBaseCostAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_base_cost expected to be basetypes.Float64Value, was: %T`, surchargeBaseCostAttribute))
	}

	surchargeMinVcpuAttribute, ok := attributes["surcharge_min_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_min_vcpu is missing from object`)

		return nil, diags
	}

	surchargeMinVcpuVal, ok := surchargeMinVcpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_min_vcpu expected to be basetypes.Int64Value, was: %T`, surchargeMinVcpuAttribute))
	}

	surchargePerMemoryMaxMegabytesAttribute, ok := attributes["surcharge_per_memory_max_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_max_megabytes is missing from object`)

		return nil, diags
	}

	surchargePerMemoryMaxMegabytesVal, ok := surchargePerMemoryMaxMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_max_megabytes expected to be basetypes.Int64Value, was: %T`, surchargePerMemoryMaxMegabytesAttribute))
	}

	surchargePerMemoryMegabyteAttribute, ok := attributes["surcharge_per_memory_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_megabyte is missing from object`)

		return nil, diags
	}

	surchargePerMemoryMegabyteVal, ok := surchargePerMemoryMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_megabyte expected to be basetypes.Float64Value, was: %T`, surchargePerMemoryMegabyteAttribute))
	}

	surchargePerVcpuAttribute, ok := attributes["surcharge_per_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_vcpu is missing from object`)

		return nil, diags
	}

	surchargePerVcpuVal, ok := surchargePerVcpuAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_vcpu expected to be basetypes.Float64Value, was: %T`, surchargePerVcpuAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DistributionSurchargesValue{
		SurchargeBaseCost:              surchargeBaseCostVal,
		SurchargeMinVcpu:               surchargeMinVcpuVal,
		SurchargePerMemoryMaxMegabytes: surchargePerMemoryMaxMegabytesVal,
		SurchargePerMemoryMegabyte:     surchargePerMemoryMegabyteVal,
		SurchargePerVcpu:               surchargePerVcpuVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewDistributionSurchargesValueNull() DistributionSurchargesValue {
	return DistributionSurchargesValue{
		state: attr.ValueStateNull,
	}
}

func NewDistributionSurchargesValueUnknown() DistributionSurchargesValue {
	return DistributionSurchargesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDistributionSurchargesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DistributionSurchargesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DistributionSurchargesValue Attribute Value",
				"While creating a DistributionSurchargesValue value, a missing attribute value was detected. "+
					"A DistributionSurchargesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DistributionSurchargesValue Attribute Type",
				"While creating a DistributionSurchargesValue value, an invalid attribute value was detected. "+
					"A DistributionSurchargesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DistributionSurchargesValue Attribute Value",
				"While creating a DistributionSurchargesValue value, an extra attribute value was detected. "+
					"A DistributionSurchargesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DistributionSurchargesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeBaseCostAttribute, ok := attributes["surcharge_base_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_base_cost is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeBaseCostVal, ok := surchargeBaseCostAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_base_cost expected to be basetypes.Float64Value, was: %T`, surchargeBaseCostAttribute))
	}

	surchargeMinVcpuAttribute, ok := attributes["surcharge_min_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_min_vcpu is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeMinVcpuVal, ok := surchargeMinVcpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_min_vcpu expected to be basetypes.Int64Value, was: %T`, surchargeMinVcpuAttribute))
	}

	surchargePerMemoryMaxMegabytesAttribute, ok := attributes["surcharge_per_memory_max_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_max_megabytes is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerMemoryMaxMegabytesVal, ok := surchargePerMemoryMaxMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_max_megabytes expected to be basetypes.Int64Value, was: %T`, surchargePerMemoryMaxMegabytesAttribute))
	}

	surchargePerMemoryMegabyteAttribute, ok := attributes["surcharge_per_memory_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_megabyte is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerMemoryMegabyteVal, ok := surchargePerMemoryMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_megabyte expected to be basetypes.Float64Value, was: %T`, surchargePerMemoryMegabyteAttribute))
	}

	surchargePerVcpuAttribute, ok := attributes["surcharge_per_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_vcpu is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerVcpuVal, ok := surchargePerVcpuAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_vcpu expected to be basetypes.Float64Value, was: %T`, surchargePerVcpuAttribute))
	}

	if diags.HasError() {
		return NewDistributionSurchargesValueUnknown(), diags
	}

	return DistributionSurchargesValue{
		SurchargeBaseCost:              surchargeBaseCostVal,
		SurchargeMinVcpu:               surchargeMinVcpuVal,
		SurchargePerMemoryMaxMegabytes: surchargePerMemoryMaxMegabytesVal,
		SurchargePerMemoryMegabyte:     surchargePerMemoryMegabyteVal,
		SurchargePerVcpu:               surchargePerVcpuVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewDistributionSurchargesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DistributionSurchargesValue {
	object, diags := NewDistributionSurchargesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDistributionSurchargesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DistributionSurchargesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDistributionSurchargesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDistributionSurchargesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDistributionSurchargesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDistributionSurchargesValueMust(DistributionSurchargesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DistributionSurchargesType) ValueType(ctx context.Context) attr.Value {
	return DistributionSurchargesValue{}
}

var _ basetypes.ObjectValuable = DistributionSurchargesValue{}

type DistributionSurchargesValue struct {
	SurchargeBaseCost              basetypes.Float64Value `tfsdk:"surcharge_base_cost"`
	SurchargeMinVcpu               basetypes.Int64Value   `tfsdk:"surcharge_min_vcpu"`
	SurchargePerMemoryMaxMegabytes basetypes.Int64Value   `tfsdk:"surcharge_per_memory_max_megabytes"`
	SurchargePerMemoryMegabyte     basetypes.Float64Value `tfsdk:"surcharge_per_memory_megabyte"`
	SurchargePerVcpu               basetypes.Float64Value `tfsdk:"surcharge_per_vcpu"`
	state                          attr.ValueState
}

func (v DistributionSurchargesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["surcharge_base_cost"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["surcharge_min_vcpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_memory_max_megabytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_memory_megabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_vcpu"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.SurchargeBaseCost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_base_cost"] = val

		val, err = v.SurchargeMinVcpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_min_vcpu"] = val

		val, err = v.SurchargePerMemoryMaxMegabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_memory_max_megabytes"] = val

		val, err = v.SurchargePerMemoryMegabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_memory_megabyte"] = val

		val, err = v.SurchargePerVcpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_vcpu"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DistributionSurchargesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DistributionSurchargesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DistributionSurchargesValue) String() string {
	return "DistributionSurchargesValue"
}

func (v DistributionSurchargesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"surcharge_base_cost":                basetypes.Float64Type{},
		"surcharge_min_vcpu":                 basetypes.Int64Type{},
		"surcharge_per_memory_max_megabytes": basetypes.Int64Type{},
		"surcharge_per_memory_megabyte":      basetypes.Float64Type{},
		"surcharge_per_vcpu":                 basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"surcharge_base_cost":                v.SurchargeBaseCost,
			"surcharge_min_vcpu":                 v.SurchargeMinVcpu,
			"surcharge_per_memory_max_megabytes": v.SurchargePerMemoryMaxMegabytes,
			"surcharge_per_memory_megabyte":      v.SurchargePerMemoryMegabyte,
			"surcharge_per_vcpu":                 v.SurchargePerVcpu,
		})

	return objVal, diags
}

func (v DistributionSurchargesValue) Equal(o attr.Value) bool {
	other, ok := o.(DistributionSurchargesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SurchargeBaseCost.Equal(other.SurchargeBaseCost) {
		return false
	}

	if !v.SurchargeMinVcpu.Equal(other.SurchargeMinVcpu) {
		return false
	}

	if !v.SurchargePerMemoryMaxMegabytes.Equal(other.SurchargePerMemoryMaxMegabytes) {
		return false
	}

	if !v.SurchargePerMemoryMegabyte.Equal(other.SurchargePerMemoryMegabyte) {
		return false
	}

	if !v.SurchargePerVcpu.Equal(other.SurchargePerVcpu) {
		return false
	}

	return true
}

func (v DistributionSurchargesValue) Type(ctx context.Context) attr.Type {
	return DistributionSurchargesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DistributionSurchargesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"surcharge_base_cost":                basetypes.Float64Type{},
		"surcharge_min_vcpu":                 basetypes.Int64Type{},
		"surcharge_per_memory_max_megabytes": basetypes.Int64Type{},
		"surcharge_per_memory_megabyte":      basetypes.Float64Type{},
		"surcharge_per_vcpu":                 basetypes.Float64Type{},
	}
}
