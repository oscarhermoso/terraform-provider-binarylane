// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resources

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func ServerResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"backups": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true this will enable two daily backups for the server. Options.daily_backups will override this value if provided. Setting this to false has no effect.\n",
				MarkdownDescription: "If true this will enable two daily backups for the server. Options.daily_backups will override this value if provided. Setting this to false has no effect.\n",
			},
			"id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The ID of the server to fetch.",
				MarkdownDescription: "The ID of the server to fetch.",
			},
			"image": schema.StringAttribute{
				Required:            true,
				Description:         "The slug of the selected operating system.",
				MarkdownDescription: "The slug of the selected operating system.",
			},
			"ipv6": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If true this will enable IPv6 for this server.",
				MarkdownDescription: "If true this will enable IPv6 for this server.",
			},
			"licenses": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"count": schema.Int64Attribute{
							Required:            true,
							Description:         "The number of licences.",
							MarkdownDescription: "The number of licences.",
						},
						"software_id": schema.Int64Attribute{
							Required:            true,
							Description:         "The ID of the software to license.",
							MarkdownDescription: "The ID of the software to license.",
						},
					},
					CustomType: LicensesType{
						ObjectType: types.ObjectType{
							AttrTypes: LicensesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The desired set of licenses.",
				MarkdownDescription: "The desired set of licenses.",
			},
			"links": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"actions": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"href": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Computed: true,
								},
								"rel": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: ActionsType{
								ObjectType: types.ObjectType{
									AttrTypes: ActionsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
				},
				CustomType: LinksType{
					ObjectType: types.ObjectType{
						AttrTypes: LinksValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The hostname of your server, such as vps01.yourcompany.com. If not provided, the server will be created with a random name.",
				MarkdownDescription: "The hostname of your server, such as vps01.yourcompany.com. If not provided, the server will be created with a random name.",
			},
			"options1": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"daily_backups": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						MarkdownDescription: "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						Validators: []validator.Int64{
							int64validator.Between(0, 14),
						},
					},
					"disk": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The total storage in GB for this server.\nIf specified this is the absolute value, not just the additional storage above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values for sizes that do not provide a value for options.restricted_storage_values_gb:\n- must be a multiple of 5\n- &gt; 60GB must be a multiple of 10\n- &gt; 200GB must be a multiple of 100",
						MarkdownDescription: "The total storage in GB for this server.\nIf specified this is the absolute value, not just the additional storage above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values for sizes that do not provide a value for options.restricted_storage_values_gb:\n- must be a multiple of 5\n- &gt; 60GB must be a multiple of 10\n- &gt; 200GB must be a multiple of 100",
					},
					"ipv4_addresses": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The total count of IPv4 addresses for this server. If specified this is the absolute value, not just the additional IPv4 addresses above what is included in the size. Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server. Must not exceed the size.ipv4_addresses_max value.",
						MarkdownDescription: "The total count of IPv4 addresses for this server. If specified this is the absolute value, not just the additional IPv4 addresses above what is included in the size. Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server. Must not exceed the size.ipv4_addresses_max value.",
						Validators: []validator.Int64{
							int64validator.Between(0, 2147483647),
						},
					},
					"memory": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The total memory in MB for this server.\nIf specified this is the absolute value, not just the additional memory above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values:\n- must be a multiple of 128\n- &gt; 2048MB must be a multiple of 1024\n- &gt; 16384MB must be a multiple of 2048\n- &gt; 24576MB must be a multiple of 4096",
						MarkdownDescription: "The total memory in MB for this server.\nIf specified this is the absolute value, not just the additional memory above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values:\n- must be a multiple of 128\n- &gt; 2048MB must be a multiple of 1024\n- &gt; 16384MB must be a multiple of 2048\n- &gt; 24576MB must be a multiple of 4096",
					},
					"monthly_backups": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						MarkdownDescription: "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						Validators: []validator.Int64{
							int64validator.Between(0, 12),
						},
					},
					"offsite_backups": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						MarkdownDescription: "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
					},
					"transfer": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "The total transfer per month in TB for this server.\nIf specified this is the absolute value, not just the additional transfer above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values (when converted to GB by multiplying the value provided by 1024):\n- must be a multiple of 5GB\n- &gt; 30GB must be a multiple of 10\n- &gt; 200GB must be a multiple of 100\n- &gt; 2000GB must be a multiple of 1000",
						MarkdownDescription: "The total transfer per month in TB for this server.\nIf specified this is the absolute value, not just the additional transfer above what is included in the size.\nLeave null to accept the default for the size if this is a new server or a resize to a different base size, or to keep the current value if this a resize with the same base size but different options.\n            \nValid values (when converted to GB by multiplying the value provided by 1024):\n- must be a multiple of 5GB\n- &gt; 30GB must be a multiple of 10\n- &gt; 200GB must be a multiple of 100\n- &gt; 2000GB must be a multiple of 1000",
					},
					"weekly_backups": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						MarkdownDescription: "Leave null to accept the default for the size if this is a new server or to keep the current value if this is a resize of an existing server.",
						Validators: []validator.Int64{
							int64validator.Between(0, 13),
						},
					},
				},
				CustomType: Options1Type{
					ObjectType: types.ObjectType{
						AttrTypes: Options1Value{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "This may be left null to accept all of the defaults for the selected size.",
				MarkdownDescription: "This may be left null to accept all of the defaults for the selected size.",
			},
			"password": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If this is provided the specified or default remote user's account password will be set to this value. Only valid if the server supports password change actions (check server.password_change_supported via the servers endpoint). If omitted and the server supports password change actions a random password will be generated and emailed to the account email address.\n",
				MarkdownDescription: "If this is provided the specified or default remote user's account password will be set to this value. Only valid if the server supports password change actions (check server.password_change_supported via the servers endpoint). If omitted and the server supports password change actions a random password will be generated and emailed to the account email address.\n",
			},
			"port_blocking": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Port blocking of outgoing connections for email, SSH and Remote Desktop (TCP ports 22, 25, and 3389) is enabled by default for all new servers. If this is false port blocking will be disabled. Disabling port blocking is only available to reviewed accounts.",
				MarkdownDescription: "Port blocking of outgoing connections for email, SSH and Remote Desktop (TCP ports 22, 25, and 3389) is enabled by default for all new servers. If this is false port blocking will be disabled. Disabling port blocking is only available to reviewed accounts.",
			},
			"region": schema.StringAttribute{
				Required:            true,
				Description:         "The slug of the selected region.",
				MarkdownDescription: "The slug of the selected region.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"server": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"advanced_features": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"enabled_advanced_features": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of the currently enabled advanced features for this server.",
								MarkdownDescription: "A list of the currently enabled advanced features for this server.",
							},
							"machine_type": schema.StringAttribute{
								Computed:            true,
								Description:         "The machine_type (corresponding to a KVM version) used for this server.\nA null value indicates automatic selection of the best KVM machine type supported by the host node.",
								MarkdownDescription: "The machine_type (corresponding to a KVM version) used for this server.\nA null value indicates automatic selection of the best KVM machine type supported by the host node.",
							},
							"processor_model": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of the processor model (and therefore CPU flags) available for this server.\nA null value indicates automatic selection of the best processor model supported by the host node.\nThis does not change the physical CPU, only the CPU flags available to the operating system.",
								MarkdownDescription: "The ID of the processor model (and therefore CPU flags) available for this server.\nA null value indicates automatic selection of the best processor model supported by the host node.\nThis does not change the physical CPU, only the CPU flags available to the operating system.",
							},
							"video_device": schema.StringAttribute{
								Computed:            true,
								Description:         "Video Device\n\n| Value | Description |\n| ----- | ----------- |\n| cirrus-logic | Cirrus Logic GD5446 |\n| standard | Standard VGA with VESA 2.0 extensions |\n| virtio | Virtio VGA (800x600) |\n| virtio-wide | Virtio VGA (1600x900) |\n\n",
								MarkdownDescription: "Video Device\n\n| Value | Description |\n| ----- | ----------- |\n| cirrus-logic | Cirrus Logic GD5446 |\n| standard | Standard VGA with VESA 2.0 extensions |\n| virtio | Virtio VGA (800x600) |\n| virtio-wide | Virtio VGA (1600x900) |\n\n",
							},
						},
						CustomType: AdvancedFeaturesType{
							ObjectType: types.ObjectType{
								AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The currently enabled advanced features, machine type and processor flags.",
						MarkdownDescription: "The currently enabled advanced features, machine type and processor flags.",
					},
					"attached_backup": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"attached_at": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time in ISO8601 format when this image was attached to the server.",
								MarkdownDescription: "The date and time in ISO8601 format when this image was attached to the server.",
							},
							"attachment_expires": schema.StringAttribute{
								Computed:            true,
								Description:         "The date and time in ISO8601 format when the backup will be automatically detached unless it is manually detached earlier.",
								MarkdownDescription: "The date and time in ISO8601 format when the backup will be automatically detached unless it is manually detached earlier.",
							},
							"disk_identifiers": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of the operating specific disk identifiers for the attached backup disks.",
								MarkdownDescription: "A list of the operating specific disk identifiers for the attached backup disks.",
							},
							"id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of the backup image.",
								MarkdownDescription: "The ID of the backup image.",
							},
						},
						CustomType: AttachedBackupType{
							ObjectType: types.ObjectType{
								AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "An object that provides details of any backup image currently attached to the server..",
						MarkdownDescription: "An object that provides details of any backup image currently attached to the server..",
					},
					"backup_ids": schema.ListAttribute{
						ElementType:         types.Int64Type,
						Computed:            true,
						Description:         "A list of the currently existing backup image IDs for this server (if any).",
						MarkdownDescription: "A list of the currently existing backup image IDs for this server (if any).",
					},
					"backup_settings": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"backup_day_of_month": schema.Int64Attribute{
								Computed:            true,
								Description:         "If monthly backups are enabled the day of the month the monthly backup will occur.",
								MarkdownDescription: "If monthly backups are enabled the day of the month the monthly backup will occur.",
							},
							"backup_day_of_week": schema.Int64Attribute{
								Computed:            true,
								Description:         "If weekly backups are enabled the day of the week that the weekly backup will occur. Sunday is day 0.",
								MarkdownDescription: "If weekly backups are enabled the day of the week that the weekly backup will occur. Sunday is day 0.",
							},
							"backup_hour_of_day": schema.Int64Attribute{
								Computed:            true,
								Description:         "The hour of the day that backups will be scheduled. This is an approximate value.",
								MarkdownDescription: "The hour of the day that backups will be scheduled. This is an approximate value.",
							},
							"offsite_backup_settings": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"manage_offsite_copies": schema.BoolAttribute{
										Computed:            true,
										Description:         "This only has effect if a custom offsite location is being used: the internal offsite backup location always manages copies.\nIf this is true old offsite backups will be removed once the replacement upload is complete.\nIf this is false backups must be removed from the Amazon S3 bucket manually. Amazon will charge your S3 account at their standard rate for every backup stored.",
										MarkdownDescription: "This only has effect if a custom offsite location is being used: the internal offsite backup location always manages copies.\nIf this is true old offsite backups will be removed once the replacement upload is complete.\nIf this is false backups must be removed from the Amazon S3 bucket manually. Amazon will charge your S3 account at their standard rate for every backup stored.",
									},
									"offsite_backup_location": schema.StringAttribute{
										Computed:            true,
										Description:         "If a custom backup location is used, this is the provided location.",
										MarkdownDescription: "If a custom backup location is used, this is the provided location.",
									},
									"use_custom_backup_location": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is true a custom backup location will be used. If false our internally managed offsite backup location be used.",
										MarkdownDescription: "If this is true a custom backup location will be used. If false our internally managed offsite backup location be used.",
									},
								},
								CustomType: OffsiteBackupSettingsType{
									ObjectType: types.ObjectType{
										AttrTypes: OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "If offsite backups are enabled this details how they are stored and managed.",
								MarkdownDescription: "If offsite backups are enabled this details how they are stored and managed.",
							},
						},
						CustomType: BackupSettingsType{
							ObjectType: types.ObjectType{
								AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Detailed backup settings for the server.",
						MarkdownDescription: "Detailed backup settings for the server.",
					},
					"cancelled_at": schema.StringAttribute{
						Computed:            true,
						Description:         "If the server has been cancelled, this is the date and time in ISO8601 format of that cancellation.",
						MarkdownDescription: "If the server has been cancelled, this is the date and time in ISO8601 format of that cancellation.",
					},
					"created_at": schema.StringAttribute{
						Computed:            true,
						Description:         "The date and time in ISO8601 format of this server's initial creation.",
						MarkdownDescription: "The date and time in ISO8601 format of this server's initial creation.",
					},
					"disk": schema.Int64Attribute{
						Computed:            true,
						Description:         "The total disk in GB of this server.",
						MarkdownDescription: "The total disk in GB of this server.",
					},
					"disks": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "A description of this disk.",
									MarkdownDescription: "A description of this disk.",
								},
								"id": schema.Int64Attribute{
									Computed:            true,
									Description:         "The ID of this disk.",
									MarkdownDescription: "The ID of this disk.",
								},
								"primary": schema.BoolAttribute{
									Computed:            true,
									Description:         "A primary disk is treated differently from other disks.",
									MarkdownDescription: "A primary disk is treated differently from other disks.",
								},
								"size_gigabytes": schema.Float64Attribute{
									Computed:            true,
									Description:         "The size of the disk in GB.",
									MarkdownDescription: "The size of the disk in GB.",
								},
							},
							CustomType: DisksType{
								ObjectType: types.ObjectType{
									AttrTypes: DisksValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "A list of the disks that are currently attached to the server.",
						MarkdownDescription: "A list of the disks that are currently attached to the server.",
					},
					"failover_ips": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "A list of any assigned failover IP addresses for this server.",
						MarkdownDescription: "A list of any assigned failover IP addresses for this server.",
					},
					"features": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "A list of the currently enabled features on this server.",
						MarkdownDescription: "A list of the currently enabled features on this server.",
					},
					"host": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"display_name": schema.StringAttribute{
								Computed:            true,
								Description:         "The name for this host.",
								MarkdownDescription: "The name for this host.",
							},
							"status_page": schema.StringAttribute{
								Computed:            true,
								Description:         "This is the URL of the status page of the host. This will normally only be set if the host is under maintenance.",
								MarkdownDescription: "This is the URL of the status page of the host. This will normally only be set if the host is under maintenance.",
							},
							"uptime_ms": schema.Int64Attribute{
								Computed:            true,
								Description:         "The current uptime in milliseconds of this host.",
								MarkdownDescription: "The current uptime in milliseconds of this host.",
							},
						},
						CustomType: HostType{
							ObjectType: types.ObjectType{
								AttrTypes: HostValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "Summary information about the host of this server.",
						MarkdownDescription: "Summary information about the host of this server.",
					},
					"id": schema.Int64Attribute{
						Computed:            true,
						Description:         "The ID of this server.",
						MarkdownDescription: "The ID of this server.",
					},
					"image": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"backup_info": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"backup_disks": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"description": schema.StringAttribute{
													Computed:            true,
													Description:         "A description of this disk.",
													MarkdownDescription: "A description of this disk.",
												},
												"id": schema.Int64Attribute{
													Computed:            true,
													Description:         "The ID of this backup disk.",
													MarkdownDescription: "The ID of this backup disk.",
												},
												"min_disk_size": schema.Int64Attribute{
													Computed:            true,
													Description:         "This is the minimum disk size in GB required to restore this disk image.",
													MarkdownDescription: "This is the minimum disk size in GB required to restore this disk image.",
												},
												"size_gigabytes": schema.Float64Attribute{
													Computed:            true,
													Description:         "This is the compressed size of the disk image in GB.",
													MarkdownDescription: "This is the compressed size of the disk image in GB.",
												},
											},
											CustomType: BackupDisksType{
												ObjectType: types.ObjectType{
													AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed:            true,
										Description:         "A list of the individual disks that make up this backup.",
										MarkdownDescription: "A list of the individual disks that make up this backup.",
									},
									"iso": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is true the backup is an ISO image and cannot be restored. ISO images may only be attached for use as a boot disk or an additional disk.",
										MarkdownDescription: "If this is true the backup is an ISO image and cannot be restored. ISO images may only be attached for use as a boot disk or an additional disk.",
									},
									"locked": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is true the backup is locked and cannot be replaced.",
										MarkdownDescription: "If this is true the backup is locked and cannot be replaced.",
									},
									"offsite": schema.BoolAttribute{
										Computed:            true,
										Description:         "If this is true, an attempt to create an offsite copy was made. This does not mean that the offsite copy attempt was successful or that the copy still exists.",
										MarkdownDescription: "If this is true, an attempt to create an offsite copy was made. This does not mean that the offsite copy attempt was successful or that the copy still exists.",
									},
									"server_id": schema.Int64Attribute{
										Computed:            true,
										Description:         "The server ID that was used to create this backup.",
										MarkdownDescription: "The server ID that was used to create this backup.",
									},
									"type": schema.StringAttribute{
										Computed:            true,
										Description:         "\n| Value | Description |\n| ----- | ----------- |\n| daily | A backup which is scheduled to be taken each day. |\n| weekly | A backup which is scheduled to be taken each week. |\n| monthly | A backup which is scheduled to be taken each month. |\n| temporary | A backup which is created on demand and only retained for a maximum of seven days. |\n\n",
										MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| daily | A backup which is scheduled to be taken each day. |\n| weekly | A backup which is scheduled to be taken each week. |\n| monthly | A backup which is scheduled to be taken each month. |\n| temporary | A backup which is created on demand and only retained for a maximum of seven days. |\n\n",
									},
								},
								CustomType: BackupInfoType{
									ObjectType: types.ObjectType{
										AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "If this image is a backup, this object will provide further information.",
								MarkdownDescription: "If this image is a backup, this object will provide further information.",
							},
							"created_at": schema.StringAttribute{
								Computed:            true,
								Description:         "If this is a backup image this is the date and time in ISO8601 format when the image was created.",
								MarkdownDescription: "If this is a backup image this is the date and time in ISO8601 format when the image was created.",
							},
							"description": schema.StringAttribute{
								Computed:            true,
								Description:         "A description that may provide further details or warnings about the image.",
								MarkdownDescription: "A description that may provide further details or warnings about the image.",
							},
							"distribution": schema.StringAttribute{
								Computed:            true,
								Description:         "If this is an operating system image, this is the name of the distribution. If this is a backup image, this is the name of the distribution the server is using.",
								MarkdownDescription: "If this is an operating system image, this is the name of the distribution. If this is a backup image, this is the name of the distribution the server is using.",
							},
							"distribution_info": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"features": schema.ListAttribute{
										ElementType:         types.StringType,
										Computed:            true,
										Description:         "Features supported by this distribution.",
										MarkdownDescription: "Features supported by this distribution.",
									},
									"image_id": schema.Int64Attribute{
										Computed:            true,
										Description:         "If this is a backup image, the operating system ID of the server at the time the backup was created.",
										MarkdownDescription: "If this is a backup image, the operating system ID of the server at the time the backup was created.",
									},
									"password_recovery": schema.StringAttribute{
										Computed:            true,
										Description:         "Supported methods of password recovery.\n\n| Value | Description |\n| ----- | ----------- |\n| manual | Password must be reset manually using the recovery console and rescue disk. |\n| offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |\n| offline-change | Password can be reset and new credentials sent (Requires restart). |\n| online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |\n\n",
										MarkdownDescription: "Supported methods of password recovery.\n\n| Value | Description |\n| ----- | ----------- |\n| manual | Password must be reset manually using the recovery console and rescue disk. |\n| offline-clear | Password can be cleared for the admin/root user only. New password needs to be provided on login via the console (Requires restart). |\n| offline-change | Password can be reset and new credentials sent (Requires restart). |\n| online-change | Password may be reset without requiring a reboot via installed QEMU Guest Agent. |\n\n",
									},
									"remote_access_user": schema.StringAttribute{
										Computed:            true,
										Description:         "User name to use when connecting via remote access (RDP or SSH).",
										MarkdownDescription: "User name to use when connecting via remote access (RDP or SSH).",
									},
								},
								CustomType: DistributionInfoType{
									ObjectType: types.ObjectType{
										AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "This object may provide further information about the distribution.",
								MarkdownDescription: "This object may provide further information about the distribution.",
							},
							"distribution_surcharges": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"surcharge_base_cost": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost for using this operating system as the base image for a size.",
										MarkdownDescription: "The additional cost for using this operating system as the base image for a size.",
									},
									"surcharge_min_vcpu": schema.Int64Attribute{
										Computed:            true,
										Description:         "The minimum vcpu count for surcharge calculations.",
										MarkdownDescription: "The minimum vcpu count for surcharge calculations.",
									},
									"surcharge_per_memory_max_megabytes": schema.Int64Attribute{
										Computed:            true,
										Description:         "The maximum memory in MB that counts towards the surcharge_per_memory_mb. Any memory above this cap does not attract the surcharge.",
										MarkdownDescription: "The maximum memory in MB that counts towards the surcharge_per_memory_mb. Any memory above this cap does not attract the surcharge.",
									},
									"surcharge_per_memory_megabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per MB for using this operating system as the base image for a size.",
										MarkdownDescription: "The additional cost per MB for using this operating system as the base image for a size.",
									},
									"surcharge_per_vcpu": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per vcpu for using this operating system as the base image for a size.",
										MarkdownDescription: "The additional cost per vcpu for using this operating system as the base image for a size.",
									},
								},
								CustomType: DistributionSurchargesType{
									ObjectType: types.ObjectType{
										AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "If this is not null the use of this image may incur surcharges above the base cost of the server. All costs are in AU$.",
								MarkdownDescription: "If this is not null the use of this image may incur surcharges above the base cost of the server. All costs are in AU$.",
							},
							"error_message": schema.StringAttribute{
								Computed:            true,
								Description:         "If the image creation failed this may provide further information.",
								MarkdownDescription: "If the image creation failed this may provide further information.",
							},
							"full_name": schema.StringAttribute{
								Computed:            true,
								Description:         "If this is an operating system image, this is the name and version of the distribution. If this is a backup image, this is the server hostname and label of the backup if it exists, otherwise it is the server hostname and UTC timestamp of the creation of the image.",
								MarkdownDescription: "If this is an operating system image, this is the name and version of the distribution. If this is a backup image, this is the server hostname and label of the backup if it exists, otherwise it is the server hostname and UTC timestamp of the creation of the image.",
							},
							"id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of this image.",
								MarkdownDescription: "The ID of this image.",
							},
							"min_disk_size": schema.Int64Attribute{
								Computed:            true,
								Description:         "For a distribution image this is the minimum disk size in GB required to install the operating system. For a backup image this is the minimum total disk size in GB required to restore the backup.",
								MarkdownDescription: "For a distribution image this is the minimum disk size in GB required to install the operating system. For a backup image this is the minimum total disk size in GB required to restore the backup.",
							},
							"min_memory_megabytes": schema.Int64Attribute{
								Computed:            true,
								Description:         "This is minimum memory in MB necessary to support this operating system (or the base operating system for a backup image).",
								MarkdownDescription: "This is minimum memory in MB necessary to support this operating system (or the base operating system for a backup image).",
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "If this is an operating system image, this is the name of the operating system version. If this is a backup image, this is the label of the backup if it exists, otherwise it is the UTC timestamp of the creation of the image.",
								MarkdownDescription: "If this is an operating system image, this is the name of the operating system version. If this is a backup image, this is the label of the backup if it exists, otherwise it is the UTC timestamp of the creation of the image.",
							},
							"public": schema.BoolAttribute{
								Computed:            true,
								Description:         "A public image is available to all users. A private image is available only to the account that created the image.",
								MarkdownDescription: "A public image is available to all users. A private image is available only to the account that created the image.",
							},
							"regions": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The slugs of the regions where the image is available for use.",
								MarkdownDescription: "The slugs of the regions where the image is available for use.",
							},
							"size_gigabytes": schema.Float64Attribute{
								Computed:            true,
								Description:         "For a distribution image this is the disk size used in GB by the operating system on initial install. For a backup image this is the size of the compressed backup image in GB.",
								MarkdownDescription: "For a distribution image this is the disk size used in GB by the operating system on initial install. For a backup image this is the size of the compressed backup image in GB.",
							},
							"slug": schema.StringAttribute{
								Computed:            true,
								Description:         "If this is an operating system image this is a slug which may be used as an alternative to the ID as a reference.",
								MarkdownDescription: "If this is an operating system image this is a slug which may be used as an alternative to the ID as a reference.",
							},
							"status": schema.StringAttribute{
								Computed:            true,
								Description:         "\n| Value | Description |\n| ----- | ----------- |\n| NEW | The image is new. |\n| available | The image is available for use. |\n| pending | The image is pending and is not yet available for use. |\n| deleted | The image has been deleted and is no longer available for use. |\n\n",
								MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| NEW | The image is new. |\n| available | The image is available for use. |\n| pending | The image is pending and is not yet available for use. |\n| deleted | The image has been deleted and is no longer available for use. |\n\n",
							},
							"type": schema.StringAttribute{
								Computed:            true,
								Description:         "\n| Value | Description |\n| ----- | ----------- |\n| custom | An image uploaded by a user. |\n| snapshot | A snapshot. Snapshot creation is not currently supported so only distribution images will have this value. |\n| backup | A backup of a server. |\n\n",
								MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| custom | An image uploaded by a user. |\n| snapshot | A snapshot. Snapshot creation is not currently supported so only distribution images will have this value. |\n| backup | A backup of a server. |\n\n",
							},
						},
						CustomType: ImageType{
							ObjectType: types.ObjectType{
								AttrTypes: ImageValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The base image used to create this server.",
						MarkdownDescription: "The base image used to create this server.",
					},
					"kernel": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of this kernel.",
								MarkdownDescription: "The ID of this kernel.",
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "This name of this kernel.",
								MarkdownDescription: "This name of this kernel.",
							},
							"version": schema.StringAttribute{
								Computed:            true,
								Description:         "The version (if any) of this kernel.",
								MarkdownDescription: "The version (if any) of this kernel.",
							},
						},
						CustomType: KernelType{
							ObjectType: types.ObjectType{
								AttrTypes: KernelValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The currently selected kernel for the server.",
						MarkdownDescription: "The currently selected kernel for the server.",
					},
					"memory": schema.Int64Attribute{
						Computed:            true,
						Description:         "The memory in MB of this server.",
						MarkdownDescription: "The memory in MB of this server.",
					},
					"name": schema.StringAttribute{
						Computed:            true,
						Description:         "The hostname of this server.",
						MarkdownDescription: "The hostname of this server.",
					},
					"networks": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"ipv6_reverse_nameservers": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "Any configured IPv6 reverse nameservers for this server. Please see our documentation for how this interacts with IPv6 nameserver settings at the account level.",
								MarkdownDescription: "Any configured IPv6 reverse nameservers for this server. Please see our documentation for how this interacts with IPv6 nameserver settings at the account level.",
							},
							"port_blocking": schema.BoolAttribute{
								Computed:            true,
								Description:         "Whether the default port blocking is enabled for this server.",
								MarkdownDescription: "Whether the default port blocking is enabled for this server.",
							},
							"recent_ddos": schema.BoolAttribute{
								Computed:            true,
								Description:         "If this is true this server has been the target of a recent DDOS attack. An email will have been sent to your email address when the DDOS was detected (and if it has ended, when it ended) with more details.",
								MarkdownDescription: "If this is true this server has been the target of a recent DDOS attack. An email will have been sent to your email address when the DDOS was detected (and if it has ended, when it ended) with more details.",
							},
							"separate_private_network_interface": schema.BoolAttribute{
								Computed:            true,
								Description:         "Whether a separate private network interface is provided for the server's VPC traffic.",
								MarkdownDescription: "Whether a separate private network interface is provided for the server's VPC traffic.",
							},
							"source_and_destination_check": schema.BoolAttribute{
								Computed:            true,
								Description:         "If enabled, this server is only able to send and receive data packets directly addressed to an IP address assigned to this server.",
								MarkdownDescription: "If enabled, this server is only able to send and receive data packets directly addressed to an IP address assigned to this server.",
							},
							"v4": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"gateway": schema.StringAttribute{
											Computed:            true,
											Description:         "The gateway for this network.",
											MarkdownDescription: "The gateway for this network.",
										},
										"ip_address": schema.StringAttribute{
											Computed:            true,
											Description:         "The IP address for this network.",
											MarkdownDescription: "The IP address for this network.",
										},
										"nat_target": schema.StringAttribute{
											Computed:            true,
											Description:         "If this is not null this property is the private IP address which receives packets from this network.",
											MarkdownDescription: "If this is not null this property is the private IP address which receives packets from this network.",
										},
										"netmask": schema.StringAttribute{
											Computed: true,
										},
										"reverse_name": schema.StringAttribute{
											Computed:            true,
											Description:         "The reverse name (if any) for this network.",
											MarkdownDescription: "The reverse name (if any) for this network.",
										},
										"type": schema.StringAttribute{
											Computed:            true,
											Description:         "\n| Value | Description |\n| ----- | ----------- |\n| private | A private (non internet accessible) network. |\n| public | A public (internet accessible) network. |\n\n",
											MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| private | A private (non internet accessible) network. |\n| public | A public (internet accessible) network. |\n\n",
										},
									},
									CustomType: V4Type{
										ObjectType: types.ObjectType{
											AttrTypes: V4Value{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "A list of the IPv4 networks for this server.",
								MarkdownDescription: "A list of the IPv4 networks for this server.",
							},
							"v6": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"gateway": schema.StringAttribute{
											Computed:            true,
											Description:         "The gateway for this network.",
											MarkdownDescription: "The gateway for this network.",
										},
										"ip_address": schema.StringAttribute{
											Computed:            true,
											Description:         "The IP address for this network.",
											MarkdownDescription: "The IP address for this network.",
										},
										"nat_target": schema.StringAttribute{
											Computed:            true,
											Description:         "If this is not null this property is the private IP address which receives packets from this network.",
											MarkdownDescription: "If this is not null this property is the private IP address which receives packets from this network.",
										},
										"netmask": schema.StringAttribute{
											Computed: true,
										},
										"reverse_name": schema.StringAttribute{
											Computed:            true,
											Description:         "The reverse name (if any) for this network.",
											MarkdownDescription: "The reverse name (if any) for this network.",
										},
										"type": schema.StringAttribute{
											Computed:            true,
											Description:         "\n| Value | Description |\n| ----- | ----------- |\n| private | A private (non internet accessible) network. |\n| public | A public (internet accessible) network. |\n\n",
											MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| private | A private (non internet accessible) network. |\n| public | A public (internet accessible) network. |\n\n",
										},
									},
									CustomType: V6Type{
										ObjectType: types.ObjectType{
											AttrTypes: V6Value{}.AttributeTypes(ctx),
										},
									},
								},
								Computed:            true,
								Description:         "A list of the IPv6 networks for this server.",
								MarkdownDescription: "A list of the IPv6 networks for this server.",
							},
						},
						CustomType: NetworksType{
							ObjectType: types.ObjectType{
								AttrTypes: NetworksValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "A list of the networks of the server.",
						MarkdownDescription: "A list of the networks of the server.",
					},
					"next_backup_window": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"end": schema.StringAttribute{
								Computed:            true,
								Description:         "The expected latest date and time in ISO8601 format of the next scheduled backup.\nThis is not a guarantee that the backup will have started or completed by this date and time.",
								MarkdownDescription: "The expected latest date and time in ISO8601 format of the next scheduled backup.\nThis is not a guarantee that the backup will have started or completed by this date and time.",
							},
							"start": schema.StringAttribute{
								Computed:            true,
								Description:         "The approximate earliest start date and time in ISO8601 format of the next scheduled backup.",
								MarkdownDescription: "The approximate earliest start date and time in ISO8601 format of the next scheduled backup.",
							},
						},
						CustomType: NextBackupWindowType{
							ObjectType: types.ObjectType{
								AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The details of the next scheduled backup, if any.",
						MarkdownDescription: "The details of the next scheduled backup, if any.",
					},
					"partner_id": schema.Int64Attribute{
						Computed:            true,
						Description:         "The server ID of the partner of this server, if one has been assigned.",
						MarkdownDescription: "The server ID of the partner of this server, if one has been assigned.",
					},
					"password_change_supported": schema.BoolAttribute{
						Computed:            true,
						Description:         "If this is true the password_reset server action can be called to change a user's password. If this is false the password_reset server action will merely clear the root/administrator password allowing the password to be changed via the web console.",
						MarkdownDescription: "If this is true the password_reset server action can be called to change a user's password. If this is false the password_reset server action will merely clear the root/administrator password allowing the password to be changed via the web console.",
					},
					"permalink": schema.StringAttribute{
						Computed:            true,
						Description:         "A randomly generated two-word identifier assigned to servers in regions that support this feature.",
						MarkdownDescription: "A randomly generated two-word identifier assigned to servers in regions that support this feature.",
					},
					"region": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"available": schema.BoolAttribute{
								Computed:            true,
								Description:         "Whether this region is available for the allocation of new resources.",
								MarkdownDescription: "Whether this region is available for the allocation of new resources.",
							},
							"features": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of features available for resources in this region.",
								MarkdownDescription: "A list of features available for resources in this region.",
							},
							"name": schema.StringAttribute{
								Computed:            true,
								Description:         "The name of this region.",
								MarkdownDescription: "The name of this region.",
							},
							"name_servers": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of nameservers available for resources in this region.",
								MarkdownDescription: "A list of nameservers available for resources in this region.",
							},
							"sizes": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "The slugs of the sizes available in this region.",
								MarkdownDescription: "The slugs of the sizes available in this region.",
							},
							"slug": schema.StringAttribute{
								Computed:            true,
								Description:         "The unique slug for this region.",
								MarkdownDescription: "The unique slug for this region.",
							},
						},
						CustomType: RegionType{
							ObjectType: types.ObjectType{
								AttrTypes: RegionValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The region this server is allocated to.",
						MarkdownDescription: "The region this server is allocated to.",
					},
					"selected_size_options": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"daily_backups": schema.Int64Attribute{
								Computed:            true,
								Description:         "The number of retained daily backups. e.g. if this is '2' we will store two daily backups, so each daily backup will be retained for two days before being overwritten.",
								MarkdownDescription: "The number of retained daily backups. e.g. if this is '2' we will store two daily backups, so each daily backup will be retained for two days before being overwritten.",
							},
							"disk": schema.Int64Attribute{
								Computed:            true,
								Description:         "The total storage in GB for this server.",
								MarkdownDescription: "The total storage in GB for this server.",
							},
							"ipv4_addresses": schema.Int64Attribute{
								Computed:            true,
								Description:         "The total count of IPv4 addresses for this server.",
								MarkdownDescription: "The total count of IPv4 addresses for this server.",
							},
							"memory": schema.Int64Attribute{
								Computed:            true,
								Description:         "The total memory in MB for this server.",
								MarkdownDescription: "The total memory in MB for this server.",
							},
							"monthly_backups": schema.Int64Attribute{
								Computed:            true,
								Description:         "The number of retained monthly backups. e.g. if this is '3' we will store three monthly backups, so each monthly backup will be retained for three months before being overwritten.",
								MarkdownDescription: "The number of retained monthly backups. e.g. if this is '3' we will store three monthly backups, so each monthly backup will be retained for three months before being overwritten.",
							},
							"offsite_backups": schema.BoolAttribute{
								Computed:            true,
								Description:         "If this is true any daily, weekly or monthly backups will be duplicated to an off-site location.",
								MarkdownDescription: "If this is true any daily, weekly or monthly backups will be duplicated to an off-site location.",
							},
							"transfer": schema.Float64Attribute{
								Computed:            true,
								Description:         "The total transfer per month in TB for this server.",
								MarkdownDescription: "The total transfer per month in TB for this server.",
							},
							"weekly_backups": schema.Int64Attribute{
								Computed:            true,
								Description:         "The number of retained weekly backups. e.g. if this is '1' we will store one weekly backup, so that weekly backup will be retained for one week before being overwritten.",
								MarkdownDescription: "The number of retained weekly backups. e.g. if this is '1' we will store one weekly backup, so that weekly backup will be retained for one week before being overwritten.",
							},
						},
						CustomType: SelectedSizeOptionsType{
							ObjectType: types.ObjectType{
								AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "An object that details the selected options for the current size.",
						MarkdownDescription: "An object that details the selected options for the current size.",
					},
					"size": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"available": schema.BoolAttribute{
								Computed:            true,
								Description:         "If this is false the size is not available for new servers.",
								MarkdownDescription: "If this is false the size is not available for new servers.",
							},
							"cpu_description": schema.StringAttribute{
								Computed:            true,
								Description:         "A description of the CPU provided in this size.",
								MarkdownDescription: "A description of the CPU provided in this size.",
							},
							"description": schema.StringAttribute{
								Computed:            true,
								Description:         "A description of this size.",
								MarkdownDescription: "A description of this size.",
							},
							"disk": schema.Int64Attribute{
								Computed:            true,
								Description:         "The included storage for this size in GB.",
								MarkdownDescription: "The included storage for this size in GB.",
							},
							"excess_transfer_cost_per_gigabyte": schema.Float64Attribute{
								Computed:            true,
								Description:         "The excess charged for any transfer above the included data transfer in AU$ per GB.",
								MarkdownDescription: "The excess charged for any transfer above the included data transfer in AU$ per GB.",
							},
							"memory": schema.Int64Attribute{
								Computed:            true,
								Description:         "The included memory for this size in MB.",
								MarkdownDescription: "The included memory for this size in MB.",
							},
							"options2": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"backups_cost_per_backup_per_gigabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The cost per GB of storage of each selected backup. See the API support document for how to calculate the final cost of backups based on the options selected.",
										MarkdownDescription: "The cost per GB of storage of each selected backup. See the API support document for how to calculate the final cost of backups based on the options selected.",
									},
									"daily_backups": schema.Int64Attribute{
										Computed:            true,
										Description:         "The number of daily backups included in the base size cost.",
										MarkdownDescription: "The number of daily backups included in the base size cost.",
									},
									"discount_for_no_public_ipv4": schema.Float64Attribute{
										Computed:            true,
										Description:         "This is the discount (if any) that is applied if no public IPv4 addresses are selected.",
										MarkdownDescription: "This is the discount (if any) that is applied if no public IPv4 addresses are selected.",
									},
									"disk_cost_per_additional_gigabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per GB per month for additional storage space.",
										MarkdownDescription: "The additional cost per GB per month for additional storage space.",
									},
									"disk_max": schema.Int64Attribute{
										Computed:            true,
										Description:         "The maximum storage in GB permitted on this size.",
										MarkdownDescription: "The maximum storage in GB permitted on this size.",
									},
									"disk_min": schema.Int64Attribute{
										Computed:            true,
										Description:         "The minimum storage in GB permitted on this size.",
										MarkdownDescription: "The minimum storage in GB permitted on this size.",
									},
									"ipv4_addresses_cost_per_address": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per public IPv4 address per month for additional IPv4 addresses.",
										MarkdownDescription: "The additional cost per public IPv4 address per month for additional IPv4 addresses.",
									},
									"ipv4_addresses_max": schema.Int64Attribute{
										Computed:            true,
										Description:         "The maximum number of IPv4 addresses permitted on this size.",
										MarkdownDescription: "The maximum number of IPv4 addresses permitted on this size.",
									},
									"memory_cost_per_additional_megabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per MB per month for additional memory.",
										MarkdownDescription: "The additional cost per MB per month for additional memory.",
									},
									"memory_max": schema.Int64Attribute{
										Computed:            true,
										Description:         "The maximum memory in MB permitted on this size.",
										MarkdownDescription: "The maximum memory in MB permitted on this size.",
									},
									"monthly_backups": schema.Int64Attribute{
										Computed:            true,
										Description:         "The number of monthly backups included in the base size cost.",
										MarkdownDescription: "The number of monthly backups included in the base size cost.",
									},
									"offsite_backup_frequency_cost": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"daily_per_gigabyte": schema.Float64Attribute{
												Computed:            true,
												Description:         "The additional cost per GB per month for enabling daily offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
												MarkdownDescription: "The additional cost per GB per month for enabling daily offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											},
											"monthly_per_gigabyte": schema.Float64Attribute{
												Computed:            true,
												Description:         "The additional cost per GB per month for enabling monthly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
												MarkdownDescription: "The additional cost per GB per month for enabling monthly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											},
											"weekly_per_gigabyte": schema.Float64Attribute{
												Computed:            true,
												Description:         "The additional cost per GB per month for enabling weekly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
												MarkdownDescription: "The additional cost per GB per month for enabling weekly offsite backups. Only the highest value of the daily, weekly and monthly is applied. See the API support document for how to calculate the final cost of backups based on the options selected.",
											},
										},
										CustomType: OffsiteBackupFrequencyCostType{
											ObjectType: types.ObjectType{
												AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
											},
										},
										Computed:            true,
										Description:         "The additional cost per GB of storage for enabling offsite backups based on highest frequency of backups currently enabled. All costs are in AU$.",
										MarkdownDescription: "The additional cost per GB of storage for enabling offsite backups based on highest frequency of backups currently enabled. All costs are in AU$.",
									},
									"offsite_backups_cost_per_gigabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per GB of storage for enabling offsite backups. See the API support document for how to calculate the final cost of backups based on the options selected.",
										MarkdownDescription: "The additional cost per GB of storage for enabling offsite backups. See the API support document for how to calculate the final cost of backups based on the options selected.",
									},
									"restricted_disk_values": schema.ListAttribute{
										ElementType:         types.Int64Type,
										Computed:            true,
										Description:         "If this is null the normal valid values in the documentation for SizeOptionsRequest are used, otherwise only these values (in GB) are permitted.",
										MarkdownDescription: "If this is null the normal valid values in the documentation for SizeOptionsRequest are used, otherwise only these values (in GB) are permitted.",
									},
									"transfer_cost_per_additional_gigabyte": schema.Float64Attribute{
										Computed:            true,
										Description:         "The additional cost per GB per month for additional included transfer.",
										MarkdownDescription: "The additional cost per GB per month for additional included transfer.",
									},
									"transfer_max": schema.Float64Attribute{
										Computed:            true,
										Description:         "The maximum transfer in TB permitted for this size.",
										MarkdownDescription: "The maximum transfer in TB permitted for this size.",
									},
									"weekly_backups": schema.Int64Attribute{
										Computed:            true,
										Description:         "The number of weekly backups included in the base size cost.",
										MarkdownDescription: "The number of weekly backups included in the base size cost.",
									},
								},
								CustomType: Options2Type{
									ObjectType: types.ObjectType{
										AttrTypes: Options2Value{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "Available add-ons (optional features not included in the base price) for the size. All costs are in AU$ per month (pro-rated).",
								MarkdownDescription: "Available add-ons (optional features not included in the base price) for the size. All costs are in AU$ per month (pro-rated).",
							},
							"price_hourly": schema.Float64Attribute{
								Computed:            true,
								Description:         "Hourly price in AU$.",
								MarkdownDescription: "Hourly price in AU$.",
							},
							"price_monthly": schema.Float64Attribute{
								Computed:            true,
								Description:         "Monthly Price in AU$.",
								MarkdownDescription: "Monthly Price in AU$.",
							},
							"regions": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of region slugs where this size is available regardless of stock.\nIf this a response to a query that included a selected operating system this response will only include regions where that operating system is available on this size,\notherwise not all regions listed will support all operating systems on this size.",
								MarkdownDescription: "A list of region slugs where this size is available regardless of stock.\nIf this a response to a query that included a selected operating system this response will only include regions where that operating system is available on this size,\notherwise not all regions listed will support all operating systems on this size.",
							},
							"regions_out_of_stock": schema.ListAttribute{
								ElementType:         types.StringType,
								Computed:            true,
								Description:         "A list of region slugs where the size is normally available but is currently not available due to lack of stock.",
								MarkdownDescription: "A list of region slugs where the size is normally available but is currently not available due to lack of stock.",
							},
							"size_type": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"description": schema.StringAttribute{
										Computed:            true,
										Description:         "The description of this size type, generally used to indicate the intended use case for sizes of this type.",
										MarkdownDescription: "The description of this size type, generally used to indicate the intended use case for sizes of this type.",
									},
									"name": schema.StringAttribute{
										Computed:            true,
										Description:         "The name of this size type.",
										MarkdownDescription: "The name of this size type.",
									},
									"slug": schema.StringAttribute{
										Computed:            true,
										Description:         "The slug of this size type.",
										MarkdownDescription: "The slug of this size type.",
									},
								},
								CustomType: SizeTypeType{
									ObjectType: types.ObjectType{
										AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
									},
								},
								Computed:            true,
								Description:         "The type of this size, generally used to differentiate sizes optimized for different usages.",
								MarkdownDescription: "The type of this size, generally used to differentiate sizes optimized for different usages.",
							},
							"slug": schema.StringAttribute{
								Computed:            true,
								Description:         "The slug of this size.",
								MarkdownDescription: "The slug of this size.",
							},
							"storage_description": schema.StringAttribute{
								Computed:            true,
								Description:         "A description of the storage provided in this size.",
								MarkdownDescription: "A description of the storage provided in this size.",
							},
							"transfer": schema.Float64Attribute{
								Computed:            true,
								Description:         "The included data transfer for this size in TB.",
								MarkdownDescription: "The included data transfer for this size in TB.",
							},
							"vcpu_units": schema.StringAttribute{
								Computed:            true,
								Description:         "This is the unit that the vcpus field counts, e.g. \"core\" or \"thread\".",
								MarkdownDescription: "This is the unit that the vcpus field counts, e.g. \"core\" or \"thread\".",
							},
							"vcpus": schema.Int64Attribute{
								Computed:            true,
								Description:         "The count of virtual CPUs for this size. See vcpu_units for a description of how each virtual CPU maps to the underlying hardware.",
								MarkdownDescription: "The count of virtual CPUs for this size. See vcpu_units for a description of how each virtual CPU maps to the underlying hardware.",
							},
						},
						CustomType: SizeType{
							ObjectType: types.ObjectType{
								AttrTypes: SizeValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "The currently selected size for this server.",
						MarkdownDescription: "The currently selected size for this server.",
					},
					"size_slug": schema.StringAttribute{
						Computed:            true,
						Description:         "The slug of the currently selected size for this server.",
						MarkdownDescription: "The slug of the currently selected size for this server.",
					},
					"status": schema.StringAttribute{
						Computed:            true,
						Description:         "\n| Value | Description |\n| ----- | ----------- |\n| new | The server is currently in the process of building and is not yet available for use. |\n| active | The server is available for use. |\n| archive | The server is powered off due to cancellation or non payment. |\n| off | The server has been powered off, but may be powered back on. |\n\n",
						MarkdownDescription: "\n| Value | Description |\n| ----- | ----------- |\n| new | The server is currently in the process of building and is not yet available for use. |\n| active | The server is available for use. |\n| archive | The server is powered off due to cancellation or non payment. |\n| off | The server has been powered off, but may be powered back on. |\n\n",
					},
					"vcpus": schema.Int64Attribute{
						Computed:            true,
						Description:         "The number of virtual CPUs of this server.",
						MarkdownDescription: "The number of virtual CPUs of this server.",
					},
					"vpc_id": schema.Int64Attribute{
						Computed:            true,
						Description:         "The VPC ID that this server is allocated to. If this value is null the server is in the default (public) network for the region.",
						MarkdownDescription: "The VPC ID that this server is allocated to. If this value is null the server is in the default (public) network for the region.",
					},
				},
				CustomType: ServerType{
					ObjectType: types.ObjectType{
						AttrTypes: ServerValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"size": schema.StringAttribute{
				Required:            true,
				Description:         "The slug of the selected size.",
				MarkdownDescription: "The slug of the selected size.",
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1),
				},
			},
			"ssh_keys": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "This may be either the SSH keys Ids or fingerprints. If this is null or not provided any SSH keys that have been marked as default will be deployed (if the operating system supports SSH keys). Submit an empty array to disable deployment of default keys.",
				MarkdownDescription: "This may be either the SSH keys Ids or fingerprints. If this is null or not provided any SSH keys that have been marked as default will be deployed (if the operating system supports SSH keys). Submit an empty array to disable deployment of default keys.",
			},
			"user_data": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "If provided this will be used to initialise the new server. This must be left null if the Image does not support UserData, see DistributionInfo.Features for more information.",
				MarkdownDescription: "If provided this will be used to initialise the new server. This must be left null if the Image does not support UserData, see DistributionInfo.Features for more information.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(65536),
				},
			},
			"vpc_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Leave null to use default (public) network for the selected region.",
				MarkdownDescription: "Leave null to use default (public) network for the selected region.",
			},
		},
	}
}

type ServerModel struct {
	Backups      types.Bool    `tfsdk:"backups"`
	Id           types.Int64   `tfsdk:"id"`
	Image        types.String  `tfsdk:"image"`
	Ipv6         types.Bool    `tfsdk:"ipv6"`
	Licenses     types.List    `tfsdk:"licenses"`
	Links        LinksValue    `tfsdk:"links"`
	Name         types.String  `tfsdk:"name"`
	Options1     Options1Value `tfsdk:"options1"`
	Password     types.String  `tfsdk:"password"`
	PortBlocking types.Bool    `tfsdk:"port_blocking"`
	Region       types.String  `tfsdk:"region"`
	Server       ServerValue   `tfsdk:"server"`
	Size         types.String  `tfsdk:"size"`
	SshKeys      types.List    `tfsdk:"ssh_keys"`
	UserData     types.String  `tfsdk:"user_data"`
	VpcId        types.Int64   `tfsdk:"vpc_id"`
}

var _ basetypes.ObjectTypable = LicensesType{}

type LicensesType struct {
	basetypes.ObjectType
}

func (t LicensesType) Equal(o attr.Type) bool {
	other, ok := o.(LicensesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LicensesType) String() string {
	return "LicensesType"
}

func (t LicensesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	softwareIdAttribute, ok := attributes["software_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`software_id is missing from object`)

		return nil, diags
	}

	softwareIdVal, ok := softwareIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`software_id expected to be basetypes.Int64Value, was: %T`, softwareIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LicensesValue{
		Count:      countVal,
		SoftwareId: softwareIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLicensesValueNull() LicensesValue {
	return LicensesValue{
		state: attr.ValueStateNull,
	}
}

func NewLicensesValueUnknown() LicensesValue {
	return LicensesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLicensesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LicensesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LicensesValue Attribute Value",
				"While creating a LicensesValue value, a missing attribute value was detected. "+
					"A LicensesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LicensesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LicensesValue Attribute Type",
				"While creating a LicensesValue value, an invalid attribute value was detected. "+
					"A LicensesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LicensesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LicensesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LicensesValue Attribute Value",
				"While creating a LicensesValue value, an extra attribute value was detected. "+
					"A LicensesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LicensesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLicensesValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewLicensesValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	softwareIdAttribute, ok := attributes["software_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`software_id is missing from object`)

		return NewLicensesValueUnknown(), diags
	}

	softwareIdVal, ok := softwareIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`software_id expected to be basetypes.Int64Value, was: %T`, softwareIdAttribute))
	}

	if diags.HasError() {
		return NewLicensesValueUnknown(), diags
	}

	return LicensesValue{
		Count:      countVal,
		SoftwareId: softwareIdVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewLicensesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LicensesValue {
	object, diags := NewLicensesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLicensesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LicensesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLicensesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLicensesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLicensesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLicensesValueMust(LicensesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LicensesType) ValueType(ctx context.Context) attr.Value {
	return LicensesValue{}
}

var _ basetypes.ObjectValuable = LicensesValue{}

type LicensesValue struct {
	Count      basetypes.Int64Value `tfsdk:"count"`
	SoftwareId basetypes.Int64Value `tfsdk:"software_id"`
	state      attr.ValueState
}

func (v LicensesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["software_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		val, err = v.SoftwareId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["software_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LicensesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LicensesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LicensesValue) String() string {
	return "LicensesValue"
}

func (v LicensesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count":       basetypes.Int64Type{},
		"software_id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count":       v.Count,
			"software_id": v.SoftwareId,
		})

	return objVal, diags
}

func (v LicensesValue) Equal(o attr.Value) bool {
	other, ok := o.(LicensesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	if !v.SoftwareId.Equal(other.SoftwareId) {
		return false
	}

	return true
}

func (v LicensesValue) Type(ctx context.Context) attr.Type {
	return LicensesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LicensesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count":       basetypes.Int64Type{},
		"software_id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LinksType{}

type LinksType struct {
	basetypes.ObjectType
}

func (t LinksType) Equal(o attr.Type) bool {
	other, ok := o.(LinksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LinksType) String() string {
	return "LinksType"
}

func (t LinksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return nil, diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LinksValue{
		Actions: actionsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLinksValueNull() LinksValue {
	return LinksValue{
		state: attr.ValueStateNull,
	}
}

func NewLinksValueUnknown() LinksValue {
	return LinksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLinksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LinksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LinksValue Attribute Value",
				"While creating a LinksValue value, a missing attribute value was detected. "+
					"A LinksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LinksValue Attribute Type",
				"While creating a LinksValue value, an invalid attribute value was detected. "+
					"A LinksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LinksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LinksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LinksValue Attribute Value",
				"While creating a LinksValue value, an extra attribute value was detected. "+
					"A LinksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LinksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	actionsAttribute, ok := attributes["actions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`actions is missing from object`)

		return NewLinksValueUnknown(), diags
	}

	actionsVal, ok := actionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`actions expected to be basetypes.ListValue, was: %T`, actionsAttribute))
	}

	if diags.HasError() {
		return NewLinksValueUnknown(), diags
	}

	return LinksValue{
		Actions: actionsVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewLinksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LinksValue {
	object, diags := NewLinksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLinksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LinksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLinksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLinksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLinksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLinksValueMust(LinksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LinksType) ValueType(ctx context.Context) attr.Value {
	return LinksValue{}
}

var _ basetypes.ObjectValuable = LinksValue{}

type LinksValue struct {
	Actions basetypes.ListValue `tfsdk:"actions"`
	state   attr.ValueState
}

func (v LinksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["actions"] = basetypes.ListType{
		ElemType: ActionsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Actions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["actions"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LinksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LinksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LinksValue) String() string {
	return "LinksValue"
}

func (v LinksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	actions := types.ListValueMust(
		ActionsType{
			basetypes.ObjectType{
				AttrTypes: ActionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Actions.Elements(),
	)

	if v.Actions.IsNull() {
		actions = types.ListNull(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Actions.IsUnknown() {
		actions = types.ListUnknown(
			ActionsType{
				basetypes.ObjectType{
					AttrTypes: ActionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"actions": actions,
		})

	return objVal, diags
}

func (v LinksValue) Equal(o attr.Value) bool {
	other, ok := o.(LinksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Actions.Equal(other.Actions) {
		return false
	}

	return true
}

func (v LinksValue) Type(ctx context.Context) attr.Type {
	return LinksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LinksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"actions": basetypes.ListType{
			ElemType: ActionsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ActionsType{}

type ActionsType struct {
	basetypes.ObjectType
}

func (t ActionsType) Equal(o attr.Type) bool {
	other, ok := o.(ActionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionsType) String() string {
	return "ActionsType"
}

func (t ActionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return nil, diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return nil, diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionsValue{
		Href:  hrefVal,
		Id:    idVal,
		Rel:   relVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewActionsValueNull() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateNull,
	}
}

func NewActionsValueUnknown() ActionsValue {
	return ActionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionsValue Attribute Value",
				"While creating a ActionsValue value, a missing attribute value was detected. "+
					"A ActionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionsValue Attribute Type",
				"While creating a ActionsValue value, an invalid attribute value was detected. "+
					"A ActionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionsValue Attribute Value",
				"While creating a ActionsValue value, an extra attribute value was detected. "+
					"A ActionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	hrefAttribute, ok := attributes["href"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`href is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	hrefVal, ok := hrefAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`href expected to be basetypes.StringValue, was: %T`, hrefAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	relAttribute, ok := attributes["rel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rel is missing from object`)

		return NewActionsValueUnknown(), diags
	}

	relVal, ok := relAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rel expected to be basetypes.StringValue, was: %T`, relAttribute))
	}

	if diags.HasError() {
		return NewActionsValueUnknown(), diags
	}

	return ActionsValue{
		Href:  hrefVal,
		Id:    idVal,
		Rel:   relVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewActionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionsValue {
	object, diags := NewActionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionsValueMust(ActionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionsType) ValueType(ctx context.Context) attr.Value {
	return ActionsValue{}
}

var _ basetypes.ObjectValuable = ActionsValue{}

type ActionsValue struct {
	Href  basetypes.StringValue `tfsdk:"href"`
	Id    basetypes.Int64Value  `tfsdk:"id"`
	Rel   basetypes.StringValue `tfsdk:"rel"`
	state attr.ValueState
}

func (v ActionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["href"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rel"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Href.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["href"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Rel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rel"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionsValue) String() string {
	return "ActionsValue"
}

func (v ActionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"href": basetypes.StringType{},
		"id":   basetypes.Int64Type{},
		"rel":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"href": v.Href,
			"id":   v.Id,
			"rel":  v.Rel,
		})

	return objVal, diags
}

func (v ActionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Href.Equal(other.Href) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Rel.Equal(other.Rel) {
		return false
	}

	return true
}

func (v ActionsValue) Type(ctx context.Context) attr.Type {
	return ActionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"href": basetypes.StringType{},
		"id":   basetypes.Int64Type{},
		"rel":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Options1Type{}

type Options1Type struct {
	basetypes.ObjectType
}

func (t Options1Type) Equal(o attr.Type) bool {
	other, ok := o.(Options1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Options1Type) String() string {
	return "Options1Type"
}

func (t Options1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return nil, diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return nil, diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.Int64Value, was: %T`, ipv4AddressesAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return nil, diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupsAttribute, ok := attributes["offsite_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups is missing from object`)

		return nil, diags
	}

	offsiteBackupsVal, ok := offsiteBackupsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups expected to be basetypes.BoolValue, was: %T`, offsiteBackupsAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return nil, diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return nil, diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Options1Value{
		DailyBackups:   dailyBackupsVal,
		Disk:           diskVal,
		Ipv4Addresses:  ipv4AddressesVal,
		Memory:         memoryVal,
		MonthlyBackups: monthlyBackupsVal,
		OffsiteBackups: offsiteBackupsVal,
		Transfer:       transferVal,
		WeeklyBackups:  weeklyBackupsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOptions1ValueNull() Options1Value {
	return Options1Value{
		state: attr.ValueStateNull,
	}
}

func NewOptions1ValueUnknown() Options1Value {
	return Options1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOptions1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Options1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Options1Value Attribute Value",
				"While creating a Options1Value value, a missing attribute value was detected. "+
					"A Options1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Options1Value Attribute Type",
				"While creating a Options1Value value, an invalid attribute value was detected. "+
					"A Options1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Options1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Options1Value Attribute Value",
				"While creating a Options1Value value, an extra attribute value was detected. "+
					"A Options1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Options1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptions1ValueUnknown(), diags
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.Int64Value, was: %T`, ipv4AddressesAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupsAttribute, ok := attributes["offsite_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	offsiteBackupsVal, ok := offsiteBackupsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups expected to be basetypes.BoolValue, was: %T`, offsiteBackupsAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return NewOptions1ValueUnknown(), diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return NewOptions1ValueUnknown(), diags
	}

	return Options1Value{
		DailyBackups:   dailyBackupsVal,
		Disk:           diskVal,
		Ipv4Addresses:  ipv4AddressesVal,
		Memory:         memoryVal,
		MonthlyBackups: monthlyBackupsVal,
		OffsiteBackups: offsiteBackupsVal,
		Transfer:       transferVal,
		WeeklyBackups:  weeklyBackupsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOptions1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Options1Value {
	object, diags := NewOptions1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptions1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Options1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptions1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptions1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptions1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptions1ValueMust(Options1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Options1Type) ValueType(ctx context.Context) attr.Value {
	return Options1Value{}
}

var _ basetypes.ObjectValuable = Options1Value{}

type Options1Value struct {
	DailyBackups   basetypes.Int64Value   `tfsdk:"daily_backups"`
	Disk           basetypes.Int64Value   `tfsdk:"disk"`
	Ipv4Addresses  basetypes.Int64Value   `tfsdk:"ipv4_addresses"`
	Memory         basetypes.Int64Value   `tfsdk:"memory"`
	MonthlyBackups basetypes.Int64Value   `tfsdk:"monthly_backups"`
	OffsiteBackups basetypes.BoolValue    `tfsdk:"offsite_backups"`
	Transfer       basetypes.Float64Value `tfsdk:"transfer"`
	WeeklyBackups  basetypes.Int64Value   `tfsdk:"weekly_backups"`
	state          attr.ValueState
}

func (v Options1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["daily_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monthly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["offsite_backups"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["transfer"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DailyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_backups"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.Ipv4Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.MonthlyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_backups"] = val

		val, err = v.OffsiteBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backups"] = val

		val, err = v.Transfer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer"] = val

		val, err = v.WeeklyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_backups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Options1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Options1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Options1Value) String() string {
	return "Options1Value"
}

func (v Options1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"daily_backups":   basetypes.Int64Type{},
		"disk":            basetypes.Int64Type{},
		"ipv4_addresses":  basetypes.Int64Type{},
		"memory":          basetypes.Int64Type{},
		"monthly_backups": basetypes.Int64Type{},
		"offsite_backups": basetypes.BoolType{},
		"transfer":        basetypes.Float64Type{},
		"weekly_backups":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daily_backups":   v.DailyBackups,
			"disk":            v.Disk,
			"ipv4_addresses":  v.Ipv4Addresses,
			"memory":          v.Memory,
			"monthly_backups": v.MonthlyBackups,
			"offsite_backups": v.OffsiteBackups,
			"transfer":        v.Transfer,
			"weekly_backups":  v.WeeklyBackups,
		})

	return objVal, diags
}

func (v Options1Value) Equal(o attr.Value) bool {
	other, ok := o.(Options1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DailyBackups.Equal(other.DailyBackups) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.Ipv4Addresses.Equal(other.Ipv4Addresses) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.MonthlyBackups.Equal(other.MonthlyBackups) {
		return false
	}

	if !v.OffsiteBackups.Equal(other.OffsiteBackups) {
		return false
	}

	if !v.Transfer.Equal(other.Transfer) {
		return false
	}

	if !v.WeeklyBackups.Equal(other.WeeklyBackups) {
		return false
	}

	return true
}

func (v Options1Value) Type(ctx context.Context) attr.Type {
	return Options1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Options1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daily_backups":   basetypes.Int64Type{},
		"disk":            basetypes.Int64Type{},
		"ipv4_addresses":  basetypes.Int64Type{},
		"memory":          basetypes.Int64Type{},
		"monthly_backups": basetypes.Int64Type{},
		"offsite_backups": basetypes.BoolType{},
		"transfer":        basetypes.Float64Type{},
		"weekly_backups":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ServerType{}

type ServerType struct {
	basetypes.ObjectType
}

func (t ServerType) Equal(o attr.Type) bool {
	other, ok := o.(ServerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerType) String() string {
	return "ServerType"
}

func (t ServerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advancedFeaturesAttribute, ok := attributes["advanced_features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advanced_features is missing from object`)

		return nil, diags
	}

	advancedFeaturesVal, ok := advancedFeaturesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advanced_features expected to be basetypes.ObjectValue, was: %T`, advancedFeaturesAttribute))
	}

	attachedBackupAttribute, ok := attributes["attached_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_backup is missing from object`)

		return nil, diags
	}

	attachedBackupVal, ok := attachedBackupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_backup expected to be basetypes.ObjectValue, was: %T`, attachedBackupAttribute))
	}

	backupIdsAttribute, ok := attributes["backup_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_ids is missing from object`)

		return nil, diags
	}

	backupIdsVal, ok := backupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_ids expected to be basetypes.ListValue, was: %T`, backupIdsAttribute))
	}

	backupSettingsAttribute, ok := attributes["backup_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_settings is missing from object`)

		return nil, diags
	}

	backupSettingsVal, ok := backupSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_settings expected to be basetypes.ObjectValue, was: %T`, backupSettingsAttribute))
	}

	cancelledAtAttribute, ok := attributes["cancelled_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cancelled_at is missing from object`)

		return nil, diags
	}

	cancelledAtVal, ok := cancelledAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cancelled_at expected to be basetypes.StringValue, was: %T`, cancelledAtAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	disksAttribute, ok := attributes["disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disks is missing from object`)

		return nil, diags
	}

	disksVal, ok := disksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disks expected to be basetypes.ListValue, was: %T`, disksAttribute))
	}

	failoverIpsAttribute, ok := attributes["failover_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_ips is missing from object`)

		return nil, diags
	}

	failoverIpsVal, ok := failoverIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_ips expected to be basetypes.ListValue, was: %T`, failoverIpsAttribute))
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return nil, diags
	}

	hostVal, ok := hostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.ObjectValue, was: %T`, hostAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	kernelAttribute, ok := attributes["kernel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kernel is missing from object`)

		return nil, diags
	}

	kernelVal, ok := kernelAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kernel expected to be basetypes.ObjectValue, was: %T`, kernelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return nil, diags
	}

	networksVal, ok := networksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ObjectValue, was: %T`, networksAttribute))
	}

	nextBackupWindowAttribute, ok := attributes["next_backup_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_backup_window is missing from object`)

		return nil, diags
	}

	nextBackupWindowVal, ok := nextBackupWindowAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_backup_window expected to be basetypes.ObjectValue, was: %T`, nextBackupWindowAttribute))
	}

	partnerIdAttribute, ok := attributes["partner_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner_id is missing from object`)

		return nil, diags
	}

	partnerIdVal, ok := partnerIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner_id expected to be basetypes.Int64Value, was: %T`, partnerIdAttribute))
	}

	passwordChangeSupportedAttribute, ok := attributes["password_change_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_change_supported is missing from object`)

		return nil, diags
	}

	passwordChangeSupportedVal, ok := passwordChangeSupportedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_change_supported expected to be basetypes.BoolValue, was: %T`, passwordChangeSupportedAttribute))
	}

	permalinkAttribute, ok := attributes["permalink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permalink is missing from object`)

		return nil, diags
	}

	permalinkVal, ok := permalinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permalink expected to be basetypes.StringValue, was: %T`, permalinkAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return nil, diags
	}

	regionVal, ok := regionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.ObjectValue, was: %T`, regionAttribute))
	}

	selectedSizeOptionsAttribute, ok := attributes["selected_size_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`selected_size_options is missing from object`)

		return nil, diags
	}

	selectedSizeOptionsVal, ok := selectedSizeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`selected_size_options expected to be basetypes.ObjectValue, was: %T`, selectedSizeOptionsAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.ObjectValue, was: %T`, sizeAttribute))
	}

	sizeSlugAttribute, ok := attributes["size_slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_slug is missing from object`)

		return nil, diags
	}

	sizeSlugVal, ok := sizeSlugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_slug expected to be basetypes.StringValue, was: %T`, sizeSlugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	vpcIdAttribute, ok := attributes["vpc_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_id is missing from object`)

		return nil, diags
	}

	vpcIdVal, ok := vpcIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_id expected to be basetypes.Int64Value, was: %T`, vpcIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerValue{
		AdvancedFeatures:        advancedFeaturesVal,
		AttachedBackup:          attachedBackupVal,
		BackupIds:               backupIdsVal,
		BackupSettings:          backupSettingsVal,
		CancelledAt:             cancelledAtVal,
		CreatedAt:               createdAtVal,
		Disk:                    diskVal,
		Disks:                   disksVal,
		FailoverIps:             failoverIpsVal,
		Features:                featuresVal,
		Host:                    hostVal,
		Id:                      idVal,
		Image:                   imageVal,
		Kernel:                  kernelVal,
		Memory:                  memoryVal,
		Name:                    nameVal,
		Networks:                networksVal,
		NextBackupWindow:        nextBackupWindowVal,
		PartnerId:               partnerIdVal,
		PasswordChangeSupported: passwordChangeSupportedVal,
		Permalink:               permalinkVal,
		Region:                  regionVal,
		SelectedSizeOptions:     selectedSizeOptionsVal,
		Size:                    sizeVal,
		SizeSlug:                sizeSlugVal,
		Status:                  statusVal,
		Vcpus:                   vcpusVal,
		VpcId:                   vpcIdVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewServerValueNull() ServerValue {
	return ServerValue{
		state: attr.ValueStateNull,
	}
}

func NewServerValueUnknown() ServerValue {
	return ServerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerValue Attribute Value",
				"While creating a ServerValue value, a missing attribute value was detected. "+
					"A ServerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerValue Attribute Type",
				"While creating a ServerValue value, an invalid attribute value was detected. "+
					"A ServerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerValue Attribute Value",
				"While creating a ServerValue value, an extra attribute value was detected. "+
					"A ServerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerValueUnknown(), diags
	}

	advancedFeaturesAttribute, ok := attributes["advanced_features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advanced_features is missing from object`)

		return NewServerValueUnknown(), diags
	}

	advancedFeaturesVal, ok := advancedFeaturesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advanced_features expected to be basetypes.ObjectValue, was: %T`, advancedFeaturesAttribute))
	}

	attachedBackupAttribute, ok := attributes["attached_backup"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_backup is missing from object`)

		return NewServerValueUnknown(), diags
	}

	attachedBackupVal, ok := attachedBackupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_backup expected to be basetypes.ObjectValue, was: %T`, attachedBackupAttribute))
	}

	backupIdsAttribute, ok := attributes["backup_ids"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_ids is missing from object`)

		return NewServerValueUnknown(), diags
	}

	backupIdsVal, ok := backupIdsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_ids expected to be basetypes.ListValue, was: %T`, backupIdsAttribute))
	}

	backupSettingsAttribute, ok := attributes["backup_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_settings is missing from object`)

		return NewServerValueUnknown(), diags
	}

	backupSettingsVal, ok := backupSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_settings expected to be basetypes.ObjectValue, was: %T`, backupSettingsAttribute))
	}

	cancelledAtAttribute, ok := attributes["cancelled_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cancelled_at is missing from object`)

		return NewServerValueUnknown(), diags
	}

	cancelledAtVal, ok := cancelledAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cancelled_at expected to be basetypes.StringValue, was: %T`, cancelledAtAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewServerValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewServerValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	disksAttribute, ok := attributes["disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disks is missing from object`)

		return NewServerValueUnknown(), diags
	}

	disksVal, ok := disksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disks expected to be basetypes.ListValue, was: %T`, disksAttribute))
	}

	failoverIpsAttribute, ok := attributes["failover_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`failover_ips is missing from object`)

		return NewServerValueUnknown(), diags
	}

	failoverIpsVal, ok := failoverIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`failover_ips expected to be basetypes.ListValue, was: %T`, failoverIpsAttribute))
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewServerValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	hostAttribute, ok := attributes["host"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host is missing from object`)

		return NewServerValueUnknown(), diags
	}

	hostVal, ok := hostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host expected to be basetypes.ObjectValue, was: %T`, hostAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewServerValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewServerValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.ObjectValue, was: %T`, imageAttribute))
	}

	kernelAttribute, ok := attributes["kernel"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kernel is missing from object`)

		return NewServerValueUnknown(), diags
	}

	kernelVal, ok := kernelAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kernel expected to be basetypes.ObjectValue, was: %T`, kernelAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewServerValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServerValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	networksAttribute, ok := attributes["networks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`networks is missing from object`)

		return NewServerValueUnknown(), diags
	}

	networksVal, ok := networksAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`networks expected to be basetypes.ObjectValue, was: %T`, networksAttribute))
	}

	nextBackupWindowAttribute, ok := attributes["next_backup_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_backup_window is missing from object`)

		return NewServerValueUnknown(), diags
	}

	nextBackupWindowVal, ok := nextBackupWindowAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_backup_window expected to be basetypes.ObjectValue, was: %T`, nextBackupWindowAttribute))
	}

	partnerIdAttribute, ok := attributes["partner_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`partner_id is missing from object`)

		return NewServerValueUnknown(), diags
	}

	partnerIdVal, ok := partnerIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`partner_id expected to be basetypes.Int64Value, was: %T`, partnerIdAttribute))
	}

	passwordChangeSupportedAttribute, ok := attributes["password_change_supported"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_change_supported is missing from object`)

		return NewServerValueUnknown(), diags
	}

	passwordChangeSupportedVal, ok := passwordChangeSupportedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_change_supported expected to be basetypes.BoolValue, was: %T`, passwordChangeSupportedAttribute))
	}

	permalinkAttribute, ok := attributes["permalink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permalink is missing from object`)

		return NewServerValueUnknown(), diags
	}

	permalinkVal, ok := permalinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permalink expected to be basetypes.StringValue, was: %T`, permalinkAttribute))
	}

	regionAttribute, ok := attributes["region"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`region is missing from object`)

		return NewServerValueUnknown(), diags
	}

	regionVal, ok := regionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`region expected to be basetypes.ObjectValue, was: %T`, regionAttribute))
	}

	selectedSizeOptionsAttribute, ok := attributes["selected_size_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`selected_size_options is missing from object`)

		return NewServerValueUnknown(), diags
	}

	selectedSizeOptionsVal, ok := selectedSizeOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`selected_size_options expected to be basetypes.ObjectValue, was: %T`, selectedSizeOptionsAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewServerValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.ObjectValue, was: %T`, sizeAttribute))
	}

	sizeSlugAttribute, ok := attributes["size_slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_slug is missing from object`)

		return NewServerValueUnknown(), diags
	}

	sizeSlugVal, ok := sizeSlugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_slug expected to be basetypes.StringValue, was: %T`, sizeSlugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewServerValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewServerValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	vpcIdAttribute, ok := attributes["vpc_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vpc_id is missing from object`)

		return NewServerValueUnknown(), diags
	}

	vpcIdVal, ok := vpcIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vpc_id expected to be basetypes.Int64Value, was: %T`, vpcIdAttribute))
	}

	if diags.HasError() {
		return NewServerValueUnknown(), diags
	}

	return ServerValue{
		AdvancedFeatures:        advancedFeaturesVal,
		AttachedBackup:          attachedBackupVal,
		BackupIds:               backupIdsVal,
		BackupSettings:          backupSettingsVal,
		CancelledAt:             cancelledAtVal,
		CreatedAt:               createdAtVal,
		Disk:                    diskVal,
		Disks:                   disksVal,
		FailoverIps:             failoverIpsVal,
		Features:                featuresVal,
		Host:                    hostVal,
		Id:                      idVal,
		Image:                   imageVal,
		Kernel:                  kernelVal,
		Memory:                  memoryVal,
		Name:                    nameVal,
		Networks:                networksVal,
		NextBackupWindow:        nextBackupWindowVal,
		PartnerId:               partnerIdVal,
		PasswordChangeSupported: passwordChangeSupportedVal,
		Permalink:               permalinkVal,
		Region:                  regionVal,
		SelectedSizeOptions:     selectedSizeOptionsVal,
		Size:                    sizeVal,
		SizeSlug:                sizeSlugVal,
		Status:                  statusVal,
		Vcpus:                   vcpusVal,
		VpcId:                   vpcIdVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewServerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerValue {
	object, diags := NewServerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerValueMust(ServerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerType) ValueType(ctx context.Context) attr.Value {
	return ServerValue{}
}

var _ basetypes.ObjectValuable = ServerValue{}

type ServerValue struct {
	AdvancedFeatures        basetypes.ObjectValue `tfsdk:"advanced_features"`
	AttachedBackup          basetypes.ObjectValue `tfsdk:"attached_backup"`
	BackupIds               basetypes.ListValue   `tfsdk:"backup_ids"`
	BackupSettings          basetypes.ObjectValue `tfsdk:"backup_settings"`
	CancelledAt             basetypes.StringValue `tfsdk:"cancelled_at"`
	CreatedAt               basetypes.StringValue `tfsdk:"created_at"`
	Disk                    basetypes.Int64Value  `tfsdk:"disk"`
	Disks                   basetypes.ListValue   `tfsdk:"disks"`
	FailoverIps             basetypes.ListValue   `tfsdk:"failover_ips"`
	Features                basetypes.ListValue   `tfsdk:"features"`
	Host                    basetypes.ObjectValue `tfsdk:"host"`
	Id                      basetypes.Int64Value  `tfsdk:"id"`
	Image                   basetypes.ObjectValue `tfsdk:"image"`
	Kernel                  basetypes.ObjectValue `tfsdk:"kernel"`
	Memory                  basetypes.Int64Value  `tfsdk:"memory"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	Networks                basetypes.ObjectValue `tfsdk:"networks"`
	NextBackupWindow        basetypes.ObjectValue `tfsdk:"next_backup_window"`
	PartnerId               basetypes.Int64Value  `tfsdk:"partner_id"`
	PasswordChangeSupported basetypes.BoolValue   `tfsdk:"password_change_supported"`
	Permalink               basetypes.StringValue `tfsdk:"permalink"`
	Region                  basetypes.ObjectValue `tfsdk:"region"`
	SelectedSizeOptions     basetypes.ObjectValue `tfsdk:"selected_size_options"`
	Size                    basetypes.ObjectValue `tfsdk:"size"`
	SizeSlug                basetypes.StringValue `tfsdk:"size_slug"`
	Status                  basetypes.StringValue `tfsdk:"status"`
	Vcpus                   basetypes.Int64Value  `tfsdk:"vcpus"`
	VpcId                   basetypes.Int64Value  `tfsdk:"vpc_id"`
	state                   attr.ValueState
}

func (v ServerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 28)

	var val tftypes.Value
	var err error

	attrTypes["advanced_features"] = basetypes.ObjectType{
		AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["attached_backup"] = basetypes.ObjectType{
		AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["backup_ids"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["backup_settings"] = basetypes.ObjectType{
		AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["cancelled_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disks"] = basetypes.ListType{
		ElemType: DisksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["failover_ips"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["features"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["host"] = basetypes.ObjectType{
		AttrTypes: HostValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.ObjectType{
		AttrTypes: ImageValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kernel"] = basetypes.ObjectType{
		AttrTypes: KernelValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["networks"] = basetypes.ObjectType{
		AttrTypes: NetworksValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["next_backup_window"] = basetypes.ObjectType{
		AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["partner_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["password_change_supported"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["permalink"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["region"] = basetypes.ObjectType{
		AttrTypes: RegionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["selected_size_options"] = basetypes.ObjectType{
		AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["size"] = basetypes.ObjectType{
		AttrTypes: SizeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["size_slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vpc_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 28)

		val, err = v.AdvancedFeatures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advanced_features"] = val

		val, err = v.AttachedBackup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attached_backup"] = val

		val, err = v.BackupIds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_ids"] = val

		val, err = v.BackupSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_settings"] = val

		val, err = v.CancelledAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cancelled_at"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.Disks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disks"] = val

		val, err = v.FailoverIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["failover_ips"] = val

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.Host.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Kernel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kernel"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Networks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["networks"] = val

		val, err = v.NextBackupWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_backup_window"] = val

		val, err = v.PartnerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["partner_id"] = val

		val, err = v.PasswordChangeSupported.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password_change_supported"] = val

		val, err = v.Permalink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permalink"] = val

		val, err = v.Region.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["region"] = val

		val, err = v.SelectedSizeOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["selected_size_options"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.SizeSlug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_slug"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		val, err = v.VpcId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vpc_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerValue) String() string {
	return "ServerValue"
}

func (v ServerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var advancedFeatures basetypes.ObjectValue

	if v.AdvancedFeatures.IsNull() {
		advancedFeatures = types.ObjectNull(
			AdvancedFeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if v.AdvancedFeatures.IsUnknown() {
		advancedFeatures = types.ObjectUnknown(
			AdvancedFeaturesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AdvancedFeatures.IsNull() && !v.AdvancedFeatures.IsUnknown() {
		advancedFeatures = types.ObjectValueMust(
			AdvancedFeaturesValue{}.AttributeTypes(ctx),
			v.AdvancedFeatures.Attributes(),
		)
	}

	var attachedBackup basetypes.ObjectValue

	if v.AttachedBackup.IsNull() {
		attachedBackup = types.ObjectNull(
			AttachedBackupValue{}.AttributeTypes(ctx),
		)
	}

	if v.AttachedBackup.IsUnknown() {
		attachedBackup = types.ObjectUnknown(
			AttachedBackupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AttachedBackup.IsNull() && !v.AttachedBackup.IsUnknown() {
		attachedBackup = types.ObjectValueMust(
			AttachedBackupValue{}.AttributeTypes(ctx),
			v.AttachedBackup.Attributes(),
		)
	}

	var backupSettings basetypes.ObjectValue

	if v.BackupSettings.IsNull() {
		backupSettings = types.ObjectNull(
			BackupSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if v.BackupSettings.IsUnknown() {
		backupSettings = types.ObjectUnknown(
			BackupSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BackupSettings.IsNull() && !v.BackupSettings.IsUnknown() {
		backupSettings = types.ObjectValueMust(
			BackupSettingsValue{}.AttributeTypes(ctx),
			v.BackupSettings.Attributes(),
		)
	}

	disks := types.ListValueMust(
		DisksType{
			basetypes.ObjectType{
				AttrTypes: DisksValue{}.AttributeTypes(ctx),
			},
		},
		v.Disks.Elements(),
	)

	if v.Disks.IsNull() {
		disks = types.ListNull(
			DisksType{
				basetypes.ObjectType{
					AttrTypes: DisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Disks.IsUnknown() {
		disks = types.ListUnknown(
			DisksType{
				basetypes.ObjectType{
					AttrTypes: DisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var host basetypes.ObjectValue

	if v.Host.IsNull() {
		host = types.ObjectNull(
			HostValue{}.AttributeTypes(ctx),
		)
	}

	if v.Host.IsUnknown() {
		host = types.ObjectUnknown(
			HostValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Host.IsNull() && !v.Host.IsUnknown() {
		host = types.ObjectValueMust(
			HostValue{}.AttributeTypes(ctx),
			v.Host.Attributes(),
		)
	}

	var image basetypes.ObjectValue

	if v.Image.IsNull() {
		image = types.ObjectNull(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if v.Image.IsUnknown() {
		image = types.ObjectUnknown(
			ImageValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Image.IsNull() && !v.Image.IsUnknown() {
		image = types.ObjectValueMust(
			ImageValue{}.AttributeTypes(ctx),
			v.Image.Attributes(),
		)
	}

	var kernel basetypes.ObjectValue

	if v.Kernel.IsNull() {
		kernel = types.ObjectNull(
			KernelValue{}.AttributeTypes(ctx),
		)
	}

	if v.Kernel.IsUnknown() {
		kernel = types.ObjectUnknown(
			KernelValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Kernel.IsNull() && !v.Kernel.IsUnknown() {
		kernel = types.ObjectValueMust(
			KernelValue{}.AttributeTypes(ctx),
			v.Kernel.Attributes(),
		)
	}

	var networks basetypes.ObjectValue

	if v.Networks.IsNull() {
		networks = types.ObjectNull(
			NetworksValue{}.AttributeTypes(ctx),
		)
	}

	if v.Networks.IsUnknown() {
		networks = types.ObjectUnknown(
			NetworksValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Networks.IsNull() && !v.Networks.IsUnknown() {
		networks = types.ObjectValueMust(
			NetworksValue{}.AttributeTypes(ctx),
			v.Networks.Attributes(),
		)
	}

	var nextBackupWindow basetypes.ObjectValue

	if v.NextBackupWindow.IsNull() {
		nextBackupWindow = types.ObjectNull(
			NextBackupWindowValue{}.AttributeTypes(ctx),
		)
	}

	if v.NextBackupWindow.IsUnknown() {
		nextBackupWindow = types.ObjectUnknown(
			NextBackupWindowValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NextBackupWindow.IsNull() && !v.NextBackupWindow.IsUnknown() {
		nextBackupWindow = types.ObjectValueMust(
			NextBackupWindowValue{}.AttributeTypes(ctx),
			v.NextBackupWindow.Attributes(),
		)
	}

	var region basetypes.ObjectValue

	if v.Region.IsNull() {
		region = types.ObjectNull(
			RegionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Region.IsUnknown() {
		region = types.ObjectUnknown(
			RegionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Region.IsNull() && !v.Region.IsUnknown() {
		region = types.ObjectValueMust(
			RegionValue{}.AttributeTypes(ctx),
			v.Region.Attributes(),
		)
	}

	var selectedSizeOptions basetypes.ObjectValue

	if v.SelectedSizeOptions.IsNull() {
		selectedSizeOptions = types.ObjectNull(
			SelectedSizeOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.SelectedSizeOptions.IsUnknown() {
		selectedSizeOptions = types.ObjectUnknown(
			SelectedSizeOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SelectedSizeOptions.IsNull() && !v.SelectedSizeOptions.IsUnknown() {
		selectedSizeOptions = types.ObjectValueMust(
			SelectedSizeOptionsValue{}.AttributeTypes(ctx),
			v.SelectedSizeOptions.Attributes(),
		)
	}

	var size basetypes.ObjectValue

	if v.Size.IsNull() {
		size = types.ObjectNull(
			SizeValue{}.AttributeTypes(ctx),
		)
	}

	if v.Size.IsUnknown() {
		size = types.ObjectUnknown(
			SizeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Size.IsNull() && !v.Size.IsUnknown() {
		size = types.ObjectValueMust(
			SizeValue{}.AttributeTypes(ctx),
			v.Size.Attributes(),
		)
	}

	backupIdsVal, d := types.ListValue(types.Int64Type, v.BackupIds.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advanced_features": basetypes.ObjectType{
				AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
			},
			"attached_backup": basetypes.ObjectType{
				AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
			},
			"backup_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"backup_settings": basetypes.ObjectType{
				AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
			},
			"cancelled_at": basetypes.StringType{},
			"created_at":   basetypes.StringType{},
			"disk":         basetypes.Int64Type{},
			"disks": basetypes.ListType{
				ElemType: DisksValue{}.Type(ctx),
			},
			"failover_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"host": basetypes.ObjectType{
				AttrTypes: HostValue{}.AttributeTypes(ctx),
			},
			"id": basetypes.Int64Type{},
			"image": basetypes.ObjectType{
				AttrTypes: ImageValue{}.AttributeTypes(ctx),
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"memory": basetypes.Int64Type{},
			"name":   basetypes.StringType{},
			"networks": basetypes.ObjectType{
				AttrTypes: NetworksValue{}.AttributeTypes(ctx),
			},
			"next_backup_window": basetypes.ObjectType{
				AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
			},
			"partner_id":                basetypes.Int64Type{},
			"password_change_supported": basetypes.BoolType{},
			"permalink":                 basetypes.StringType{},
			"region": basetypes.ObjectType{
				AttrTypes: RegionValue{}.AttributeTypes(ctx),
			},
			"selected_size_options": basetypes.ObjectType{
				AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
			},
			"size": basetypes.ObjectType{
				AttrTypes: SizeValue{}.AttributeTypes(ctx),
			},
			"size_slug": basetypes.StringType{},
			"status":    basetypes.StringType{},
			"vcpus":     basetypes.Int64Type{},
			"vpc_id":    basetypes.Int64Type{},
		}), diags
	}

	failoverIpsVal, d := types.ListValue(types.StringType, v.FailoverIps.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advanced_features": basetypes.ObjectType{
				AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
			},
			"attached_backup": basetypes.ObjectType{
				AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
			},
			"backup_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"backup_settings": basetypes.ObjectType{
				AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
			},
			"cancelled_at": basetypes.StringType{},
			"created_at":   basetypes.StringType{},
			"disk":         basetypes.Int64Type{},
			"disks": basetypes.ListType{
				ElemType: DisksValue{}.Type(ctx),
			},
			"failover_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"host": basetypes.ObjectType{
				AttrTypes: HostValue{}.AttributeTypes(ctx),
			},
			"id": basetypes.Int64Type{},
			"image": basetypes.ObjectType{
				AttrTypes: ImageValue{}.AttributeTypes(ctx),
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"memory": basetypes.Int64Type{},
			"name":   basetypes.StringType{},
			"networks": basetypes.ObjectType{
				AttrTypes: NetworksValue{}.AttributeTypes(ctx),
			},
			"next_backup_window": basetypes.ObjectType{
				AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
			},
			"partner_id":                basetypes.Int64Type{},
			"password_change_supported": basetypes.BoolType{},
			"permalink":                 basetypes.StringType{},
			"region": basetypes.ObjectType{
				AttrTypes: RegionValue{}.AttributeTypes(ctx),
			},
			"selected_size_options": basetypes.ObjectType{
				AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
			},
			"size": basetypes.ObjectType{
				AttrTypes: SizeValue{}.AttributeTypes(ctx),
			},
			"size_slug": basetypes.StringType{},
			"status":    basetypes.StringType{},
			"vcpus":     basetypes.Int64Type{},
			"vpc_id":    basetypes.Int64Type{},
		}), diags
	}

	featuresVal, d := types.ListValue(types.StringType, v.Features.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"advanced_features": basetypes.ObjectType{
				AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
			},
			"attached_backup": basetypes.ObjectType{
				AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
			},
			"backup_ids": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"backup_settings": basetypes.ObjectType{
				AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
			},
			"cancelled_at": basetypes.StringType{},
			"created_at":   basetypes.StringType{},
			"disk":         basetypes.Int64Type{},
			"disks": basetypes.ListType{
				ElemType: DisksValue{}.Type(ctx),
			},
			"failover_ips": basetypes.ListType{
				ElemType: types.StringType,
			},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"host": basetypes.ObjectType{
				AttrTypes: HostValue{}.AttributeTypes(ctx),
			},
			"id": basetypes.Int64Type{},
			"image": basetypes.ObjectType{
				AttrTypes: ImageValue{}.AttributeTypes(ctx),
			},
			"kernel": basetypes.ObjectType{
				AttrTypes: KernelValue{}.AttributeTypes(ctx),
			},
			"memory": basetypes.Int64Type{},
			"name":   basetypes.StringType{},
			"networks": basetypes.ObjectType{
				AttrTypes: NetworksValue{}.AttributeTypes(ctx),
			},
			"next_backup_window": basetypes.ObjectType{
				AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
			},
			"partner_id":                basetypes.Int64Type{},
			"password_change_supported": basetypes.BoolType{},
			"permalink":                 basetypes.StringType{},
			"region": basetypes.ObjectType{
				AttrTypes: RegionValue{}.AttributeTypes(ctx),
			},
			"selected_size_options": basetypes.ObjectType{
				AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
			},
			"size": basetypes.ObjectType{
				AttrTypes: SizeValue{}.AttributeTypes(ctx),
			},
			"size_slug": basetypes.StringType{},
			"status":    basetypes.StringType{},
			"vcpus":     basetypes.Int64Type{},
			"vpc_id":    basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"advanced_features": basetypes.ObjectType{
			AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
		},
		"attached_backup": basetypes.ObjectType{
			AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
		},
		"backup_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"backup_settings": basetypes.ObjectType{
			AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
		},
		"cancelled_at": basetypes.StringType{},
		"created_at":   basetypes.StringType{},
		"disk":         basetypes.Int64Type{},
		"disks": basetypes.ListType{
			ElemType: DisksValue{}.Type(ctx),
		},
		"failover_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host": basetypes.ObjectType{
			AttrTypes: HostValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.Int64Type{},
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
		"kernel": basetypes.ObjectType{
			AttrTypes: KernelValue{}.AttributeTypes(ctx),
		},
		"memory": basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"networks": basetypes.ObjectType{
			AttrTypes: NetworksValue{}.AttributeTypes(ctx),
		},
		"next_backup_window": basetypes.ObjectType{
			AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
		},
		"partner_id":                basetypes.Int64Type{},
		"password_change_supported": basetypes.BoolType{},
		"permalink":                 basetypes.StringType{},
		"region": basetypes.ObjectType{
			AttrTypes: RegionValue{}.AttributeTypes(ctx),
		},
		"selected_size_options": basetypes.ObjectType{
			AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
		},
		"size": basetypes.ObjectType{
			AttrTypes: SizeValue{}.AttributeTypes(ctx),
		},
		"size_slug": basetypes.StringType{},
		"status":    basetypes.StringType{},
		"vcpus":     basetypes.Int64Type{},
		"vpc_id":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advanced_features":         advancedFeatures,
			"attached_backup":           attachedBackup,
			"backup_ids":                backupIdsVal,
			"backup_settings":           backupSettings,
			"cancelled_at":              v.CancelledAt,
			"created_at":                v.CreatedAt,
			"disk":                      v.Disk,
			"disks":                     disks,
			"failover_ips":              failoverIpsVal,
			"features":                  featuresVal,
			"host":                      host,
			"id":                        v.Id,
			"image":                     image,
			"kernel":                    kernel,
			"memory":                    v.Memory,
			"name":                      v.Name,
			"networks":                  networks,
			"next_backup_window":        nextBackupWindow,
			"partner_id":                v.PartnerId,
			"password_change_supported": v.PasswordChangeSupported,
			"permalink":                 v.Permalink,
			"region":                    region,
			"selected_size_options":     selectedSizeOptions,
			"size":                      size,
			"size_slug":                 v.SizeSlug,
			"status":                    v.Status,
			"vcpus":                     v.Vcpus,
			"vpc_id":                    v.VpcId,
		})

	return objVal, diags
}

func (v ServerValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvancedFeatures.Equal(other.AdvancedFeatures) {
		return false
	}

	if !v.AttachedBackup.Equal(other.AttachedBackup) {
		return false
	}

	if !v.BackupIds.Equal(other.BackupIds) {
		return false
	}

	if !v.BackupSettings.Equal(other.BackupSettings) {
		return false
	}

	if !v.CancelledAt.Equal(other.CancelledAt) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.Disks.Equal(other.Disks) {
		return false
	}

	if !v.FailoverIps.Equal(other.FailoverIps) {
		return false
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.Host.Equal(other.Host) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Kernel.Equal(other.Kernel) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Networks.Equal(other.Networks) {
		return false
	}

	if !v.NextBackupWindow.Equal(other.NextBackupWindow) {
		return false
	}

	if !v.PartnerId.Equal(other.PartnerId) {
		return false
	}

	if !v.PasswordChangeSupported.Equal(other.PasswordChangeSupported) {
		return false
	}

	if !v.Permalink.Equal(other.Permalink) {
		return false
	}

	if !v.Region.Equal(other.Region) {
		return false
	}

	if !v.SelectedSizeOptions.Equal(other.SelectedSizeOptions) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.SizeSlug.Equal(other.SizeSlug) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	if !v.VpcId.Equal(other.VpcId) {
		return false
	}

	return true
}

func (v ServerValue) Type(ctx context.Context) attr.Type {
	return ServerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advanced_features": basetypes.ObjectType{
			AttrTypes: AdvancedFeaturesValue{}.AttributeTypes(ctx),
		},
		"attached_backup": basetypes.ObjectType{
			AttrTypes: AttachedBackupValue{}.AttributeTypes(ctx),
		},
		"backup_ids": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"backup_settings": basetypes.ObjectType{
			AttrTypes: BackupSettingsValue{}.AttributeTypes(ctx),
		},
		"cancelled_at": basetypes.StringType{},
		"created_at":   basetypes.StringType{},
		"disk":         basetypes.Int64Type{},
		"disks": basetypes.ListType{
			ElemType: DisksValue{}.Type(ctx),
		},
		"failover_ips": basetypes.ListType{
			ElemType: types.StringType,
		},
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"host": basetypes.ObjectType{
			AttrTypes: HostValue{}.AttributeTypes(ctx),
		},
		"id": basetypes.Int64Type{},
		"image": basetypes.ObjectType{
			AttrTypes: ImageValue{}.AttributeTypes(ctx),
		},
		"kernel": basetypes.ObjectType{
			AttrTypes: KernelValue{}.AttributeTypes(ctx),
		},
		"memory": basetypes.Int64Type{},
		"name":   basetypes.StringType{},
		"networks": basetypes.ObjectType{
			AttrTypes: NetworksValue{}.AttributeTypes(ctx),
		},
		"next_backup_window": basetypes.ObjectType{
			AttrTypes: NextBackupWindowValue{}.AttributeTypes(ctx),
		},
		"partner_id":                basetypes.Int64Type{},
		"password_change_supported": basetypes.BoolType{},
		"permalink":                 basetypes.StringType{},
		"region": basetypes.ObjectType{
			AttrTypes: RegionValue{}.AttributeTypes(ctx),
		},
		"selected_size_options": basetypes.ObjectType{
			AttrTypes: SelectedSizeOptionsValue{}.AttributeTypes(ctx),
		},
		"size": basetypes.ObjectType{
			AttrTypes: SizeValue{}.AttributeTypes(ctx),
		},
		"size_slug": basetypes.StringType{},
		"status":    basetypes.StringType{},
		"vcpus":     basetypes.Int64Type{},
		"vpc_id":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = AdvancedFeaturesType{}

type AdvancedFeaturesType struct {
	basetypes.ObjectType
}

func (t AdvancedFeaturesType) Equal(o attr.Type) bool {
	other, ok := o.(AdvancedFeaturesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AdvancedFeaturesType) String() string {
	return "AdvancedFeaturesType"
}

func (t AdvancedFeaturesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAdvancedFeaturesAttribute, ok := attributes["enabled_advanced_features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled_advanced_features is missing from object`)

		return nil, diags
	}

	enabledAdvancedFeaturesVal, ok := enabledAdvancedFeaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled_advanced_features expected to be basetypes.ListValue, was: %T`, enabledAdvancedFeaturesAttribute))
	}

	machineTypeAttribute, ok := attributes["machine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine_type is missing from object`)

		return nil, diags
	}

	machineTypeVal, ok := machineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine_type expected to be basetypes.StringValue, was: %T`, machineTypeAttribute))
	}

	processorModelAttribute, ok := attributes["processor_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processor_model is missing from object`)

		return nil, diags
	}

	processorModelVal, ok := processorModelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processor_model expected to be basetypes.Int64Value, was: %T`, processorModelAttribute))
	}

	videoDeviceAttribute, ok := attributes["video_device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`video_device is missing from object`)

		return nil, diags
	}

	videoDeviceVal, ok := videoDeviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`video_device expected to be basetypes.StringValue, was: %T`, videoDeviceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AdvancedFeaturesValue{
		EnabledAdvancedFeatures: enabledAdvancedFeaturesVal,
		MachineType:             machineTypeVal,
		ProcessorModel:          processorModelVal,
		VideoDevice:             videoDeviceVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewAdvancedFeaturesValueNull() AdvancedFeaturesValue {
	return AdvancedFeaturesValue{
		state: attr.ValueStateNull,
	}
}

func NewAdvancedFeaturesValueUnknown() AdvancedFeaturesValue {
	return AdvancedFeaturesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAdvancedFeaturesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AdvancedFeaturesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AdvancedFeaturesValue Attribute Value",
				"While creating a AdvancedFeaturesValue value, a missing attribute value was detected. "+
					"A AdvancedFeaturesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdvancedFeaturesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AdvancedFeaturesValue Attribute Type",
				"While creating a AdvancedFeaturesValue value, an invalid attribute value was detected. "+
					"A AdvancedFeaturesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AdvancedFeaturesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AdvancedFeaturesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AdvancedFeaturesValue Attribute Value",
				"While creating a AdvancedFeaturesValue value, an extra attribute value was detected. "+
					"A AdvancedFeaturesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AdvancedFeaturesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAdvancedFeaturesValueUnknown(), diags
	}

	enabledAdvancedFeaturesAttribute, ok := attributes["enabled_advanced_features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled_advanced_features is missing from object`)

		return NewAdvancedFeaturesValueUnknown(), diags
	}

	enabledAdvancedFeaturesVal, ok := enabledAdvancedFeaturesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled_advanced_features expected to be basetypes.ListValue, was: %T`, enabledAdvancedFeaturesAttribute))
	}

	machineTypeAttribute, ok := attributes["machine_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`machine_type is missing from object`)

		return NewAdvancedFeaturesValueUnknown(), diags
	}

	machineTypeVal, ok := machineTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`machine_type expected to be basetypes.StringValue, was: %T`, machineTypeAttribute))
	}

	processorModelAttribute, ok := attributes["processor_model"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`processor_model is missing from object`)

		return NewAdvancedFeaturesValueUnknown(), diags
	}

	processorModelVal, ok := processorModelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`processor_model expected to be basetypes.Int64Value, was: %T`, processorModelAttribute))
	}

	videoDeviceAttribute, ok := attributes["video_device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`video_device is missing from object`)

		return NewAdvancedFeaturesValueUnknown(), diags
	}

	videoDeviceVal, ok := videoDeviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`video_device expected to be basetypes.StringValue, was: %T`, videoDeviceAttribute))
	}

	if diags.HasError() {
		return NewAdvancedFeaturesValueUnknown(), diags
	}

	return AdvancedFeaturesValue{
		EnabledAdvancedFeatures: enabledAdvancedFeaturesVal,
		MachineType:             machineTypeVal,
		ProcessorModel:          processorModelVal,
		VideoDevice:             videoDeviceVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewAdvancedFeaturesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AdvancedFeaturesValue {
	object, diags := NewAdvancedFeaturesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAdvancedFeaturesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AdvancedFeaturesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAdvancedFeaturesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAdvancedFeaturesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAdvancedFeaturesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAdvancedFeaturesValueMust(AdvancedFeaturesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AdvancedFeaturesType) ValueType(ctx context.Context) attr.Value {
	return AdvancedFeaturesValue{}
}

var _ basetypes.ObjectValuable = AdvancedFeaturesValue{}

type AdvancedFeaturesValue struct {
	EnabledAdvancedFeatures basetypes.ListValue   `tfsdk:"enabled_advanced_features"`
	MachineType             basetypes.StringValue `tfsdk:"machine_type"`
	ProcessorModel          basetypes.Int64Value  `tfsdk:"processor_model"`
	VideoDevice             basetypes.StringValue `tfsdk:"video_device"`
	state                   attr.ValueState
}

func (v AdvancedFeaturesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled_advanced_features"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["machine_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["processor_model"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["video_device"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.EnabledAdvancedFeatures.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled_advanced_features"] = val

		val, err = v.MachineType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["machine_type"] = val

		val, err = v.ProcessorModel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["processor_model"] = val

		val, err = v.VideoDevice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["video_device"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AdvancedFeaturesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AdvancedFeaturesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AdvancedFeaturesValue) String() string {
	return "AdvancedFeaturesValue"
}

func (v AdvancedFeaturesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	enabledAdvancedFeaturesVal, d := types.ListValue(types.StringType, v.EnabledAdvancedFeatures.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"enabled_advanced_features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"machine_type":    basetypes.StringType{},
			"processor_model": basetypes.Int64Type{},
			"video_device":    basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"enabled_advanced_features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"machine_type":    basetypes.StringType{},
		"processor_model": basetypes.Int64Type{},
		"video_device":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled_advanced_features": enabledAdvancedFeaturesVal,
			"machine_type":              v.MachineType,
			"processor_model":           v.ProcessorModel,
			"video_device":              v.VideoDevice,
		})

	return objVal, diags
}

func (v AdvancedFeaturesValue) Equal(o attr.Value) bool {
	other, ok := o.(AdvancedFeaturesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EnabledAdvancedFeatures.Equal(other.EnabledAdvancedFeatures) {
		return false
	}

	if !v.MachineType.Equal(other.MachineType) {
		return false
	}

	if !v.ProcessorModel.Equal(other.ProcessorModel) {
		return false
	}

	if !v.VideoDevice.Equal(other.VideoDevice) {
		return false
	}

	return true
}

func (v AdvancedFeaturesValue) Type(ctx context.Context) attr.Type {
	return AdvancedFeaturesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AdvancedFeaturesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled_advanced_features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"machine_type":    basetypes.StringType{},
		"processor_model": basetypes.Int64Type{},
		"video_device":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AttachedBackupType{}

type AttachedBackupType struct {
	basetypes.ObjectType
}

func (t AttachedBackupType) Equal(o attr.Type) bool {
	other, ok := o.(AttachedBackupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AttachedBackupType) String() string {
	return "AttachedBackupType"
}

func (t AttachedBackupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	attachedAtAttribute, ok := attributes["attached_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_at is missing from object`)

		return nil, diags
	}

	attachedAtVal, ok := attachedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_at expected to be basetypes.StringValue, was: %T`, attachedAtAttribute))
	}

	attachmentExpiresAttribute, ok := attributes["attachment_expires"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attachment_expires is missing from object`)

		return nil, diags
	}

	attachmentExpiresVal, ok := attachmentExpiresAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attachment_expires expected to be basetypes.StringValue, was: %T`, attachmentExpiresAttribute))
	}

	diskIdentifiersAttribute, ok := attributes["disk_identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_identifiers is missing from object`)

		return nil, diags
	}

	diskIdentifiersVal, ok := diskIdentifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_identifiers expected to be basetypes.ListValue, was: %T`, diskIdentifiersAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AttachedBackupValue{
		AttachedAt:        attachedAtVal,
		AttachmentExpires: attachmentExpiresVal,
		DiskIdentifiers:   diskIdentifiersVal,
		Id:                idVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAttachedBackupValueNull() AttachedBackupValue {
	return AttachedBackupValue{
		state: attr.ValueStateNull,
	}
}

func NewAttachedBackupValueUnknown() AttachedBackupValue {
	return AttachedBackupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAttachedBackupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AttachedBackupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AttachedBackupValue Attribute Value",
				"While creating a AttachedBackupValue value, a missing attribute value was detected. "+
					"A AttachedBackupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachedBackupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AttachedBackupValue Attribute Type",
				"While creating a AttachedBackupValue value, an invalid attribute value was detected. "+
					"A AttachedBackupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AttachedBackupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AttachedBackupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AttachedBackupValue Attribute Value",
				"While creating a AttachedBackupValue value, an extra attribute value was detected. "+
					"A AttachedBackupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AttachedBackupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAttachedBackupValueUnknown(), diags
	}

	attachedAtAttribute, ok := attributes["attached_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attached_at is missing from object`)

		return NewAttachedBackupValueUnknown(), diags
	}

	attachedAtVal, ok := attachedAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attached_at expected to be basetypes.StringValue, was: %T`, attachedAtAttribute))
	}

	attachmentExpiresAttribute, ok := attributes["attachment_expires"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`attachment_expires is missing from object`)

		return NewAttachedBackupValueUnknown(), diags
	}

	attachmentExpiresVal, ok := attachmentExpiresAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`attachment_expires expected to be basetypes.StringValue, was: %T`, attachmentExpiresAttribute))
	}

	diskIdentifiersAttribute, ok := attributes["disk_identifiers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_identifiers is missing from object`)

		return NewAttachedBackupValueUnknown(), diags
	}

	diskIdentifiersVal, ok := diskIdentifiersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_identifiers expected to be basetypes.ListValue, was: %T`, diskIdentifiersAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewAttachedBackupValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	if diags.HasError() {
		return NewAttachedBackupValueUnknown(), diags
	}

	return AttachedBackupValue{
		AttachedAt:        attachedAtVal,
		AttachmentExpires: attachmentExpiresVal,
		DiskIdentifiers:   diskIdentifiersVal,
		Id:                idVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewAttachedBackupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AttachedBackupValue {
	object, diags := NewAttachedBackupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAttachedBackupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AttachedBackupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAttachedBackupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAttachedBackupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAttachedBackupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAttachedBackupValueMust(AttachedBackupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AttachedBackupType) ValueType(ctx context.Context) attr.Value {
	return AttachedBackupValue{}
}

var _ basetypes.ObjectValuable = AttachedBackupValue{}

type AttachedBackupValue struct {
	AttachedAt        basetypes.StringValue `tfsdk:"attached_at"`
	AttachmentExpires basetypes.StringValue `tfsdk:"attachment_expires"`
	DiskIdentifiers   basetypes.ListValue   `tfsdk:"disk_identifiers"`
	Id                basetypes.Int64Value  `tfsdk:"id"`
	state             attr.ValueState
}

func (v AttachedBackupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["attached_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["attachment_expires"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk_identifiers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AttachedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attached_at"] = val

		val, err = v.AttachmentExpires.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["attachment_expires"] = val

		val, err = v.DiskIdentifiers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_identifiers"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AttachedBackupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AttachedBackupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AttachedBackupValue) String() string {
	return "AttachedBackupValue"
}

func (v AttachedBackupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	diskIdentifiersVal, d := types.ListValue(types.StringType, v.DiskIdentifiers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"attached_at":        basetypes.StringType{},
			"attachment_expires": basetypes.StringType{},
			"disk_identifiers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"id": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"attached_at":        basetypes.StringType{},
		"attachment_expires": basetypes.StringType{},
		"disk_identifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"attached_at":        v.AttachedAt,
			"attachment_expires": v.AttachmentExpires,
			"disk_identifiers":   diskIdentifiersVal,
			"id":                 v.Id,
		})

	return objVal, diags
}

func (v AttachedBackupValue) Equal(o attr.Value) bool {
	other, ok := o.(AttachedBackupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AttachedAt.Equal(other.AttachedAt) {
		return false
	}

	if !v.AttachmentExpires.Equal(other.AttachmentExpires) {
		return false
	}

	if !v.DiskIdentifiers.Equal(other.DiskIdentifiers) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	return true
}

func (v AttachedBackupValue) Type(ctx context.Context) attr.Type {
	return AttachedBackupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AttachedBackupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"attached_at":        basetypes.StringType{},
		"attachment_expires": basetypes.StringType{},
		"disk_identifiers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"id": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BackupSettingsType{}

type BackupSettingsType struct {
	basetypes.ObjectType
}

func (t BackupSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(BackupSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BackupSettingsType) String() string {
	return "BackupSettingsType"
}

func (t BackupSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupDayOfMonthAttribute, ok := attributes["backup_day_of_month"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_day_of_month is missing from object`)

		return nil, diags
	}

	backupDayOfMonthVal, ok := backupDayOfMonthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_day_of_month expected to be basetypes.Int64Value, was: %T`, backupDayOfMonthAttribute))
	}

	backupDayOfWeekAttribute, ok := attributes["backup_day_of_week"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_day_of_week is missing from object`)

		return nil, diags
	}

	backupDayOfWeekVal, ok := backupDayOfWeekAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_day_of_week expected to be basetypes.Int64Value, was: %T`, backupDayOfWeekAttribute))
	}

	backupHourOfDayAttribute, ok := attributes["backup_hour_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_hour_of_day is missing from object`)

		return nil, diags
	}

	backupHourOfDayVal, ok := backupHourOfDayAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_hour_of_day expected to be basetypes.Int64Value, was: %T`, backupHourOfDayAttribute))
	}

	offsiteBackupSettingsAttribute, ok := attributes["offsite_backup_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_settings is missing from object`)

		return nil, diags
	}

	offsiteBackupSettingsVal, ok := offsiteBackupSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_settings expected to be basetypes.ObjectValue, was: %T`, offsiteBackupSettingsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BackupSettingsValue{
		BackupDayOfMonth:      backupDayOfMonthVal,
		BackupDayOfWeek:       backupDayOfWeekVal,
		BackupHourOfDay:       backupHourOfDayVal,
		OffsiteBackupSettings: offsiteBackupSettingsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewBackupSettingsValueNull() BackupSettingsValue {
	return BackupSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewBackupSettingsValueUnknown() BackupSettingsValue {
	return BackupSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBackupSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BackupSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BackupSettingsValue Attribute Value",
				"While creating a BackupSettingsValue value, a missing attribute value was detected. "+
					"A BackupSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BackupSettingsValue Attribute Type",
				"While creating a BackupSettingsValue value, an invalid attribute value was detected. "+
					"A BackupSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BackupSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BackupSettingsValue Attribute Value",
				"While creating a BackupSettingsValue value, an extra attribute value was detected. "+
					"A BackupSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BackupSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBackupSettingsValueUnknown(), diags
	}

	backupDayOfMonthAttribute, ok := attributes["backup_day_of_month"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_day_of_month is missing from object`)

		return NewBackupSettingsValueUnknown(), diags
	}

	backupDayOfMonthVal, ok := backupDayOfMonthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_day_of_month expected to be basetypes.Int64Value, was: %T`, backupDayOfMonthAttribute))
	}

	backupDayOfWeekAttribute, ok := attributes["backup_day_of_week"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_day_of_week is missing from object`)

		return NewBackupSettingsValueUnknown(), diags
	}

	backupDayOfWeekVal, ok := backupDayOfWeekAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_day_of_week expected to be basetypes.Int64Value, was: %T`, backupDayOfWeekAttribute))
	}

	backupHourOfDayAttribute, ok := attributes["backup_hour_of_day"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_hour_of_day is missing from object`)

		return NewBackupSettingsValueUnknown(), diags
	}

	backupHourOfDayVal, ok := backupHourOfDayAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_hour_of_day expected to be basetypes.Int64Value, was: %T`, backupHourOfDayAttribute))
	}

	offsiteBackupSettingsAttribute, ok := attributes["offsite_backup_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_settings is missing from object`)

		return NewBackupSettingsValueUnknown(), diags
	}

	offsiteBackupSettingsVal, ok := offsiteBackupSettingsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_settings expected to be basetypes.ObjectValue, was: %T`, offsiteBackupSettingsAttribute))
	}

	if diags.HasError() {
		return NewBackupSettingsValueUnknown(), diags
	}

	return BackupSettingsValue{
		BackupDayOfMonth:      backupDayOfMonthVal,
		BackupDayOfWeek:       backupDayOfWeekVal,
		BackupHourOfDay:       backupHourOfDayVal,
		OffsiteBackupSettings: offsiteBackupSettingsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewBackupSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BackupSettingsValue {
	object, diags := NewBackupSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBackupSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BackupSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBackupSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBackupSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBackupSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBackupSettingsValueMust(BackupSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BackupSettingsType) ValueType(ctx context.Context) attr.Value {
	return BackupSettingsValue{}
}

var _ basetypes.ObjectValuable = BackupSettingsValue{}

type BackupSettingsValue struct {
	BackupDayOfMonth      basetypes.Int64Value  `tfsdk:"backup_day_of_month"`
	BackupDayOfWeek       basetypes.Int64Value  `tfsdk:"backup_day_of_week"`
	BackupHourOfDay       basetypes.Int64Value  `tfsdk:"backup_hour_of_day"`
	OffsiteBackupSettings basetypes.ObjectValue `tfsdk:"offsite_backup_settings"`
	state                 attr.ValueState
}

func (v BackupSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["backup_day_of_month"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["backup_day_of_week"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["backup_hour_of_day"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["offsite_backup_settings"] = basetypes.ObjectType{
		AttrTypes: OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.BackupDayOfMonth.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_day_of_month"] = val

		val, err = v.BackupDayOfWeek.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_day_of_week"] = val

		val, err = v.BackupHourOfDay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_hour_of_day"] = val

		val, err = v.OffsiteBackupSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backup_settings"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BackupSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BackupSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BackupSettingsValue) String() string {
	return "BackupSettingsValue"
}

func (v BackupSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var offsiteBackupSettings basetypes.ObjectValue

	if v.OffsiteBackupSettings.IsNull() {
		offsiteBackupSettings = types.ObjectNull(
			OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if v.OffsiteBackupSettings.IsUnknown() {
		offsiteBackupSettings = types.ObjectUnknown(
			OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OffsiteBackupSettings.IsNull() && !v.OffsiteBackupSettings.IsUnknown() {
		offsiteBackupSettings = types.ObjectValueMust(
			OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
			v.OffsiteBackupSettings.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_day_of_month": basetypes.Int64Type{},
		"backup_day_of_week":  basetypes.Int64Type{},
		"backup_hour_of_day":  basetypes.Int64Type{},
		"offsite_backup_settings": basetypes.ObjectType{
			AttrTypes: OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_day_of_month":     v.BackupDayOfMonth,
			"backup_day_of_week":      v.BackupDayOfWeek,
			"backup_hour_of_day":      v.BackupHourOfDay,
			"offsite_backup_settings": offsiteBackupSettings,
		})

	return objVal, diags
}

func (v BackupSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(BackupSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupDayOfMonth.Equal(other.BackupDayOfMonth) {
		return false
	}

	if !v.BackupDayOfWeek.Equal(other.BackupDayOfWeek) {
		return false
	}

	if !v.BackupHourOfDay.Equal(other.BackupHourOfDay) {
		return false
	}

	if !v.OffsiteBackupSettings.Equal(other.OffsiteBackupSettings) {
		return false
	}

	return true
}

func (v BackupSettingsValue) Type(ctx context.Context) attr.Type {
	return BackupSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BackupSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_day_of_month": basetypes.Int64Type{},
		"backup_day_of_week":  basetypes.Int64Type{},
		"backup_hour_of_day":  basetypes.Int64Type{},
		"offsite_backup_settings": basetypes.ObjectType{
			AttrTypes: OffsiteBackupSettingsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OffsiteBackupSettingsType{}

type OffsiteBackupSettingsType struct {
	basetypes.ObjectType
}

func (t OffsiteBackupSettingsType) Equal(o attr.Type) bool {
	other, ok := o.(OffsiteBackupSettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OffsiteBackupSettingsType) String() string {
	return "OffsiteBackupSettingsType"
}

func (t OffsiteBackupSettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	manageOffsiteCopiesAttribute, ok := attributes["manage_offsite_copies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manage_offsite_copies is missing from object`)

		return nil, diags
	}

	manageOffsiteCopiesVal, ok := manageOffsiteCopiesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manage_offsite_copies expected to be basetypes.BoolValue, was: %T`, manageOffsiteCopiesAttribute))
	}

	offsiteBackupLocationAttribute, ok := attributes["offsite_backup_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_location is missing from object`)

		return nil, diags
	}

	offsiteBackupLocationVal, ok := offsiteBackupLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_location expected to be basetypes.StringValue, was: %T`, offsiteBackupLocationAttribute))
	}

	useCustomBackupLocationAttribute, ok := attributes["use_custom_backup_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_custom_backup_location is missing from object`)

		return nil, diags
	}

	useCustomBackupLocationVal, ok := useCustomBackupLocationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_custom_backup_location expected to be basetypes.BoolValue, was: %T`, useCustomBackupLocationAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OffsiteBackupSettingsValue{
		ManageOffsiteCopies:     manageOffsiteCopiesVal,
		OffsiteBackupLocation:   offsiteBackupLocationVal,
		UseCustomBackupLocation: useCustomBackupLocationVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupSettingsValueNull() OffsiteBackupSettingsValue {
	return OffsiteBackupSettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewOffsiteBackupSettingsValueUnknown() OffsiteBackupSettingsValue {
	return OffsiteBackupSettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOffsiteBackupSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OffsiteBackupSettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OffsiteBackupSettingsValue Attribute Value",
				"While creating a OffsiteBackupSettingsValue value, a missing attribute value was detected. "+
					"A OffsiteBackupSettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupSettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OffsiteBackupSettingsValue Attribute Type",
				"While creating a OffsiteBackupSettingsValue value, an invalid attribute value was detected. "+
					"A OffsiteBackupSettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupSettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OffsiteBackupSettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OffsiteBackupSettingsValue Attribute Value",
				"While creating a OffsiteBackupSettingsValue value, an extra attribute value was detected. "+
					"A OffsiteBackupSettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OffsiteBackupSettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOffsiteBackupSettingsValueUnknown(), diags
	}

	manageOffsiteCopiesAttribute, ok := attributes["manage_offsite_copies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`manage_offsite_copies is missing from object`)

		return NewOffsiteBackupSettingsValueUnknown(), diags
	}

	manageOffsiteCopiesVal, ok := manageOffsiteCopiesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`manage_offsite_copies expected to be basetypes.BoolValue, was: %T`, manageOffsiteCopiesAttribute))
	}

	offsiteBackupLocationAttribute, ok := attributes["offsite_backup_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_location is missing from object`)

		return NewOffsiteBackupSettingsValueUnknown(), diags
	}

	offsiteBackupLocationVal, ok := offsiteBackupLocationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_location expected to be basetypes.StringValue, was: %T`, offsiteBackupLocationAttribute))
	}

	useCustomBackupLocationAttribute, ok := attributes["use_custom_backup_location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`use_custom_backup_location is missing from object`)

		return NewOffsiteBackupSettingsValueUnknown(), diags
	}

	useCustomBackupLocationVal, ok := useCustomBackupLocationAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`use_custom_backup_location expected to be basetypes.BoolValue, was: %T`, useCustomBackupLocationAttribute))
	}

	if diags.HasError() {
		return NewOffsiteBackupSettingsValueUnknown(), diags
	}

	return OffsiteBackupSettingsValue{
		ManageOffsiteCopies:     manageOffsiteCopiesVal,
		OffsiteBackupLocation:   offsiteBackupLocationVal,
		UseCustomBackupLocation: useCustomBackupLocationVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OffsiteBackupSettingsValue {
	object, diags := NewOffsiteBackupSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOffsiteBackupSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OffsiteBackupSettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOffsiteBackupSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOffsiteBackupSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOffsiteBackupSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOffsiteBackupSettingsValueMust(OffsiteBackupSettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OffsiteBackupSettingsType) ValueType(ctx context.Context) attr.Value {
	return OffsiteBackupSettingsValue{}
}

var _ basetypes.ObjectValuable = OffsiteBackupSettingsValue{}

type OffsiteBackupSettingsValue struct {
	ManageOffsiteCopies     basetypes.BoolValue   `tfsdk:"manage_offsite_copies"`
	OffsiteBackupLocation   basetypes.StringValue `tfsdk:"offsite_backup_location"`
	UseCustomBackupLocation basetypes.BoolValue   `tfsdk:"use_custom_backup_location"`
	state                   attr.ValueState
}

func (v OffsiteBackupSettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["manage_offsite_copies"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["offsite_backup_location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["use_custom_backup_location"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ManageOffsiteCopies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["manage_offsite_copies"] = val

		val, err = v.OffsiteBackupLocation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backup_location"] = val

		val, err = v.UseCustomBackupLocation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["use_custom_backup_location"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OffsiteBackupSettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OffsiteBackupSettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OffsiteBackupSettingsValue) String() string {
	return "OffsiteBackupSettingsValue"
}

func (v OffsiteBackupSettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"manage_offsite_copies":      basetypes.BoolType{},
		"offsite_backup_location":    basetypes.StringType{},
		"use_custom_backup_location": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"manage_offsite_copies":      v.ManageOffsiteCopies,
			"offsite_backup_location":    v.OffsiteBackupLocation,
			"use_custom_backup_location": v.UseCustomBackupLocation,
		})

	return objVal, diags
}

func (v OffsiteBackupSettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(OffsiteBackupSettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ManageOffsiteCopies.Equal(other.ManageOffsiteCopies) {
		return false
	}

	if !v.OffsiteBackupLocation.Equal(other.OffsiteBackupLocation) {
		return false
	}

	if !v.UseCustomBackupLocation.Equal(other.UseCustomBackupLocation) {
		return false
	}

	return true
}

func (v OffsiteBackupSettingsValue) Type(ctx context.Context) attr.Type {
	return OffsiteBackupSettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OffsiteBackupSettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"manage_offsite_copies":      basetypes.BoolType{},
		"offsite_backup_location":    basetypes.StringType{},
		"use_custom_backup_location": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = DisksType{}

type DisksType struct {
	basetypes.ObjectType
}

func (t DisksType) Equal(o attr.Type) bool {
	other, ok := o.(DisksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DisksType) String() string {
	return "DisksType"
}

func (t DisksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return nil, diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		Primary:       primaryVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDisksValueNull() DisksValue {
	return DisksValue{
		state: attr.ValueStateNull,
	}
}

func NewDisksValueUnknown() DisksValue {
	return DisksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDisksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DisksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DisksValue Attribute Value",
				"While creating a DisksValue value, a missing attribute value was detected. "+
					"A DisksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DisksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DisksValue Attribute Type",
				"While creating a DisksValue value, an invalid attribute value was detected. "+
					"A DisksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DisksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DisksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DisksValue Attribute Value",
				"While creating a DisksValue value, an extra attribute value was detected. "+
					"A DisksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DisksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDisksValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDisksValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDisksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewDisksValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return NewDisksValueUnknown(), diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return NewDisksValueUnknown(), diags
	}

	return DisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		Primary:       primaryVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewDisksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DisksValue {
	object, diags := NewDisksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDisksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DisksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDisksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDisksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDisksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDisksValueMust(DisksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DisksType) ValueType(ctx context.Context) attr.Value {
	return DisksValue{}
}

var _ basetypes.ObjectValuable = DisksValue{}

type DisksValue struct {
	Description   basetypes.StringValue  `tfsdk:"description"`
	Id            basetypes.Int64Value   `tfsdk:"id"`
	Primary       basetypes.BoolValue    `tfsdk:"primary"`
	SizeGigabytes basetypes.Float64Value `tfsdk:"size_gigabytes"`
	state         attr.ValueState
}

func (v DisksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size_gigabytes"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		val, err = v.SizeGigabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_gigabytes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DisksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DisksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DisksValue) String() string {
	return "DisksValue"
}

func (v DisksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"primary":        basetypes.BoolType{},
		"size_gigabytes": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":    v.Description,
			"id":             v.Id,
			"primary":        v.Primary,
			"size_gigabytes": v.SizeGigabytes,
		})

	return objVal, diags
}

func (v DisksValue) Equal(o attr.Value) bool {
	other, ok := o.(DisksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	if !v.SizeGigabytes.Equal(other.SizeGigabytes) {
		return false
	}

	return true
}

func (v DisksValue) Type(ctx context.Context) attr.Type {
	return DisksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DisksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"primary":        basetypes.BoolType{},
		"size_gigabytes": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = HostType{}

type HostType struct {
	basetypes.ObjectType
}

func (t HostType) Equal(o attr.Type) bool {
	other, ok := o.(HostType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HostType) String() string {
	return "HostType"
}

func (t HostType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return nil, diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	statusPageAttribute, ok := attributes["status_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_page is missing from object`)

		return nil, diags
	}

	statusPageVal, ok := statusPageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_page expected to be basetypes.StringValue, was: %T`, statusPageAttribute))
	}

	uptimeMsAttribute, ok := attributes["uptime_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime_ms is missing from object`)

		return nil, diags
	}

	uptimeMsVal, ok := uptimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime_ms expected to be basetypes.Int64Value, was: %T`, uptimeMsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HostValue{
		DisplayName: displayNameVal,
		StatusPage:  statusPageVal,
		UptimeMs:    uptimeMsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewHostValueNull() HostValue {
	return HostValue{
		state: attr.ValueStateNull,
	}
}

func NewHostValueUnknown() HostValue {
	return HostValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHostValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HostValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HostValue Attribute Value",
				"While creating a HostValue value, a missing attribute value was detected. "+
					"A HostValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HostValue Attribute Type",
				"While creating a HostValue value, an invalid attribute value was detected. "+
					"A HostValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HostValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HostValue Attribute Value",
				"While creating a HostValue value, an extra attribute value was detected. "+
					"A HostValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HostValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHostValueUnknown(), diags
	}

	displayNameAttribute, ok := attributes["display_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`display_name is missing from object`)

		return NewHostValueUnknown(), diags
	}

	displayNameVal, ok := displayNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`display_name expected to be basetypes.StringValue, was: %T`, displayNameAttribute))
	}

	statusPageAttribute, ok := attributes["status_page"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status_page is missing from object`)

		return NewHostValueUnknown(), diags
	}

	statusPageVal, ok := statusPageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status_page expected to be basetypes.StringValue, was: %T`, statusPageAttribute))
	}

	uptimeMsAttribute, ok := attributes["uptime_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uptime_ms is missing from object`)

		return NewHostValueUnknown(), diags
	}

	uptimeMsVal, ok := uptimeMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uptime_ms expected to be basetypes.Int64Value, was: %T`, uptimeMsAttribute))
	}

	if diags.HasError() {
		return NewHostValueUnknown(), diags
	}

	return HostValue{
		DisplayName: displayNameVal,
		StatusPage:  statusPageVal,
		UptimeMs:    uptimeMsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewHostValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HostValue {
	object, diags := NewHostValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHostValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HostType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHostValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHostValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHostValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHostValueMust(HostValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HostType) ValueType(ctx context.Context) attr.Value {
	return HostValue{}
}

var _ basetypes.ObjectValuable = HostValue{}

type HostValue struct {
	DisplayName basetypes.StringValue `tfsdk:"display_name"`
	StatusPage  basetypes.StringValue `tfsdk:"status_page"`
	UptimeMs    basetypes.Int64Value  `tfsdk:"uptime_ms"`
	state       attr.ValueState
}

func (v HostValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["display_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status_page"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uptime_ms"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DisplayName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["display_name"] = val

		val, err = v.StatusPage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status_page"] = val

		val, err = v.UptimeMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uptime_ms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HostValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HostValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HostValue) String() string {
	return "HostValue"
}

func (v HostValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"status_page":  basetypes.StringType{},
		"uptime_ms":    basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"display_name": v.DisplayName,
			"status_page":  v.StatusPage,
			"uptime_ms":    v.UptimeMs,
		})

	return objVal, diags
}

func (v HostValue) Equal(o attr.Value) bool {
	other, ok := o.(HostValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DisplayName.Equal(other.DisplayName) {
		return false
	}

	if !v.StatusPage.Equal(other.StatusPage) {
		return false
	}

	if !v.UptimeMs.Equal(other.UptimeMs) {
		return false
	}

	return true
}

func (v HostValue) Type(ctx context.Context) attr.Type {
	return HostType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HostValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"display_name": basetypes.StringType{},
		"status_page":  basetypes.StringType{},
		"uptime_ms":    basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ImageType{}

type ImageType struct {
	basetypes.ObjectType
}

func (t ImageType) Equal(o attr.Type) bool {
	other, ok := o.(ImageType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ImageType) String() string {
	return "ImageType"
}

func (t ImageType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupInfoAttribute, ok := attributes["backup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_info is missing from object`)

		return nil, diags
	}

	backupInfoVal, ok := backupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_info expected to be basetypes.ObjectValue, was: %T`, backupInfoAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return nil, diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	distributionAttribute, ok := attributes["distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution is missing from object`)

		return nil, diags
	}

	distributionVal, ok := distributionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution expected to be basetypes.StringValue, was: %T`, distributionAttribute))
	}

	distributionInfoAttribute, ok := attributes["distribution_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_info is missing from object`)

		return nil, diags
	}

	distributionInfoVal, ok := distributionInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_info expected to be basetypes.ObjectValue, was: %T`, distributionInfoAttribute))
	}

	distributionSurchargesAttribute, ok := attributes["distribution_surcharges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_surcharges is missing from object`)

		return nil, diags
	}

	distributionSurchargesVal, ok := distributionSurchargesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_surcharges expected to be basetypes.ObjectValue, was: %T`, distributionSurchargesAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return nil, diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return nil, diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	minMemoryMegabytesAttribute, ok := attributes["min_memory_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_memory_megabytes is missing from object`)

		return nil, diags
	}

	minMemoryMegabytesVal, ok := minMemoryMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_memory_megabytes expected to be basetypes.Int64Value, was: %T`, minMemoryMegabytesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return nil, diags
	}

	publicVal, ok := publicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.BoolValue, was: %T`, publicAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return nil, diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return nil, diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ImageValue{
		BackupInfo:             backupInfoVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Distribution:           distributionVal,
		DistributionInfo:       distributionInfoVal,
		DistributionSurcharges: distributionSurchargesVal,
		ErrorMessage:           errorMessageVal,
		FullName:               fullNameVal,
		Id:                     idVal,
		MinDiskSize:            minDiskSizeVal,
		MinMemoryMegabytes:     minMemoryMegabytesVal,
		Name:                   nameVal,
		Public:                 publicVal,
		Regions:                regionsVal,
		SizeGigabytes:          sizeGigabytesVal,
		Slug:                   slugVal,
		Status:                 statusVal,
		ImageType:              typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewImageValueNull() ImageValue {
	return ImageValue{
		state: attr.ValueStateNull,
	}
}

func NewImageValueUnknown() ImageValue {
	return ImageValue{
		state: attr.ValueStateUnknown,
	}
}

func NewImageValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ImageValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ImageValue Attribute Value",
				"While creating a ImageValue value, a missing attribute value was detected. "+
					"A ImageValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ImageValue Attribute Type",
				"While creating a ImageValue value, an invalid attribute value was detected. "+
					"A ImageValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ImageValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ImageValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ImageValue Attribute Value",
				"While creating a ImageValue value, an extra attribute value was detected. "+
					"A ImageValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ImageValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	backupInfoAttribute, ok := attributes["backup_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_info is missing from object`)

		return NewImageValueUnknown(), diags
	}

	backupInfoVal, ok := backupInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_info expected to be basetypes.ObjectValue, was: %T`, backupInfoAttribute))
	}

	createdAtAttribute, ok := attributes["created_at"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created_at is missing from object`)

		return NewImageValueUnknown(), diags
	}

	createdAtVal, ok := createdAtAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created_at expected to be basetypes.StringValue, was: %T`, createdAtAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewImageValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	distributionAttribute, ok := attributes["distribution"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution is missing from object`)

		return NewImageValueUnknown(), diags
	}

	distributionVal, ok := distributionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution expected to be basetypes.StringValue, was: %T`, distributionAttribute))
	}

	distributionInfoAttribute, ok := attributes["distribution_info"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_info is missing from object`)

		return NewImageValueUnknown(), diags
	}

	distributionInfoVal, ok := distributionInfoAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_info expected to be basetypes.ObjectValue, was: %T`, distributionInfoAttribute))
	}

	distributionSurchargesAttribute, ok := attributes["distribution_surcharges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`distribution_surcharges is missing from object`)

		return NewImageValueUnknown(), diags
	}

	distributionSurchargesVal, ok := distributionSurchargesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`distribution_surcharges expected to be basetypes.ObjectValue, was: %T`, distributionSurchargesAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewImageValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return NewImageValueUnknown(), diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewImageValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return NewImageValueUnknown(), diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	minMemoryMegabytesAttribute, ok := attributes["min_memory_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_memory_megabytes is missing from object`)

		return NewImageValueUnknown(), diags
	}

	minMemoryMegabytesVal, ok := minMemoryMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_memory_megabytes expected to be basetypes.Int64Value, was: %T`, minMemoryMegabytesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewImageValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	publicAttribute, ok := attributes["public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`public is missing from object`)

		return NewImageValueUnknown(), diags
	}

	publicVal, ok := publicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`public expected to be basetypes.BoolValue, was: %T`, publicAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return NewImageValueUnknown(), diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return NewImageValueUnknown(), diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewImageValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewImageValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.StringValue, was: %T`, statusAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewImageValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewImageValueUnknown(), diags
	}

	return ImageValue{
		BackupInfo:             backupInfoVal,
		CreatedAt:              createdAtVal,
		Description:            descriptionVal,
		Distribution:           distributionVal,
		DistributionInfo:       distributionInfoVal,
		DistributionSurcharges: distributionSurchargesVal,
		ErrorMessage:           errorMessageVal,
		FullName:               fullNameVal,
		Id:                     idVal,
		MinDiskSize:            minDiskSizeVal,
		MinMemoryMegabytes:     minMemoryMegabytesVal,
		Name:                   nameVal,
		Public:                 publicVal,
		Regions:                regionsVal,
		SizeGigabytes:          sizeGigabytesVal,
		Slug:                   slugVal,
		Status:                 statusVal,
		ImageType:              typeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewImageValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ImageValue {
	object, diags := NewImageValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewImageValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ImageType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewImageValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewImageValueUnknown(), nil
	}

	if in.IsNull() {
		return NewImageValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewImageValueMust(ImageValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ImageType) ValueType(ctx context.Context) attr.Value {
	return ImageValue{}
}

var _ basetypes.ObjectValuable = ImageValue{}

type ImageValue struct {
	BackupInfo             basetypes.ObjectValue  `tfsdk:"backup_info"`
	CreatedAt              basetypes.StringValue  `tfsdk:"created_at"`
	Description            basetypes.StringValue  `tfsdk:"description"`
	Distribution           basetypes.StringValue  `tfsdk:"distribution"`
	DistributionInfo       basetypes.ObjectValue  `tfsdk:"distribution_info"`
	DistributionSurcharges basetypes.ObjectValue  `tfsdk:"distribution_surcharges"`
	ErrorMessage           basetypes.StringValue  `tfsdk:"error_message"`
	FullName               basetypes.StringValue  `tfsdk:"full_name"`
	Id                     basetypes.Int64Value   `tfsdk:"id"`
	MinDiskSize            basetypes.Int64Value   `tfsdk:"min_disk_size"`
	MinMemoryMegabytes     basetypes.Int64Value   `tfsdk:"min_memory_megabytes"`
	Name                   basetypes.StringValue  `tfsdk:"name"`
	Public                 basetypes.BoolValue    `tfsdk:"public"`
	Regions                basetypes.ListValue    `tfsdk:"regions"`
	SizeGigabytes          basetypes.Float64Value `tfsdk:"size_gigabytes"`
	Slug                   basetypes.StringValue  `tfsdk:"slug"`
	Status                 basetypes.StringValue  `tfsdk:"status"`
	ImageType              basetypes.StringValue  `tfsdk:"type"`
	state                  attr.ValueState
}

func (v ImageValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["backup_info"] = basetypes.ObjectType{
		AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["created_at"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["distribution"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["distribution_info"] = basetypes.ObjectType{
		AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["distribution_surcharges"] = basetypes.ObjectType{
		AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["full_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_disk_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_memory_megabytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["public"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["regions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["size_gigabytes"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.BackupInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_info"] = val

		val, err = v.CreatedAt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created_at"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Distribution.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution"] = val

		val, err = v.DistributionInfo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution_info"] = val

		val, err = v.DistributionSurcharges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["distribution_surcharges"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.FullName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MinDiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_disk_size"] = val

		val, err = v.MinMemoryMegabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_memory_megabytes"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Public.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["public"] = val

		val, err = v.Regions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions"] = val

		val, err = v.SizeGigabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_gigabytes"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		val, err = v.ImageType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ImageValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ImageValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ImageValue) String() string {
	return "ImageValue"
}

func (v ImageValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var backupInfo basetypes.ObjectValue

	if v.BackupInfo.IsNull() {
		backupInfo = types.ObjectNull(
			BackupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.BackupInfo.IsUnknown() {
		backupInfo = types.ObjectUnknown(
			BackupInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.BackupInfo.IsNull() && !v.BackupInfo.IsUnknown() {
		backupInfo = types.ObjectValueMust(
			BackupInfoValue{}.AttributeTypes(ctx),
			v.BackupInfo.Attributes(),
		)
	}

	var distributionInfo basetypes.ObjectValue

	if v.DistributionInfo.IsNull() {
		distributionInfo = types.ObjectNull(
			DistributionInfoValue{}.AttributeTypes(ctx),
		)
	}

	if v.DistributionInfo.IsUnknown() {
		distributionInfo = types.ObjectUnknown(
			DistributionInfoValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DistributionInfo.IsNull() && !v.DistributionInfo.IsUnknown() {
		distributionInfo = types.ObjectValueMust(
			DistributionInfoValue{}.AttributeTypes(ctx),
			v.DistributionInfo.Attributes(),
		)
	}

	var distributionSurcharges basetypes.ObjectValue

	if v.DistributionSurcharges.IsNull() {
		distributionSurcharges = types.ObjectNull(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
		)
	}

	if v.DistributionSurcharges.IsUnknown() {
		distributionSurcharges = types.ObjectUnknown(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DistributionSurcharges.IsNull() && !v.DistributionSurcharges.IsUnknown() {
		distributionSurcharges = types.ObjectValueMust(
			DistributionSurchargesValue{}.AttributeTypes(ctx),
			v.DistributionSurcharges.Attributes(),
		)
	}

	regionsVal, d := types.ListValue(types.StringType, v.Regions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"backup_info": basetypes.ObjectType{
				AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
			},
			"created_at":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"distribution": basetypes.StringType{},
			"distribution_info": basetypes.ObjectType{
				AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
			},
			"distribution_surcharges": basetypes.ObjectType{
				AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
			},
			"error_message":        basetypes.StringType{},
			"full_name":            basetypes.StringType{},
			"id":                   basetypes.Int64Type{},
			"min_disk_size":        basetypes.Int64Type{},
			"min_memory_megabytes": basetypes.Int64Type{},
			"name":                 basetypes.StringType{},
			"public":               basetypes.BoolType{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_gigabytes": basetypes.Float64Type{},
			"slug":           basetypes.StringType{},
			"status":         basetypes.StringType{},
			"type":           basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"backup_info": basetypes.ObjectType{
			AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
		},
		"created_at":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"distribution": basetypes.StringType{},
		"distribution_info": basetypes.ObjectType{
			AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
		},
		"distribution_surcharges": basetypes.ObjectType{
			AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
		},
		"error_message":        basetypes.StringType{},
		"full_name":            basetypes.StringType{},
		"id":                   basetypes.Int64Type{},
		"min_disk_size":        basetypes.Int64Type{},
		"min_memory_megabytes": basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"public":               basetypes.BoolType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_gigabytes": basetypes.Float64Type{},
		"slug":           basetypes.StringType{},
		"status":         basetypes.StringType{},
		"type":           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_info":             backupInfo,
			"created_at":              v.CreatedAt,
			"description":             v.Description,
			"distribution":            v.Distribution,
			"distribution_info":       distributionInfo,
			"distribution_surcharges": distributionSurcharges,
			"error_message":           v.ErrorMessage,
			"full_name":               v.FullName,
			"id":                      v.Id,
			"min_disk_size":           v.MinDiskSize,
			"min_memory_megabytes":    v.MinMemoryMegabytes,
			"name":                    v.Name,
			"public":                  v.Public,
			"regions":                 regionsVal,
			"size_gigabytes":          v.SizeGigabytes,
			"slug":                    v.Slug,
			"status":                  v.Status,
			"type":                    v.ImageType,
		})

	return objVal, diags
}

func (v ImageValue) Equal(o attr.Value) bool {
	other, ok := o.(ImageValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupInfo.Equal(other.BackupInfo) {
		return false
	}

	if !v.CreatedAt.Equal(other.CreatedAt) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Distribution.Equal(other.Distribution) {
		return false
	}

	if !v.DistributionInfo.Equal(other.DistributionInfo) {
		return false
	}

	if !v.DistributionSurcharges.Equal(other.DistributionSurcharges) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.FullName.Equal(other.FullName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MinDiskSize.Equal(other.MinDiskSize) {
		return false
	}

	if !v.MinMemoryMegabytes.Equal(other.MinMemoryMegabytes) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Public.Equal(other.Public) {
		return false
	}

	if !v.Regions.Equal(other.Regions) {
		return false
	}

	if !v.SizeGigabytes.Equal(other.SizeGigabytes) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	if !v.ImageType.Equal(other.ImageType) {
		return false
	}

	return true
}

func (v ImageValue) Type(ctx context.Context) attr.Type {
	return ImageType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ImageValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_info": basetypes.ObjectType{
			AttrTypes: BackupInfoValue{}.AttributeTypes(ctx),
		},
		"created_at":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"distribution": basetypes.StringType{},
		"distribution_info": basetypes.ObjectType{
			AttrTypes: DistributionInfoValue{}.AttributeTypes(ctx),
		},
		"distribution_surcharges": basetypes.ObjectType{
			AttrTypes: DistributionSurchargesValue{}.AttributeTypes(ctx),
		},
		"error_message":        basetypes.StringType{},
		"full_name":            basetypes.StringType{},
		"id":                   basetypes.Int64Type{},
		"min_disk_size":        basetypes.Int64Type{},
		"min_memory_megabytes": basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"public":               basetypes.BoolType{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_gigabytes": basetypes.Float64Type{},
		"slug":           basetypes.StringType{},
		"status":         basetypes.StringType{},
		"type":           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BackupInfoType{}

type BackupInfoType struct {
	basetypes.ObjectType
}

func (t BackupInfoType) Equal(o attr.Type) bool {
	other, ok := o.(BackupInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BackupInfoType) String() string {
	return "BackupInfoType"
}

func (t BackupInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupDisksAttribute, ok := attributes["backup_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_disks is missing from object`)

		return nil, diags
	}

	backupDisksVal, ok := backupDisksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_disks expected to be basetypes.ListValue, was: %T`, backupDisksAttribute))
	}

	isoAttribute, ok := attributes["iso"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iso is missing from object`)

		return nil, diags
	}

	isoVal, ok := isoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iso expected to be basetypes.BoolValue, was: %T`, isoAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return nil, diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	offsiteAttribute, ok := attributes["offsite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite is missing from object`)

		return nil, diags
	}

	offsiteVal, ok := offsiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite expected to be basetypes.BoolValue, was: %T`, offsiteAttribute))
	}

	serverIdAttribute, ok := attributes["server_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id is missing from object`)

		return nil, diags
	}

	serverIdVal, ok := serverIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id expected to be basetypes.Int64Value, was: %T`, serverIdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BackupInfoValue{
		BackupDisks:    backupDisksVal,
		Iso:            isoVal,
		Locked:         lockedVal,
		Offsite:        offsiteVal,
		ServerId:       serverIdVal,
		BackupInfoType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewBackupInfoValueNull() BackupInfoValue {
	return BackupInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewBackupInfoValueUnknown() BackupInfoValue {
	return BackupInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBackupInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BackupInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BackupInfoValue Attribute Value",
				"While creating a BackupInfoValue value, a missing attribute value was detected. "+
					"A BackupInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BackupInfoValue Attribute Type",
				"While creating a BackupInfoValue value, an invalid attribute value was detected. "+
					"A BackupInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BackupInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BackupInfoValue Attribute Value",
				"While creating a BackupInfoValue value, an extra attribute value was detected. "+
					"A BackupInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BackupInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBackupInfoValueUnknown(), diags
	}

	backupDisksAttribute, ok := attributes["backup_disks"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backup_disks is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	backupDisksVal, ok := backupDisksAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backup_disks expected to be basetypes.ListValue, was: %T`, backupDisksAttribute))
	}

	isoAttribute, ok := attributes["iso"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`iso is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	isoVal, ok := isoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`iso expected to be basetypes.BoolValue, was: %T`, isoAttribute))
	}

	lockedAttribute, ok := attributes["locked"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`locked is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	lockedVal, ok := lockedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`locked expected to be basetypes.BoolValue, was: %T`, lockedAttribute))
	}

	offsiteAttribute, ok := attributes["offsite"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	offsiteVal, ok := offsiteAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite expected to be basetypes.BoolValue, was: %T`, offsiteAttribute))
	}

	serverIdAttribute, ok := attributes["server_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`server_id is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	serverIdVal, ok := serverIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`server_id expected to be basetypes.Int64Value, was: %T`, serverIdAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewBackupInfoValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewBackupInfoValueUnknown(), diags
	}

	return BackupInfoValue{
		BackupDisks:    backupDisksVal,
		Iso:            isoVal,
		Locked:         lockedVal,
		Offsite:        offsiteVal,
		ServerId:       serverIdVal,
		BackupInfoType: typeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewBackupInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BackupInfoValue {
	object, diags := NewBackupInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBackupInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BackupInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBackupInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBackupInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBackupInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBackupInfoValueMust(BackupInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BackupInfoType) ValueType(ctx context.Context) attr.Value {
	return BackupInfoValue{}
}

var _ basetypes.ObjectValuable = BackupInfoValue{}

type BackupInfoValue struct {
	BackupDisks    basetypes.ListValue   `tfsdk:"backup_disks"`
	Iso            basetypes.BoolValue   `tfsdk:"iso"`
	Locked         basetypes.BoolValue   `tfsdk:"locked"`
	Offsite        basetypes.BoolValue   `tfsdk:"offsite"`
	ServerId       basetypes.Int64Value  `tfsdk:"server_id"`
	BackupInfoType basetypes.StringValue `tfsdk:"type"`
	state          attr.ValueState
}

func (v BackupInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["backup_disks"] = basetypes.ListType{
		ElemType: BackupDisksValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["iso"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["locked"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["offsite"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["server_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.BackupDisks.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backup_disks"] = val

		val, err = v.Iso.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["iso"] = val

		val, err = v.Locked.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["locked"] = val

		val, err = v.Offsite.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite"] = val

		val, err = v.ServerId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["server_id"] = val

		val, err = v.BackupInfoType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BackupInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BackupInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BackupInfoValue) String() string {
	return "BackupInfoValue"
}

func (v BackupInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	backupDisks := types.ListValueMust(
		BackupDisksType{
			basetypes.ObjectType{
				AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
			},
		},
		v.BackupDisks.Elements(),
	)

	if v.BackupDisks.IsNull() {
		backupDisks = types.ListNull(
			BackupDisksType{
				basetypes.ObjectType{
					AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BackupDisks.IsUnknown() {
		backupDisks = types.ListUnknown(
			BackupDisksType{
				basetypes.ObjectType{
					AttrTypes: BackupDisksValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"backup_disks": basetypes.ListType{
			ElemType: BackupDisksValue{}.Type(ctx),
		},
		"iso":       basetypes.BoolType{},
		"locked":    basetypes.BoolType{},
		"offsite":   basetypes.BoolType{},
		"server_id": basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backup_disks": backupDisks,
			"iso":          v.Iso,
			"locked":       v.Locked,
			"offsite":      v.Offsite,
			"server_id":    v.ServerId,
			"type":         v.BackupInfoType,
		})

	return objVal, diags
}

func (v BackupInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(BackupInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupDisks.Equal(other.BackupDisks) {
		return false
	}

	if !v.Iso.Equal(other.Iso) {
		return false
	}

	if !v.Locked.Equal(other.Locked) {
		return false
	}

	if !v.Offsite.Equal(other.Offsite) {
		return false
	}

	if !v.ServerId.Equal(other.ServerId) {
		return false
	}

	if !v.BackupInfoType.Equal(other.BackupInfoType) {
		return false
	}

	return true
}

func (v BackupInfoValue) Type(ctx context.Context) attr.Type {
	return BackupInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BackupInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backup_disks": basetypes.ListType{
			ElemType: BackupDisksValue{}.Type(ctx),
		},
		"iso":       basetypes.BoolType{},
		"locked":    basetypes.BoolType{},
		"offsite":   basetypes.BoolType{},
		"server_id": basetypes.Int64Type{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BackupDisksType{}

type BackupDisksType struct {
	basetypes.ObjectType
}

func (t BackupDisksType) Equal(o attr.Type) bool {
	other, ok := o.(BackupDisksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BackupDisksType) String() string {
	return "BackupDisksType"
}

func (t BackupDisksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return nil, diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return nil, diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BackupDisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		MinDiskSize:   minDiskSizeVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBackupDisksValueNull() BackupDisksValue {
	return BackupDisksValue{
		state: attr.ValueStateNull,
	}
}

func NewBackupDisksValueUnknown() BackupDisksValue {
	return BackupDisksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBackupDisksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BackupDisksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BackupDisksValue Attribute Value",
				"While creating a BackupDisksValue value, a missing attribute value was detected. "+
					"A BackupDisksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BackupDisksValue Attribute Type",
				"While creating a BackupDisksValue value, an invalid attribute value was detected. "+
					"A BackupDisksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BackupDisksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BackupDisksValue Attribute Value",
				"While creating a BackupDisksValue value, an extra attribute value was detected. "+
					"A BackupDisksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BackupDisksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBackupDisksValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	minDiskSizeAttribute, ok := attributes["min_disk_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_disk_size is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	minDiskSizeVal, ok := minDiskSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_disk_size expected to be basetypes.Int64Value, was: %T`, minDiskSizeAttribute))
	}

	sizeGigabytesAttribute, ok := attributes["size_gigabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_gigabytes is missing from object`)

		return NewBackupDisksValueUnknown(), diags
	}

	sizeGigabytesVal, ok := sizeGigabytesAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_gigabytes expected to be basetypes.Float64Value, was: %T`, sizeGigabytesAttribute))
	}

	if diags.HasError() {
		return NewBackupDisksValueUnknown(), diags
	}

	return BackupDisksValue{
		Description:   descriptionVal,
		Id:            idVal,
		MinDiskSize:   minDiskSizeVal,
		SizeGigabytes: sizeGigabytesVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBackupDisksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BackupDisksValue {
	object, diags := NewBackupDisksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBackupDisksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BackupDisksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBackupDisksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBackupDisksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBackupDisksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBackupDisksValueMust(BackupDisksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BackupDisksType) ValueType(ctx context.Context) attr.Value {
	return BackupDisksValue{}
}

var _ basetypes.ObjectValuable = BackupDisksValue{}

type BackupDisksValue struct {
	Description   basetypes.StringValue  `tfsdk:"description"`
	Id            basetypes.Int64Value   `tfsdk:"id"`
	MinDiskSize   basetypes.Int64Value   `tfsdk:"min_disk_size"`
	SizeGigabytes basetypes.Float64Value `tfsdk:"size_gigabytes"`
	state         attr.ValueState
}

func (v BackupDisksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_disk_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size_gigabytes"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.MinDiskSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_disk_size"] = val

		val, err = v.SizeGigabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_gigabytes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BackupDisksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BackupDisksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BackupDisksValue) String() string {
	return "BackupDisksValue"
}

func (v BackupDisksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"min_disk_size":  basetypes.Int64Type{},
		"size_gigabytes": basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":    v.Description,
			"id":             v.Id,
			"min_disk_size":  v.MinDiskSize,
			"size_gigabytes": v.SizeGigabytes,
		})

	return objVal, diags
}

func (v BackupDisksValue) Equal(o attr.Value) bool {
	other, ok := o.(BackupDisksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.MinDiskSize.Equal(other.MinDiskSize) {
		return false
	}

	if !v.SizeGigabytes.Equal(other.SizeGigabytes) {
		return false
	}

	return true
}

func (v BackupDisksValue) Type(ctx context.Context) attr.Type {
	return BackupDisksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BackupDisksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":    basetypes.StringType{},
		"id":             basetypes.Int64Type{},
		"min_disk_size":  basetypes.Int64Type{},
		"size_gigabytes": basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = DistributionInfoType{}

type DistributionInfoType struct {
	basetypes.ObjectType
}

func (t DistributionInfoType) Equal(o attr.Type) bool {
	other, ok := o.(DistributionInfoType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DistributionInfoType) String() string {
	return "DistributionInfoType"
}

func (t DistributionInfoType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return nil, diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.Int64Value, was: %T`, imageIdAttribute))
	}

	passwordRecoveryAttribute, ok := attributes["password_recovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_recovery is missing from object`)

		return nil, diags
	}

	passwordRecoveryVal, ok := passwordRecoveryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_recovery expected to be basetypes.StringValue, was: %T`, passwordRecoveryAttribute))
	}

	remoteAccessUserAttribute, ok := attributes["remote_access_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_access_user is missing from object`)

		return nil, diags
	}

	remoteAccessUserVal, ok := remoteAccessUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_access_user expected to be basetypes.StringValue, was: %T`, remoteAccessUserAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DistributionInfoValue{
		Features:         featuresVal,
		ImageId:          imageIdVal,
		PasswordRecovery: passwordRecoveryVal,
		RemoteAccessUser: remoteAccessUserVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDistributionInfoValueNull() DistributionInfoValue {
	return DistributionInfoValue{
		state: attr.ValueStateNull,
	}
}

func NewDistributionInfoValueUnknown() DistributionInfoValue {
	return DistributionInfoValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDistributionInfoValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DistributionInfoValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DistributionInfoValue Attribute Value",
				"While creating a DistributionInfoValue value, a missing attribute value was detected. "+
					"A DistributionInfoValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DistributionInfoValue Attribute Type",
				"While creating a DistributionInfoValue value, an invalid attribute value was detected. "+
					"A DistributionInfoValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DistributionInfoValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DistributionInfoValue Attribute Value",
				"While creating a DistributionInfoValue value, an extra attribute value was detected. "+
					"A DistributionInfoValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DistributionInfoValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDistributionInfoValueUnknown(), diags
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	imageIdAttribute, ok := attributes["image_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_id is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	imageIdVal, ok := imageIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_id expected to be basetypes.Int64Value, was: %T`, imageIdAttribute))
	}

	passwordRecoveryAttribute, ok := attributes["password_recovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`password_recovery is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	passwordRecoveryVal, ok := passwordRecoveryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`password_recovery expected to be basetypes.StringValue, was: %T`, passwordRecoveryAttribute))
	}

	remoteAccessUserAttribute, ok := attributes["remote_access_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_access_user is missing from object`)

		return NewDistributionInfoValueUnknown(), diags
	}

	remoteAccessUserVal, ok := remoteAccessUserAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_access_user expected to be basetypes.StringValue, was: %T`, remoteAccessUserAttribute))
	}

	if diags.HasError() {
		return NewDistributionInfoValueUnknown(), diags
	}

	return DistributionInfoValue{
		Features:         featuresVal,
		ImageId:          imageIdVal,
		PasswordRecovery: passwordRecoveryVal,
		RemoteAccessUser: remoteAccessUserVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewDistributionInfoValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DistributionInfoValue {
	object, diags := NewDistributionInfoValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDistributionInfoValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DistributionInfoType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDistributionInfoValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDistributionInfoValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDistributionInfoValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDistributionInfoValueMust(DistributionInfoValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DistributionInfoType) ValueType(ctx context.Context) attr.Value {
	return DistributionInfoValue{}
}

var _ basetypes.ObjectValuable = DistributionInfoValue{}

type DistributionInfoValue struct {
	Features         basetypes.ListValue   `tfsdk:"features"`
	ImageId          basetypes.Int64Value  `tfsdk:"image_id"`
	PasswordRecovery basetypes.StringValue `tfsdk:"password_recovery"`
	RemoteAccessUser basetypes.StringValue `tfsdk:"remote_access_user"`
	state            attr.ValueState
}

func (v DistributionInfoValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["features"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["image_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["password_recovery"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_access_user"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.ImageId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_id"] = val

		val, err = v.PasswordRecovery.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["password_recovery"] = val

		val, err = v.RemoteAccessUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_access_user"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DistributionInfoValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DistributionInfoValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DistributionInfoValue) String() string {
	return "DistributionInfoValue"
}

func (v DistributionInfoValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	featuresVal, d := types.ListValue(types.StringType, v.Features.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"image_id":           basetypes.Int64Type{},
			"password_recovery":  basetypes.StringType{},
			"remote_access_user": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"image_id":           basetypes.Int64Type{},
		"password_recovery":  basetypes.StringType{},
		"remote_access_user": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"features":           featuresVal,
			"image_id":           v.ImageId,
			"password_recovery":  v.PasswordRecovery,
			"remote_access_user": v.RemoteAccessUser,
		})

	return objVal, diags
}

func (v DistributionInfoValue) Equal(o attr.Value) bool {
	other, ok := o.(DistributionInfoValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.ImageId.Equal(other.ImageId) {
		return false
	}

	if !v.PasswordRecovery.Equal(other.PasswordRecovery) {
		return false
	}

	if !v.RemoteAccessUser.Equal(other.RemoteAccessUser) {
		return false
	}

	return true
}

func (v DistributionInfoValue) Type(ctx context.Context) attr.Type {
	return DistributionInfoType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DistributionInfoValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"image_id":           basetypes.Int64Type{},
		"password_recovery":  basetypes.StringType{},
		"remote_access_user": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DistributionSurchargesType{}

type DistributionSurchargesType struct {
	basetypes.ObjectType
}

func (t DistributionSurchargesType) Equal(o attr.Type) bool {
	other, ok := o.(DistributionSurchargesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DistributionSurchargesType) String() string {
	return "DistributionSurchargesType"
}

func (t DistributionSurchargesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	surchargeBaseCostAttribute, ok := attributes["surcharge_base_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_base_cost is missing from object`)

		return nil, diags
	}

	surchargeBaseCostVal, ok := surchargeBaseCostAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_base_cost expected to be basetypes.Float64Value, was: %T`, surchargeBaseCostAttribute))
	}

	surchargeMinVcpuAttribute, ok := attributes["surcharge_min_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_min_vcpu is missing from object`)

		return nil, diags
	}

	surchargeMinVcpuVal, ok := surchargeMinVcpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_min_vcpu expected to be basetypes.Int64Value, was: %T`, surchargeMinVcpuAttribute))
	}

	surchargePerMemoryMaxMegabytesAttribute, ok := attributes["surcharge_per_memory_max_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_max_megabytes is missing from object`)

		return nil, diags
	}

	surchargePerMemoryMaxMegabytesVal, ok := surchargePerMemoryMaxMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_max_megabytes expected to be basetypes.Int64Value, was: %T`, surchargePerMemoryMaxMegabytesAttribute))
	}

	surchargePerMemoryMegabyteAttribute, ok := attributes["surcharge_per_memory_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_megabyte is missing from object`)

		return nil, diags
	}

	surchargePerMemoryMegabyteVal, ok := surchargePerMemoryMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_megabyte expected to be basetypes.Float64Value, was: %T`, surchargePerMemoryMegabyteAttribute))
	}

	surchargePerVcpuAttribute, ok := attributes["surcharge_per_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_vcpu is missing from object`)

		return nil, diags
	}

	surchargePerVcpuVal, ok := surchargePerVcpuAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_vcpu expected to be basetypes.Float64Value, was: %T`, surchargePerVcpuAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DistributionSurchargesValue{
		SurchargeBaseCost:              surchargeBaseCostVal,
		SurchargeMinVcpu:               surchargeMinVcpuVal,
		SurchargePerMemoryMaxMegabytes: surchargePerMemoryMaxMegabytesVal,
		SurchargePerMemoryMegabyte:     surchargePerMemoryMegabyteVal,
		SurchargePerVcpu:               surchargePerVcpuVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewDistributionSurchargesValueNull() DistributionSurchargesValue {
	return DistributionSurchargesValue{
		state: attr.ValueStateNull,
	}
}

func NewDistributionSurchargesValueUnknown() DistributionSurchargesValue {
	return DistributionSurchargesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDistributionSurchargesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DistributionSurchargesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DistributionSurchargesValue Attribute Value",
				"While creating a DistributionSurchargesValue value, a missing attribute value was detected. "+
					"A DistributionSurchargesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DistributionSurchargesValue Attribute Type",
				"While creating a DistributionSurchargesValue value, an invalid attribute value was detected. "+
					"A DistributionSurchargesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DistributionSurchargesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DistributionSurchargesValue Attribute Value",
				"While creating a DistributionSurchargesValue value, an extra attribute value was detected. "+
					"A DistributionSurchargesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DistributionSurchargesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeBaseCostAttribute, ok := attributes["surcharge_base_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_base_cost is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeBaseCostVal, ok := surchargeBaseCostAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_base_cost expected to be basetypes.Float64Value, was: %T`, surchargeBaseCostAttribute))
	}

	surchargeMinVcpuAttribute, ok := attributes["surcharge_min_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_min_vcpu is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargeMinVcpuVal, ok := surchargeMinVcpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_min_vcpu expected to be basetypes.Int64Value, was: %T`, surchargeMinVcpuAttribute))
	}

	surchargePerMemoryMaxMegabytesAttribute, ok := attributes["surcharge_per_memory_max_megabytes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_max_megabytes is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerMemoryMaxMegabytesVal, ok := surchargePerMemoryMaxMegabytesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_max_megabytes expected to be basetypes.Int64Value, was: %T`, surchargePerMemoryMaxMegabytesAttribute))
	}

	surchargePerMemoryMegabyteAttribute, ok := attributes["surcharge_per_memory_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_memory_megabyte is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerMemoryMegabyteVal, ok := surchargePerMemoryMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_memory_megabyte expected to be basetypes.Float64Value, was: %T`, surchargePerMemoryMegabyteAttribute))
	}

	surchargePerVcpuAttribute, ok := attributes["surcharge_per_vcpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`surcharge_per_vcpu is missing from object`)

		return NewDistributionSurchargesValueUnknown(), diags
	}

	surchargePerVcpuVal, ok := surchargePerVcpuAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`surcharge_per_vcpu expected to be basetypes.Float64Value, was: %T`, surchargePerVcpuAttribute))
	}

	if diags.HasError() {
		return NewDistributionSurchargesValueUnknown(), diags
	}

	return DistributionSurchargesValue{
		SurchargeBaseCost:              surchargeBaseCostVal,
		SurchargeMinVcpu:               surchargeMinVcpuVal,
		SurchargePerMemoryMaxMegabytes: surchargePerMemoryMaxMegabytesVal,
		SurchargePerMemoryMegabyte:     surchargePerMemoryMegabyteVal,
		SurchargePerVcpu:               surchargePerVcpuVal,
		state:                          attr.ValueStateKnown,
	}, diags
}

func NewDistributionSurchargesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DistributionSurchargesValue {
	object, diags := NewDistributionSurchargesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDistributionSurchargesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DistributionSurchargesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDistributionSurchargesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDistributionSurchargesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDistributionSurchargesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDistributionSurchargesValueMust(DistributionSurchargesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DistributionSurchargesType) ValueType(ctx context.Context) attr.Value {
	return DistributionSurchargesValue{}
}

var _ basetypes.ObjectValuable = DistributionSurchargesValue{}

type DistributionSurchargesValue struct {
	SurchargeBaseCost              basetypes.Float64Value `tfsdk:"surcharge_base_cost"`
	SurchargeMinVcpu               basetypes.Int64Value   `tfsdk:"surcharge_min_vcpu"`
	SurchargePerMemoryMaxMegabytes basetypes.Int64Value   `tfsdk:"surcharge_per_memory_max_megabytes"`
	SurchargePerMemoryMegabyte     basetypes.Float64Value `tfsdk:"surcharge_per_memory_megabyte"`
	SurchargePerVcpu               basetypes.Float64Value `tfsdk:"surcharge_per_vcpu"`
	state                          attr.ValueState
}

func (v DistributionSurchargesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["surcharge_base_cost"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["surcharge_min_vcpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_memory_max_megabytes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_memory_megabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["surcharge_per_vcpu"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.SurchargeBaseCost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_base_cost"] = val

		val, err = v.SurchargeMinVcpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_min_vcpu"] = val

		val, err = v.SurchargePerMemoryMaxMegabytes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_memory_max_megabytes"] = val

		val, err = v.SurchargePerMemoryMegabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_memory_megabyte"] = val

		val, err = v.SurchargePerVcpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["surcharge_per_vcpu"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DistributionSurchargesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DistributionSurchargesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DistributionSurchargesValue) String() string {
	return "DistributionSurchargesValue"
}

func (v DistributionSurchargesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"surcharge_base_cost":                basetypes.Float64Type{},
		"surcharge_min_vcpu":                 basetypes.Int64Type{},
		"surcharge_per_memory_max_megabytes": basetypes.Int64Type{},
		"surcharge_per_memory_megabyte":      basetypes.Float64Type{},
		"surcharge_per_vcpu":                 basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"surcharge_base_cost":                v.SurchargeBaseCost,
			"surcharge_min_vcpu":                 v.SurchargeMinVcpu,
			"surcharge_per_memory_max_megabytes": v.SurchargePerMemoryMaxMegabytes,
			"surcharge_per_memory_megabyte":      v.SurchargePerMemoryMegabyte,
			"surcharge_per_vcpu":                 v.SurchargePerVcpu,
		})

	return objVal, diags
}

func (v DistributionSurchargesValue) Equal(o attr.Value) bool {
	other, ok := o.(DistributionSurchargesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.SurchargeBaseCost.Equal(other.SurchargeBaseCost) {
		return false
	}

	if !v.SurchargeMinVcpu.Equal(other.SurchargeMinVcpu) {
		return false
	}

	if !v.SurchargePerMemoryMaxMegabytes.Equal(other.SurchargePerMemoryMaxMegabytes) {
		return false
	}

	if !v.SurchargePerMemoryMegabyte.Equal(other.SurchargePerMemoryMegabyte) {
		return false
	}

	if !v.SurchargePerVcpu.Equal(other.SurchargePerVcpu) {
		return false
	}

	return true
}

func (v DistributionSurchargesValue) Type(ctx context.Context) attr.Type {
	return DistributionSurchargesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DistributionSurchargesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"surcharge_base_cost":                basetypes.Float64Type{},
		"surcharge_min_vcpu":                 basetypes.Int64Type{},
		"surcharge_per_memory_max_megabytes": basetypes.Int64Type{},
		"surcharge_per_memory_megabyte":      basetypes.Float64Type{},
		"surcharge_per_vcpu":                 basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = KernelType{}

type KernelType struct {
	basetypes.ObjectType
}

func (t KernelType) Equal(o attr.Type) bool {
	other, ok := o.(KernelType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t KernelType) String() string {
	return "KernelType"
}

func (t KernelType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return KernelValue{
		Id:      idVal,
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewKernelValueNull() KernelValue {
	return KernelValue{
		state: attr.ValueStateNull,
	}
}

func NewKernelValueUnknown() KernelValue {
	return KernelValue{
		state: attr.ValueStateUnknown,
	}
}

func NewKernelValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (KernelValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing KernelValue Attribute Value",
				"While creating a KernelValue value, a missing attribute value was detected. "+
					"A KernelValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KernelValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid KernelValue Attribute Type",
				"While creating a KernelValue value, an invalid attribute value was detected. "+
					"A KernelValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("KernelValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("KernelValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra KernelValue Attribute Value",
				"While creating a KernelValue value, an extra attribute value was detected. "+
					"A KernelValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra KernelValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewKernelValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewKernelValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewKernelValueUnknown(), diags
	}

	return KernelValue{
		Id:      idVal,
		Name:    nameVal,
		Version: versionVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewKernelValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) KernelValue {
	object, diags := NewKernelValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewKernelValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t KernelType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewKernelValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewKernelValueUnknown(), nil
	}

	if in.IsNull() {
		return NewKernelValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewKernelValueMust(KernelValue{}.AttributeTypes(ctx), attributes), nil
}

func (t KernelType) ValueType(ctx context.Context) attr.Value {
	return KernelValue{}
}

var _ basetypes.ObjectValuable = KernelValue{}

type KernelValue struct {
	Id      basetypes.Int64Value  `tfsdk:"id"`
	Name    basetypes.StringValue `tfsdk:"name"`
	Version basetypes.StringValue `tfsdk:"version"`
	state   attr.ValueState
}

func (v KernelValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v KernelValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v KernelValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v KernelValue) String() string {
	return "KernelValue"
}

func (v KernelValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"id":      basetypes.Int64Type{},
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":      v.Id,
			"name":    v.Name,
			"version": v.Version,
		})

	return objVal, diags
}

func (v KernelValue) Equal(o attr.Value) bool {
	other, ok := o.(KernelValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v KernelValue) Type(ctx context.Context) attr.Type {
	return KernelType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v KernelValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":      basetypes.Int64Type{},
		"name":    basetypes.StringType{},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworksType{}

type NetworksType struct {
	basetypes.ObjectType
}

func (t NetworksType) Equal(o attr.Type) bool {
	other, ok := o.(NetworksType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworksType) String() string {
	return "NetworksType"
}

func (t NetworksType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv6ReverseNameserversAttribute, ok := attributes["ipv6_reverse_nameservers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_reverse_nameservers is missing from object`)

		return nil, diags
	}

	ipv6ReverseNameserversVal, ok := ipv6ReverseNameserversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_reverse_nameservers expected to be basetypes.ListValue, was: %T`, ipv6ReverseNameserversAttribute))
	}

	portBlockingAttribute, ok := attributes["port_blocking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_blocking is missing from object`)

		return nil, diags
	}

	portBlockingVal, ok := portBlockingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_blocking expected to be basetypes.BoolValue, was: %T`, portBlockingAttribute))
	}

	recentDdosAttribute, ok := attributes["recent_ddos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recent_ddos is missing from object`)

		return nil, diags
	}

	recentDdosVal, ok := recentDdosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recent_ddos expected to be basetypes.BoolValue, was: %T`, recentDdosAttribute))
	}

	separatePrivateNetworkInterfaceAttribute, ok := attributes["separate_private_network_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`separate_private_network_interface is missing from object`)

		return nil, diags
	}

	separatePrivateNetworkInterfaceVal, ok := separatePrivateNetworkInterfaceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`separate_private_network_interface expected to be basetypes.BoolValue, was: %T`, separatePrivateNetworkInterfaceAttribute))
	}

	sourceAndDestinationCheckAttribute, ok := attributes["source_and_destination_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_and_destination_check is missing from object`)

		return nil, diags
	}

	sourceAndDestinationCheckVal, ok := sourceAndDestinationCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_and_destination_check expected to be basetypes.BoolValue, was: %T`, sourceAndDestinationCheckAttribute))
	}

	v4Attribute, ok := attributes["v4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v4 is missing from object`)

		return nil, diags
	}

	v4Val, ok := v4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v4 expected to be basetypes.ListValue, was: %T`, v4Attribute))
	}

	v6Attribute, ok := attributes["v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v6 is missing from object`)

		return nil, diags
	}

	v6Val, ok := v6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v6 expected to be basetypes.ListValue, was: %T`, v6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworksValue{
		Ipv6ReverseNameservers:          ipv6ReverseNameserversVal,
		PortBlocking:                    portBlockingVal,
		RecentDdos:                      recentDdosVal,
		SeparatePrivateNetworkInterface: separatePrivateNetworkInterfaceVal,
		SourceAndDestinationCheck:       sourceAndDestinationCheckVal,
		V4:                              v4Val,
		V6:                              v6Val,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueNull() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworksValueUnknown() NetworksValue {
	return NetworksValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworksValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworksValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworksValue Attribute Value",
				"While creating a NetworksValue value, a missing attribute value was detected. "+
					"A NetworksValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworksValue Attribute Type",
				"While creating a NetworksValue value, an invalid attribute value was detected. "+
					"A NetworksValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworksValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworksValue Attribute Value",
				"While creating a NetworksValue value, an extra attribute value was detected. "+
					"A NetworksValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworksValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	ipv6ReverseNameserversAttribute, ok := attributes["ipv6_reverse_nameservers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_reverse_nameservers is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	ipv6ReverseNameserversVal, ok := ipv6ReverseNameserversAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_reverse_nameservers expected to be basetypes.ListValue, was: %T`, ipv6ReverseNameserversAttribute))
	}

	portBlockingAttribute, ok := attributes["port_blocking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_blocking is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	portBlockingVal, ok := portBlockingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_blocking expected to be basetypes.BoolValue, was: %T`, portBlockingAttribute))
	}

	recentDdosAttribute, ok := attributes["recent_ddos"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recent_ddos is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	recentDdosVal, ok := recentDdosAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recent_ddos expected to be basetypes.BoolValue, was: %T`, recentDdosAttribute))
	}

	separatePrivateNetworkInterfaceAttribute, ok := attributes["separate_private_network_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`separate_private_network_interface is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	separatePrivateNetworkInterfaceVal, ok := separatePrivateNetworkInterfaceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`separate_private_network_interface expected to be basetypes.BoolValue, was: %T`, separatePrivateNetworkInterfaceAttribute))
	}

	sourceAndDestinationCheckAttribute, ok := attributes["source_and_destination_check"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_and_destination_check is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	sourceAndDestinationCheckVal, ok := sourceAndDestinationCheckAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_and_destination_check expected to be basetypes.BoolValue, was: %T`, sourceAndDestinationCheckAttribute))
	}

	v4Attribute, ok := attributes["v4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v4 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	v4Val, ok := v4Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v4 expected to be basetypes.ListValue, was: %T`, v4Attribute))
	}

	v6Attribute, ok := attributes["v6"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`v6 is missing from object`)

		return NewNetworksValueUnknown(), diags
	}

	v6Val, ok := v6Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`v6 expected to be basetypes.ListValue, was: %T`, v6Attribute))
	}

	if diags.HasError() {
		return NewNetworksValueUnknown(), diags
	}

	return NetworksValue{
		Ipv6ReverseNameservers:          ipv6ReverseNameserversVal,
		PortBlocking:                    portBlockingVal,
		RecentDdos:                      recentDdosVal,
		SeparatePrivateNetworkInterface: separatePrivateNetworkInterfaceVal,
		SourceAndDestinationCheck:       sourceAndDestinationCheckVal,
		V4:                              v4Val,
		V6:                              v6Val,
		state:                           attr.ValueStateKnown,
	}, diags
}

func NewNetworksValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworksValue {
	object, diags := NewNetworksValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworksValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworksType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworksValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworksValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworksValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworksValueMust(NetworksValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworksType) ValueType(ctx context.Context) attr.Value {
	return NetworksValue{}
}

var _ basetypes.ObjectValuable = NetworksValue{}

type NetworksValue struct {
	Ipv6ReverseNameservers          basetypes.ListValue `tfsdk:"ipv6_reverse_nameservers"`
	PortBlocking                    basetypes.BoolValue `tfsdk:"port_blocking"`
	RecentDdos                      basetypes.BoolValue `tfsdk:"recent_ddos"`
	SeparatePrivateNetworkInterface basetypes.BoolValue `tfsdk:"separate_private_network_interface"`
	SourceAndDestinationCheck       basetypes.BoolValue `tfsdk:"source_and_destination_check"`
	V4                              basetypes.ListValue `tfsdk:"v4"`
	V6                              basetypes.ListValue `tfsdk:"v6"`
	state                           attr.ValueState
}

func (v NetworksValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["ipv6_reverse_nameservers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["port_blocking"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["recent_ddos"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["separate_private_network_interface"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_and_destination_check"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["v4"] = basetypes.ListType{
		ElemType: V4Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["v6"] = basetypes.ListType{
		ElemType: V6Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Ipv6ReverseNameservers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_reverse_nameservers"] = val

		val, err = v.PortBlocking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_blocking"] = val

		val, err = v.RecentDdos.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recent_ddos"] = val

		val, err = v.SeparatePrivateNetworkInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["separate_private_network_interface"] = val

		val, err = v.SourceAndDestinationCheck.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_and_destination_check"] = val

		val, err = v.V4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v4"] = val

		val, err = v.V6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["v6"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworksValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworksValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworksValue) String() string {
	return "NetworksValue"
}

func (v NetworksValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	v4 := types.ListValueMust(
		V4Type{
			basetypes.ObjectType{
				AttrTypes: V4Value{}.AttributeTypes(ctx),
			},
		},
		v.V4.Elements(),
	)

	if v.V4.IsNull() {
		v4 = types.ListNull(
			V4Type{
				basetypes.ObjectType{
					AttrTypes: V4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.V4.IsUnknown() {
		v4 = types.ListUnknown(
			V4Type{
				basetypes.ObjectType{
					AttrTypes: V4Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	v6 := types.ListValueMust(
		V6Type{
			basetypes.ObjectType{
				AttrTypes: V6Value{}.AttributeTypes(ctx),
			},
		},
		v.V6.Elements(),
	)

	if v.V6.IsNull() {
		v6 = types.ListNull(
			V6Type{
				basetypes.ObjectType{
					AttrTypes: V6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.V6.IsUnknown() {
		v6 = types.ListUnknown(
			V6Type{
				basetypes.ObjectType{
					AttrTypes: V6Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ipv6ReverseNameserversVal, d := types.ListValue(types.StringType, v.Ipv6ReverseNameservers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"ipv6_reverse_nameservers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"port_blocking":                      basetypes.BoolType{},
			"recent_ddos":                        basetypes.BoolType{},
			"separate_private_network_interface": basetypes.BoolType{},
			"source_and_destination_check":       basetypes.BoolType{},
			"v4": basetypes.ListType{
				ElemType: V4Value{}.Type(ctx),
			},
			"v6": basetypes.ListType{
				ElemType: V6Value{}.Type(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"ipv6_reverse_nameservers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port_blocking":                      basetypes.BoolType{},
		"recent_ddos":                        basetypes.BoolType{},
		"separate_private_network_interface": basetypes.BoolType{},
		"source_and_destination_check":       basetypes.BoolType{},
		"v4": basetypes.ListType{
			ElemType: V4Value{}.Type(ctx),
		},
		"v6": basetypes.ListType{
			ElemType: V6Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ipv6_reverse_nameservers":           ipv6ReverseNameserversVal,
			"port_blocking":                      v.PortBlocking,
			"recent_ddos":                        v.RecentDdos,
			"separate_private_network_interface": v.SeparatePrivateNetworkInterface,
			"source_and_destination_check":       v.SourceAndDestinationCheck,
			"v4":                                 v4,
			"v6":                                 v6,
		})

	return objVal, diags
}

func (v NetworksValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworksValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv6ReverseNameservers.Equal(other.Ipv6ReverseNameservers) {
		return false
	}

	if !v.PortBlocking.Equal(other.PortBlocking) {
		return false
	}

	if !v.RecentDdos.Equal(other.RecentDdos) {
		return false
	}

	if !v.SeparatePrivateNetworkInterface.Equal(other.SeparatePrivateNetworkInterface) {
		return false
	}

	if !v.SourceAndDestinationCheck.Equal(other.SourceAndDestinationCheck) {
		return false
	}

	if !v.V4.Equal(other.V4) {
		return false
	}

	if !v.V6.Equal(other.V6) {
		return false
	}

	return true
}

func (v NetworksValue) Type(ctx context.Context) attr.Type {
	return NetworksType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworksValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv6_reverse_nameservers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"port_blocking":                      basetypes.BoolType{},
		"recent_ddos":                        basetypes.BoolType{},
		"separate_private_network_interface": basetypes.BoolType{},
		"source_and_destination_check":       basetypes.BoolType{},
		"v4": basetypes.ListType{
			ElemType: V4Value{}.Type(ctx),
		},
		"v6": basetypes.ListType{
			ElemType: V6Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = V4Type{}

type V4Type struct {
	basetypes.ObjectType
}

func (t V4Type) Equal(o attr.Type) bool {
	other, ok := o.(V4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V4Type) String() string {
	return "V4Type"
}

func (t V4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natTargetAttribute, ok := attributes["nat_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_target is missing from object`)

		return nil, diags
	}

	natTargetVal, ok := natTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_target expected to be basetypes.StringValue, was: %T`, natTargetAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	reverseNameAttribute, ok := attributes["reverse_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reverse_name is missing from object`)

		return nil, diags
	}

	reverseNameVal, ok := reverseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reverse_name expected to be basetypes.StringValue, was: %T`, reverseNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V4Value{
		Gateway:     gatewayVal,
		IpAddress:   ipAddressVal,
		NatTarget:   natTargetVal,
		Netmask:     netmaskVal,
		ReverseName: reverseNameVal,
		V4Type:      typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewV4ValueNull() V4Value {
	return V4Value{
		state: attr.ValueStateNull,
	}
}

func NewV4ValueUnknown() V4Value {
	return V4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewV4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V4Value Attribute Value",
				"While creating a V4Value value, a missing attribute value was detected. "+
					"A V4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V4Value Attribute Type",
				"While creating a V4Value value, an invalid attribute value was detected. "+
					"A V4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V4Value Attribute Value",
				"While creating a V4Value value, an extra attribute value was detected. "+
					"A V4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV4ValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natTargetAttribute, ok := attributes["nat_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_target is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	natTargetVal, ok := natTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_target expected to be basetypes.StringValue, was: %T`, natTargetAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	reverseNameAttribute, ok := attributes["reverse_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reverse_name is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	reverseNameVal, ok := reverseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reverse_name expected to be basetypes.StringValue, was: %T`, reverseNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewV4ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewV4ValueUnknown(), diags
	}

	return V4Value{
		Gateway:     gatewayVal,
		IpAddress:   ipAddressVal,
		NatTarget:   natTargetVal,
		Netmask:     netmaskVal,
		ReverseName: reverseNameVal,
		V4Type:      typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewV4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V4Value {
	object, diags := NewV4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV4ValueMust(V4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t V4Type) ValueType(ctx context.Context) attr.Value {
	return V4Value{}
}

var _ basetypes.ObjectValuable = V4Value{}

type V4Value struct {
	Gateway     basetypes.StringValue `tfsdk:"gateway"`
	IpAddress   basetypes.StringValue `tfsdk:"ip_address"`
	NatTarget   basetypes.StringValue `tfsdk:"nat_target"`
	Netmask     basetypes.StringValue `tfsdk:"netmask"`
	ReverseName basetypes.StringValue `tfsdk:"reverse_name"`
	V4Type      basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v V4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nat_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reverse_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.NatTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_target"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.ReverseName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reverse_name"] = val

		val, err = v.V4Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V4Value) String() string {
	return "V4Value"
}

func (v V4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway":      basetypes.StringType{},
		"ip_address":   basetypes.StringType{},
		"nat_target":   basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"reverse_name": basetypes.StringType{},
		"type":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":      v.Gateway,
			"ip_address":   v.IpAddress,
			"nat_target":   v.NatTarget,
			"netmask":      v.Netmask,
			"reverse_name": v.ReverseName,
			"type":         v.V4Type,
		})

	return objVal, diags
}

func (v V4Value) Equal(o attr.Value) bool {
	other, ok := o.(V4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.NatTarget.Equal(other.NatTarget) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.ReverseName.Equal(other.ReverseName) {
		return false
	}

	if !v.V4Type.Equal(other.V4Type) {
		return false
	}

	return true
}

func (v V4Value) Type(ctx context.Context) attr.Type {
	return V4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway":      basetypes.StringType{},
		"ip_address":   basetypes.StringType{},
		"nat_target":   basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"reverse_name": basetypes.StringType{},
		"type":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = V6Type{}

type V6Type struct {
	basetypes.ObjectType
}

func (t V6Type) Equal(o attr.Type) bool {
	other, ok := o.(V6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t V6Type) String() string {
	return "V6Type"
}

func (t V6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return nil, diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natTargetAttribute, ok := attributes["nat_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_target is missing from object`)

		return nil, diags
	}

	natTargetVal, ok := natTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_target expected to be basetypes.StringValue, was: %T`, natTargetAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return nil, diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	reverseNameAttribute, ok := attributes["reverse_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reverse_name is missing from object`)

		return nil, diags
	}

	reverseNameVal, ok := reverseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reverse_name expected to be basetypes.StringValue, was: %T`, reverseNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return V6Value{
		Gateway:     gatewayVal,
		IpAddress:   ipAddressVal,
		NatTarget:   natTargetVal,
		Netmask:     netmaskVal,
		ReverseName: reverseNameVal,
		V6Type:      typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewV6ValueNull() V6Value {
	return V6Value{
		state: attr.ValueStateNull,
	}
}

func NewV6ValueUnknown() V6Value {
	return V6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewV6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (V6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing V6Value Attribute Value",
				"While creating a V6Value value, a missing attribute value was detected. "+
					"A V6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid V6Value Attribute Type",
				"While creating a V6Value value, an invalid attribute value was detected. "+
					"A V6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("V6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("V6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra V6Value Attribute Value",
				"While creating a V6Value value, an extra attribute value was detected. "+
					"A V6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra V6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewV6ValueUnknown(), diags
	}

	gatewayAttribute, ok := attributes["gateway"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gateway is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	gatewayVal, ok := gatewayAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gateway expected to be basetypes.StringValue, was: %T`, gatewayAttribute))
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	natTargetAttribute, ok := attributes["nat_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nat_target is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	natTargetVal, ok := natTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nat_target expected to be basetypes.StringValue, was: %T`, natTargetAttribute))
	}

	netmaskAttribute, ok := attributes["netmask"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`netmask is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	netmaskVal, ok := netmaskAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`netmask expected to be basetypes.StringValue, was: %T`, netmaskAttribute))
	}

	reverseNameAttribute, ok := attributes["reverse_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reverse_name is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	reverseNameVal, ok := reverseNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reverse_name expected to be basetypes.StringValue, was: %T`, reverseNameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewV6ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewV6ValueUnknown(), diags
	}

	return V6Value{
		Gateway:     gatewayVal,
		IpAddress:   ipAddressVal,
		NatTarget:   natTargetVal,
		Netmask:     netmaskVal,
		ReverseName: reverseNameVal,
		V6Type:      typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewV6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) V6Value {
	object, diags := NewV6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewV6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t V6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewV6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewV6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewV6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewV6ValueMust(V6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t V6Type) ValueType(ctx context.Context) attr.Value {
	return V6Value{}
}

var _ basetypes.ObjectValuable = V6Value{}

type V6Value struct {
	Gateway     basetypes.StringValue `tfsdk:"gateway"`
	IpAddress   basetypes.StringValue `tfsdk:"ip_address"`
	NatTarget   basetypes.StringValue `tfsdk:"nat_target"`
	Netmask     basetypes.StringValue `tfsdk:"netmask"`
	ReverseName basetypes.StringValue `tfsdk:"reverse_name"`
	V6Type      basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v V6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["gateway"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nat_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["netmask"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["reverse_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Gateway.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gateway"] = val

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.NatTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nat_target"] = val

		val, err = v.Netmask.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["netmask"] = val

		val, err = v.ReverseName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reverse_name"] = val

		val, err = v.V6Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v V6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v V6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v V6Value) String() string {
	return "V6Value"
}

func (v V6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"gateway":      basetypes.StringType{},
		"ip_address":   basetypes.StringType{},
		"nat_target":   basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"reverse_name": basetypes.StringType{},
		"type":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"gateway":      v.Gateway,
			"ip_address":   v.IpAddress,
			"nat_target":   v.NatTarget,
			"netmask":      v.Netmask,
			"reverse_name": v.ReverseName,
			"type":         v.V6Type,
		})

	return objVal, diags
}

func (v V6Value) Equal(o attr.Value) bool {
	other, ok := o.(V6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Gateway.Equal(other.Gateway) {
		return false
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.NatTarget.Equal(other.NatTarget) {
		return false
	}

	if !v.Netmask.Equal(other.Netmask) {
		return false
	}

	if !v.ReverseName.Equal(other.ReverseName) {
		return false
	}

	if !v.V6Type.Equal(other.V6Type) {
		return false
	}

	return true
}

func (v V6Value) Type(ctx context.Context) attr.Type {
	return V6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v V6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"gateway":      basetypes.StringType{},
		"ip_address":   basetypes.StringType{},
		"nat_target":   basetypes.StringType{},
		"netmask":      basetypes.StringType{},
		"reverse_name": basetypes.StringType{},
		"type":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NextBackupWindowType{}

type NextBackupWindowType struct {
	basetypes.ObjectType
}

func (t NextBackupWindowType) Equal(o attr.Type) bool {
	other, ok := o.(NextBackupWindowType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NextBackupWindowType) String() string {
	return "NextBackupWindowType"
}

func (t NextBackupWindowType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return nil, diags
	}

	endVal, ok := endAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.StringValue, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NextBackupWindowValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNextBackupWindowValueNull() NextBackupWindowValue {
	return NextBackupWindowValue{
		state: attr.ValueStateNull,
	}
}

func NewNextBackupWindowValueUnknown() NextBackupWindowValue {
	return NextBackupWindowValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNextBackupWindowValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NextBackupWindowValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NextBackupWindowValue Attribute Value",
				"While creating a NextBackupWindowValue value, a missing attribute value was detected. "+
					"A NextBackupWindowValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextBackupWindowValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NextBackupWindowValue Attribute Type",
				"While creating a NextBackupWindowValue value, an invalid attribute value was detected. "+
					"A NextBackupWindowValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NextBackupWindowValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NextBackupWindowValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NextBackupWindowValue Attribute Value",
				"While creating a NextBackupWindowValue value, an extra attribute value was detected. "+
					"A NextBackupWindowValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NextBackupWindowValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNextBackupWindowValueUnknown(), diags
	}

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return NewNextBackupWindowValueUnknown(), diags
	}

	endVal, ok := endAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.StringValue, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewNextBackupWindowValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.StringValue, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewNextBackupWindowValueUnknown(), diags
	}

	return NextBackupWindowValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewNextBackupWindowValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NextBackupWindowValue {
	object, diags := NewNextBackupWindowValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNextBackupWindowValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NextBackupWindowType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNextBackupWindowValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNextBackupWindowValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNextBackupWindowValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNextBackupWindowValueMust(NextBackupWindowValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NextBackupWindowType) ValueType(ctx context.Context) attr.Value {
	return NextBackupWindowValue{}
}

var _ basetypes.ObjectValuable = NextBackupWindowValue{}

type NextBackupWindowValue struct {
	End   basetypes.StringValue `tfsdk:"end"`
	Start basetypes.StringValue `tfsdk:"start"`
	state attr.ValueState
}

func (v NextBackupWindowValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["end"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.End.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NextBackupWindowValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NextBackupWindowValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NextBackupWindowValue) String() string {
	return "NextBackupWindowValue"
}

func (v NextBackupWindowValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"end":   basetypes.StringType{},
		"start": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"end":   v.End,
			"start": v.Start,
		})

	return objVal, diags
}

func (v NextBackupWindowValue) Equal(o attr.Value) bool {
	other, ok := o.(NextBackupWindowValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.End.Equal(other.End) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v NextBackupWindowValue) Type(ctx context.Context) attr.Type {
	return NextBackupWindowType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NextBackupWindowValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"end":   basetypes.StringType{},
		"start": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RegionType{}

type RegionType struct {
	basetypes.ObjectType
}

func (t RegionType) Equal(o attr.Type) bool {
	other, ok := o.(RegionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RegionType) String() string {
	return "RegionType"
}

func (t RegionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return nil, diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return nil, diags
	}

	nameServersVal, ok := nameServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be basetypes.ListValue, was: %T`, nameServersAttribute))
	}

	sizesAttribute, ok := attributes["sizes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sizes is missing from object`)

		return nil, diags
	}

	sizesVal, ok := sizesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sizes expected to be basetypes.ListValue, was: %T`, sizesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RegionValue{
		Available:   availableVal,
		Features:    featuresVal,
		Name:        nameVal,
		NameServers: nameServersVal,
		Sizes:       sizesVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRegionValueNull() RegionValue {
	return RegionValue{
		state: attr.ValueStateNull,
	}
}

func NewRegionValueUnknown() RegionValue {
	return RegionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRegionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RegionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RegionValue Attribute Value",
				"While creating a RegionValue value, a missing attribute value was detected. "+
					"A RegionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RegionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RegionValue Attribute Type",
				"While creating a RegionValue value, an invalid attribute value was detected. "+
					"A RegionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RegionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RegionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RegionValue Attribute Value",
				"While creating a RegionValue value, an extra attribute value was detected. "+
					"A RegionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RegionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRegionValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	featuresAttribute, ok := attributes["features"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`features is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	featuresVal, ok := featuresAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`features expected to be basetypes.ListValue, was: %T`, featuresAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	nameServersAttribute, ok := attributes["name_servers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name_servers is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	nameServersVal, ok := nameServersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name_servers expected to be basetypes.ListValue, was: %T`, nameServersAttribute))
	}

	sizesAttribute, ok := attributes["sizes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sizes is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	sizesVal, ok := sizesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sizes expected to be basetypes.ListValue, was: %T`, sizesAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewRegionValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return NewRegionValueUnknown(), diags
	}

	return RegionValue{
		Available:   availableVal,
		Features:    featuresVal,
		Name:        nameVal,
		NameServers: nameServersVal,
		Sizes:       sizesVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRegionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RegionValue {
	object, diags := NewRegionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRegionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RegionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRegionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRegionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRegionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRegionValueMust(RegionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RegionType) ValueType(ctx context.Context) attr.Value {
	return RegionValue{}
}

var _ basetypes.ObjectValuable = RegionValue{}

type RegionValue struct {
	Available   basetypes.BoolValue   `tfsdk:"available"`
	Features    basetypes.ListValue   `tfsdk:"features"`
	Name        basetypes.StringValue `tfsdk:"name"`
	NameServers basetypes.ListValue   `tfsdk:"name_servers"`
	Sizes       basetypes.ListValue   `tfsdk:"sizes"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	state       attr.ValueState
}

func (v RegionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["features"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name_servers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["sizes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.Features.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["features"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.NameServers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name_servers"] = val

		val, err = v.Sizes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sizes"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RegionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RegionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RegionValue) String() string {
	return "RegionValue"
}

func (v RegionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	featuresVal, d := types.ListValue(types.StringType, v.Features.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available": basetypes.BoolType{},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"name_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sizes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"slug": basetypes.StringType{},
		}), diags
	}

	nameServersVal, d := types.ListValue(types.StringType, v.NameServers.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available": basetypes.BoolType{},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"name_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sizes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"slug": basetypes.StringType{},
		}), diags
	}

	sizesVal, d := types.ListValue(types.StringType, v.Sizes.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available": basetypes.BoolType{},
			"features": basetypes.ListType{
				ElemType: types.StringType,
			},
			"name": basetypes.StringType{},
			"name_servers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"sizes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"slug": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"available": basetypes.BoolType{},
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"name_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sizes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"slug": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"available":    v.Available,
			"features":     featuresVal,
			"name":         v.Name,
			"name_servers": nameServersVal,
			"sizes":        sizesVal,
			"slug":         v.Slug,
		})

	return objVal, diags
}

func (v RegionValue) Equal(o attr.Value) bool {
	other, ok := o.(RegionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.Features.Equal(other.Features) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.NameServers.Equal(other.NameServers) {
		return false
	}

	if !v.Sizes.Equal(other.Sizes) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	return true
}

func (v RegionValue) Type(ctx context.Context) attr.Type {
	return RegionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RegionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available": basetypes.BoolType{},
		"features": basetypes.ListType{
			ElemType: types.StringType,
		},
		"name": basetypes.StringType{},
		"name_servers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"sizes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"slug": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SelectedSizeOptionsType{}

type SelectedSizeOptionsType struct {
	basetypes.ObjectType
}

func (t SelectedSizeOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(SelectedSizeOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SelectedSizeOptionsType) String() string {
	return "SelectedSizeOptionsType"
}

func (t SelectedSizeOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return nil, diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return nil, diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.Int64Value, was: %T`, ipv4AddressesAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return nil, diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupsAttribute, ok := attributes["offsite_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups is missing from object`)

		return nil, diags
	}

	offsiteBackupsVal, ok := offsiteBackupsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups expected to be basetypes.BoolValue, was: %T`, offsiteBackupsAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return nil, diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return nil, diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SelectedSizeOptionsValue{
		DailyBackups:   dailyBackupsVal,
		Disk:           diskVal,
		Ipv4Addresses:  ipv4AddressesVal,
		Memory:         memoryVal,
		MonthlyBackups: monthlyBackupsVal,
		OffsiteBackups: offsiteBackupsVal,
		Transfer:       transferVal,
		WeeklyBackups:  weeklyBackupsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSelectedSizeOptionsValueNull() SelectedSizeOptionsValue {
	return SelectedSizeOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewSelectedSizeOptionsValueUnknown() SelectedSizeOptionsValue {
	return SelectedSizeOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSelectedSizeOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SelectedSizeOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SelectedSizeOptionsValue Attribute Value",
				"While creating a SelectedSizeOptionsValue value, a missing attribute value was detected. "+
					"A SelectedSizeOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelectedSizeOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SelectedSizeOptionsValue Attribute Type",
				"While creating a SelectedSizeOptionsValue value, an invalid attribute value was detected. "+
					"A SelectedSizeOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SelectedSizeOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SelectedSizeOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SelectedSizeOptionsValue Attribute Value",
				"While creating a SelectedSizeOptionsValue value, an extra attribute value was detected. "+
					"A SelectedSizeOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SelectedSizeOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.Int64Value, was: %T`, ipv4AddressesAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupsAttribute, ok := attributes["offsite_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	offsiteBackupsVal, ok := offsiteBackupsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups expected to be basetypes.BoolValue, was: %T`, offsiteBackupsAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return NewSelectedSizeOptionsValueUnknown(), diags
	}

	return SelectedSizeOptionsValue{
		DailyBackups:   dailyBackupsVal,
		Disk:           diskVal,
		Ipv4Addresses:  ipv4AddressesVal,
		Memory:         memoryVal,
		MonthlyBackups: monthlyBackupsVal,
		OffsiteBackups: offsiteBackupsVal,
		Transfer:       transferVal,
		WeeklyBackups:  weeklyBackupsVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSelectedSizeOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SelectedSizeOptionsValue {
	object, diags := NewSelectedSizeOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSelectedSizeOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SelectedSizeOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSelectedSizeOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSelectedSizeOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSelectedSizeOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSelectedSizeOptionsValueMust(SelectedSizeOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SelectedSizeOptionsType) ValueType(ctx context.Context) attr.Value {
	return SelectedSizeOptionsValue{}
}

var _ basetypes.ObjectValuable = SelectedSizeOptionsValue{}

type SelectedSizeOptionsValue struct {
	DailyBackups   basetypes.Int64Value   `tfsdk:"daily_backups"`
	Disk           basetypes.Int64Value   `tfsdk:"disk"`
	Ipv4Addresses  basetypes.Int64Value   `tfsdk:"ipv4_addresses"`
	Memory         basetypes.Int64Value   `tfsdk:"memory"`
	MonthlyBackups basetypes.Int64Value   `tfsdk:"monthly_backups"`
	OffsiteBackups basetypes.BoolValue    `tfsdk:"offsite_backups"`
	Transfer       basetypes.Float64Value `tfsdk:"transfer"`
	WeeklyBackups  basetypes.Int64Value   `tfsdk:"weekly_backups"`
	state          attr.ValueState
}

func (v SelectedSizeOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["daily_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monthly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["offsite_backups"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["transfer"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.DailyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_backups"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.Ipv4Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.MonthlyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_backups"] = val

		val, err = v.OffsiteBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backups"] = val

		val, err = v.Transfer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer"] = val

		val, err = v.WeeklyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_backups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SelectedSizeOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SelectedSizeOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SelectedSizeOptionsValue) String() string {
	return "SelectedSizeOptionsValue"
}

func (v SelectedSizeOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"daily_backups":   basetypes.Int64Type{},
		"disk":            basetypes.Int64Type{},
		"ipv4_addresses":  basetypes.Int64Type{},
		"memory":          basetypes.Int64Type{},
		"monthly_backups": basetypes.Int64Type{},
		"offsite_backups": basetypes.BoolType{},
		"transfer":        basetypes.Float64Type{},
		"weekly_backups":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daily_backups":   v.DailyBackups,
			"disk":            v.Disk,
			"ipv4_addresses":  v.Ipv4Addresses,
			"memory":          v.Memory,
			"monthly_backups": v.MonthlyBackups,
			"offsite_backups": v.OffsiteBackups,
			"transfer":        v.Transfer,
			"weekly_backups":  v.WeeklyBackups,
		})

	return objVal, diags
}

func (v SelectedSizeOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(SelectedSizeOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DailyBackups.Equal(other.DailyBackups) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.Ipv4Addresses.Equal(other.Ipv4Addresses) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.MonthlyBackups.Equal(other.MonthlyBackups) {
		return false
	}

	if !v.OffsiteBackups.Equal(other.OffsiteBackups) {
		return false
	}

	if !v.Transfer.Equal(other.Transfer) {
		return false
	}

	if !v.WeeklyBackups.Equal(other.WeeklyBackups) {
		return false
	}

	return true
}

func (v SelectedSizeOptionsValue) Type(ctx context.Context) attr.Type {
	return SelectedSizeOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SelectedSizeOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daily_backups":   basetypes.Int64Type{},
		"disk":            basetypes.Int64Type{},
		"ipv4_addresses":  basetypes.Int64Type{},
		"memory":          basetypes.Int64Type{},
		"monthly_backups": basetypes.Int64Type{},
		"offsite_backups": basetypes.BoolType{},
		"transfer":        basetypes.Float64Type{},
		"weekly_backups":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SizeType{}

type SizeType struct {
	basetypes.ObjectType
}

func (t SizeType) Equal(o attr.Type) bool {
	other, ok := o.(SizeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SizeType) String() string {
	return "SizeType"
}

func (t SizeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return nil, diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	cpuDescriptionAttribute, ok := attributes["cpu_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_description is missing from object`)

		return nil, diags
	}

	cpuDescriptionVal, ok := cpuDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_description expected to be basetypes.StringValue, was: %T`, cpuDescriptionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return nil, diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	excessTransferCostPerGigabyteAttribute, ok := attributes["excess_transfer_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excess_transfer_cost_per_gigabyte is missing from object`)

		return nil, diags
	}

	excessTransferCostPerGigabyteVal, ok := excessTransferCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excess_transfer_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, excessTransferCostPerGigabyteAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return nil, diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	options2Attribute, ok := attributes["options2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options2 is missing from object`)

		return nil, diags
	}

	options2Val, ok := options2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options2 expected to be basetypes.ObjectValue, was: %T`, options2Attribute))
	}

	priceHourlyAttribute, ok := attributes["price_hourly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_hourly is missing from object`)

		return nil, diags
	}

	priceHourlyVal, ok := priceHourlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_hourly expected to be basetypes.Float64Value, was: %T`, priceHourlyAttribute))
	}

	priceMonthlyAttribute, ok := attributes["price_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_monthly is missing from object`)

		return nil, diags
	}

	priceMonthlyVal, ok := priceMonthlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_monthly expected to be basetypes.Float64Value, was: %T`, priceMonthlyAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return nil, diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	regionsOutOfStockAttribute, ok := attributes["regions_out_of_stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions_out_of_stock is missing from object`)

		return nil, diags
	}

	regionsOutOfStockVal, ok := regionsOutOfStockAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions_out_of_stock expected to be basetypes.ListValue, was: %T`, regionsOutOfStockAttribute))
	}

	sizeTypeAttribute, ok := attributes["size_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_type is missing from object`)

		return nil, diags
	}

	sizeTypeVal, ok := sizeTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_type expected to be basetypes.ObjectValue, was: %T`, sizeTypeAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	storageDescriptionAttribute, ok := attributes["storage_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_description is missing from object`)

		return nil, diags
	}

	storageDescriptionVal, ok := storageDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_description expected to be basetypes.StringValue, was: %T`, storageDescriptionAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return nil, diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	vcpuUnitsAttribute, ok := attributes["vcpu_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_units is missing from object`)

		return nil, diags
	}

	vcpuUnitsVal, ok := vcpuUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_units expected to be basetypes.StringValue, was: %T`, vcpuUnitsAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return nil, diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SizeValue{
		Available:                     availableVal,
		CpuDescription:                cpuDescriptionVal,
		Description:                   descriptionVal,
		Disk:                          diskVal,
		ExcessTransferCostPerGigabyte: excessTransferCostPerGigabyteVal,
		Memory:                        memoryVal,
		Options2:                      options2Val,
		PriceHourly:                   priceHourlyVal,
		PriceMonthly:                  priceMonthlyVal,
		Regions:                       regionsVal,
		RegionsOutOfStock:             regionsOutOfStockVal,
		SizeType:                      sizeTypeVal,
		Slug:                          slugVal,
		StorageDescription:            storageDescriptionVal,
		Transfer:                      transferVal,
		VcpuUnits:                     vcpuUnitsVal,
		Vcpus:                         vcpusVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSizeValueNull() SizeValue {
	return SizeValue{
		state: attr.ValueStateNull,
	}
}

func NewSizeValueUnknown() SizeValue {
	return SizeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSizeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SizeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SizeValue Attribute Value",
				"While creating a SizeValue value, a missing attribute value was detected. "+
					"A SizeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SizeValue Attribute Type",
				"While creating a SizeValue value, an invalid attribute value was detected. "+
					"A SizeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SizeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SizeValue Attribute Value",
				"While creating a SizeValue value, an extra attribute value was detected. "+
					"A SizeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SizeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSizeValueUnknown(), diags
	}

	availableAttribute, ok := attributes["available"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`available is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	availableVal, ok := availableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`available expected to be basetypes.BoolValue, was: %T`, availableAttribute))
	}

	cpuDescriptionAttribute, ok := attributes["cpu_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cpu_description is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	cpuDescriptionVal, ok := cpuDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cpu_description expected to be basetypes.StringValue, was: %T`, cpuDescriptionAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	diskAttribute, ok := attributes["disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	diskVal, ok := diskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk expected to be basetypes.Int64Value, was: %T`, diskAttribute))
	}

	excessTransferCostPerGigabyteAttribute, ok := attributes["excess_transfer_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`excess_transfer_cost_per_gigabyte is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	excessTransferCostPerGigabyteVal, ok := excessTransferCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`excess_transfer_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, excessTransferCostPerGigabyteAttribute))
	}

	memoryAttribute, ok := attributes["memory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	memoryVal, ok := memoryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory expected to be basetypes.Int64Value, was: %T`, memoryAttribute))
	}

	options2Attribute, ok := attributes["options2"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options2 is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	options2Val, ok := options2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options2 expected to be basetypes.ObjectValue, was: %T`, options2Attribute))
	}

	priceHourlyAttribute, ok := attributes["price_hourly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_hourly is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	priceHourlyVal, ok := priceHourlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_hourly expected to be basetypes.Float64Value, was: %T`, priceHourlyAttribute))
	}

	priceMonthlyAttribute, ok := attributes["price_monthly"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`price_monthly is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	priceMonthlyVal, ok := priceMonthlyAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`price_monthly expected to be basetypes.Float64Value, was: %T`, priceMonthlyAttribute))
	}

	regionsAttribute, ok := attributes["regions"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	regionsVal, ok := regionsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions expected to be basetypes.ListValue, was: %T`, regionsAttribute))
	}

	regionsOutOfStockAttribute, ok := attributes["regions_out_of_stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`regions_out_of_stock is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	regionsOutOfStockVal, ok := regionsOutOfStockAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`regions_out_of_stock expected to be basetypes.ListValue, was: %T`, regionsOutOfStockAttribute))
	}

	sizeTypeAttribute, ok := attributes["size_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_type is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	sizeTypeVal, ok := sizeTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_type expected to be basetypes.ObjectValue, was: %T`, sizeTypeAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	storageDescriptionAttribute, ok := attributes["storage_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_description is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	storageDescriptionVal, ok := storageDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_description expected to be basetypes.StringValue, was: %T`, storageDescriptionAttribute))
	}

	transferAttribute, ok := attributes["transfer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	transferVal, ok := transferAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer expected to be basetypes.Float64Value, was: %T`, transferAttribute))
	}

	vcpuUnitsAttribute, ok := attributes["vcpu_units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpu_units is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	vcpuUnitsVal, ok := vcpuUnitsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpu_units expected to be basetypes.StringValue, was: %T`, vcpuUnitsAttribute))
	}

	vcpusAttribute, ok := attributes["vcpus"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vcpus is missing from object`)

		return NewSizeValueUnknown(), diags
	}

	vcpusVal, ok := vcpusAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vcpus expected to be basetypes.Int64Value, was: %T`, vcpusAttribute))
	}

	if diags.HasError() {
		return NewSizeValueUnknown(), diags
	}

	return SizeValue{
		Available:                     availableVal,
		CpuDescription:                cpuDescriptionVal,
		Description:                   descriptionVal,
		Disk:                          diskVal,
		ExcessTransferCostPerGigabyte: excessTransferCostPerGigabyteVal,
		Memory:                        memoryVal,
		Options2:                      options2Val,
		PriceHourly:                   priceHourlyVal,
		PriceMonthly:                  priceMonthlyVal,
		Regions:                       regionsVal,
		RegionsOutOfStock:             regionsOutOfStockVal,
		SizeType:                      sizeTypeVal,
		Slug:                          slugVal,
		StorageDescription:            storageDescriptionVal,
		Transfer:                      transferVal,
		VcpuUnits:                     vcpuUnitsVal,
		Vcpus:                         vcpusVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSizeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SizeValue {
	object, diags := NewSizeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSizeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SizeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSizeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSizeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSizeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSizeValueMust(SizeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SizeType) ValueType(ctx context.Context) attr.Value {
	return SizeValue{}
}

var _ basetypes.ObjectValuable = SizeValue{}

type SizeValue struct {
	Available                     basetypes.BoolValue    `tfsdk:"available"`
	CpuDescription                basetypes.StringValue  `tfsdk:"cpu_description"`
	Description                   basetypes.StringValue  `tfsdk:"description"`
	Disk                          basetypes.Int64Value   `tfsdk:"disk"`
	ExcessTransferCostPerGigabyte basetypes.Float64Value `tfsdk:"excess_transfer_cost_per_gigabyte"`
	Memory                        basetypes.Int64Value   `tfsdk:"memory"`
	Options2                      basetypes.ObjectValue  `tfsdk:"options2"`
	PriceHourly                   basetypes.Float64Value `tfsdk:"price_hourly"`
	PriceMonthly                  basetypes.Float64Value `tfsdk:"price_monthly"`
	Regions                       basetypes.ListValue    `tfsdk:"regions"`
	RegionsOutOfStock             basetypes.ListValue    `tfsdk:"regions_out_of_stock"`
	SizeType                      basetypes.ObjectValue  `tfsdk:"size_type"`
	Slug                          basetypes.StringValue  `tfsdk:"slug"`
	StorageDescription            basetypes.StringValue  `tfsdk:"storage_description"`
	Transfer                      basetypes.Float64Value `tfsdk:"transfer"`
	VcpuUnits                     basetypes.StringValue  `tfsdk:"vcpu_units"`
	Vcpus                         basetypes.Int64Value   `tfsdk:"vcpus"`
	state                         attr.ValueState
}

func (v SizeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["available"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cpu_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["excess_transfer_cost_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["memory"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["options2"] = basetypes.ObjectType{
		AttrTypes: Options2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["price_hourly"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["price_monthly"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["regions"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["regions_out_of_stock"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["size_type"] = basetypes.ObjectType{
		AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["storage_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["transfer"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["vcpu_units"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vcpus"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.Available.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["available"] = val

		val, err = v.CpuDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cpu_description"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Disk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk"] = val

		val, err = v.ExcessTransferCostPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["excess_transfer_cost_per_gigabyte"] = val

		val, err = v.Memory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory"] = val

		val, err = v.Options2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options2"] = val

		val, err = v.PriceHourly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price_hourly"] = val

		val, err = v.PriceMonthly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["price_monthly"] = val

		val, err = v.Regions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions"] = val

		val, err = v.RegionsOutOfStock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["regions_out_of_stock"] = val

		val, err = v.SizeType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_type"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.StorageDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_description"] = val

		val, err = v.Transfer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer"] = val

		val, err = v.VcpuUnits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpu_units"] = val

		val, err = v.Vcpus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vcpus"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SizeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SizeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SizeValue) String() string {
	return "SizeValue"
}

func (v SizeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var options2 basetypes.ObjectValue

	if v.Options2.IsNull() {
		options2 = types.ObjectNull(
			Options2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Options2.IsUnknown() {
		options2 = types.ObjectUnknown(
			Options2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Options2.IsNull() && !v.Options2.IsUnknown() {
		options2 = types.ObjectValueMust(
			Options2Value{}.AttributeTypes(ctx),
			v.Options2.Attributes(),
		)
	}

	var sizeType basetypes.ObjectValue

	if v.SizeType.IsNull() {
		sizeType = types.ObjectNull(
			SizeTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.SizeType.IsUnknown() {
		sizeType = types.ObjectUnknown(
			SizeTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SizeType.IsNull() && !v.SizeType.IsUnknown() {
		sizeType = types.ObjectValueMust(
			SizeTypeValue{}.AttributeTypes(ctx),
			v.SizeType.Attributes(),
		)
	}

	regionsVal, d := types.ListValue(types.StringType, v.Regions.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available":                         basetypes.BoolType{},
			"cpu_description":                   basetypes.StringType{},
			"description":                       basetypes.StringType{},
			"disk":                              basetypes.Int64Type{},
			"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
			"memory":                            basetypes.Int64Type{},
			"options2": basetypes.ObjectType{
				AttrTypes: Options2Value{}.AttributeTypes(ctx),
			},
			"price_hourly":  basetypes.Float64Type{},
			"price_monthly": basetypes.Float64Type{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"regions_out_of_stock": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_type": basetypes.ObjectType{
				AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
			},
			"slug":                basetypes.StringType{},
			"storage_description": basetypes.StringType{},
			"transfer":            basetypes.Float64Type{},
			"vcpu_units":          basetypes.StringType{},
			"vcpus":               basetypes.Int64Type{},
		}), diags
	}

	regionsOutOfStockVal, d := types.ListValue(types.StringType, v.RegionsOutOfStock.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"available":                         basetypes.BoolType{},
			"cpu_description":                   basetypes.StringType{},
			"description":                       basetypes.StringType{},
			"disk":                              basetypes.Int64Type{},
			"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
			"memory":                            basetypes.Int64Type{},
			"options2": basetypes.ObjectType{
				AttrTypes: Options2Value{}.AttributeTypes(ctx),
			},
			"price_hourly":  basetypes.Float64Type{},
			"price_monthly": basetypes.Float64Type{},
			"regions": basetypes.ListType{
				ElemType: types.StringType,
			},
			"regions_out_of_stock": basetypes.ListType{
				ElemType: types.StringType,
			},
			"size_type": basetypes.ObjectType{
				AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
			},
			"slug":                basetypes.StringType{},
			"storage_description": basetypes.StringType{},
			"transfer":            basetypes.Float64Type{},
			"vcpu_units":          basetypes.StringType{},
			"vcpus":               basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"available":                         basetypes.BoolType{},
		"cpu_description":                   basetypes.StringType{},
		"description":                       basetypes.StringType{},
		"disk":                              basetypes.Int64Type{},
		"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
		"memory":                            basetypes.Int64Type{},
		"options2": basetypes.ObjectType{
			AttrTypes: Options2Value{}.AttributeTypes(ctx),
		},
		"price_hourly":  basetypes.Float64Type{},
		"price_monthly": basetypes.Float64Type{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"regions_out_of_stock": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_type": basetypes.ObjectType{
			AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
		},
		"slug":                basetypes.StringType{},
		"storage_description": basetypes.StringType{},
		"transfer":            basetypes.Float64Type{},
		"vcpu_units":          basetypes.StringType{},
		"vcpus":               basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"available":                         v.Available,
			"cpu_description":                   v.CpuDescription,
			"description":                       v.Description,
			"disk":                              v.Disk,
			"excess_transfer_cost_per_gigabyte": v.ExcessTransferCostPerGigabyte,
			"memory":                            v.Memory,
			"options2":                          options2,
			"price_hourly":                      v.PriceHourly,
			"price_monthly":                     v.PriceMonthly,
			"regions":                           regionsVal,
			"regions_out_of_stock":              regionsOutOfStockVal,
			"size_type":                         sizeType,
			"slug":                              v.Slug,
			"storage_description":               v.StorageDescription,
			"transfer":                          v.Transfer,
			"vcpu_units":                        v.VcpuUnits,
			"vcpus":                             v.Vcpus,
		})

	return objVal, diags
}

func (v SizeValue) Equal(o attr.Value) bool {
	other, ok := o.(SizeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Available.Equal(other.Available) {
		return false
	}

	if !v.CpuDescription.Equal(other.CpuDescription) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Disk.Equal(other.Disk) {
		return false
	}

	if !v.ExcessTransferCostPerGigabyte.Equal(other.ExcessTransferCostPerGigabyte) {
		return false
	}

	if !v.Memory.Equal(other.Memory) {
		return false
	}

	if !v.Options2.Equal(other.Options2) {
		return false
	}

	if !v.PriceHourly.Equal(other.PriceHourly) {
		return false
	}

	if !v.PriceMonthly.Equal(other.PriceMonthly) {
		return false
	}

	if !v.Regions.Equal(other.Regions) {
		return false
	}

	if !v.RegionsOutOfStock.Equal(other.RegionsOutOfStock) {
		return false
	}

	if !v.SizeType.Equal(other.SizeType) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.StorageDescription.Equal(other.StorageDescription) {
		return false
	}

	if !v.Transfer.Equal(other.Transfer) {
		return false
	}

	if !v.VcpuUnits.Equal(other.VcpuUnits) {
		return false
	}

	if !v.Vcpus.Equal(other.Vcpus) {
		return false
	}

	return true
}

func (v SizeValue) Type(ctx context.Context) attr.Type {
	return SizeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SizeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"available":                         basetypes.BoolType{},
		"cpu_description":                   basetypes.StringType{},
		"description":                       basetypes.StringType{},
		"disk":                              basetypes.Int64Type{},
		"excess_transfer_cost_per_gigabyte": basetypes.Float64Type{},
		"memory":                            basetypes.Int64Type{},
		"options2": basetypes.ObjectType{
			AttrTypes: Options2Value{}.AttributeTypes(ctx),
		},
		"price_hourly":  basetypes.Float64Type{},
		"price_monthly": basetypes.Float64Type{},
		"regions": basetypes.ListType{
			ElemType: types.StringType,
		},
		"regions_out_of_stock": basetypes.ListType{
			ElemType: types.StringType,
		},
		"size_type": basetypes.ObjectType{
			AttrTypes: SizeTypeValue{}.AttributeTypes(ctx),
		},
		"slug":                basetypes.StringType{},
		"storage_description": basetypes.StringType{},
		"transfer":            basetypes.Float64Type{},
		"vcpu_units":          basetypes.StringType{},
		"vcpus":               basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Options2Type{}

type Options2Type struct {
	basetypes.ObjectType
}

func (t Options2Type) Equal(o attr.Type) bool {
	other, ok := o.(Options2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Options2Type) String() string {
	return "Options2Type"
}

func (t Options2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	backupsCostPerBackupPerGigabyteAttribute, ok := attributes["backups_cost_per_backup_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backups_cost_per_backup_per_gigabyte is missing from object`)

		return nil, diags
	}

	backupsCostPerBackupPerGigabyteVal, ok := backupsCostPerBackupPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backups_cost_per_backup_per_gigabyte expected to be basetypes.Float64Value, was: %T`, backupsCostPerBackupPerGigabyteAttribute))
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return nil, diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	discountForNoPublicIpv4Attribute, ok := attributes["discount_for_no_public_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_for_no_public_ipv4 is missing from object`)

		return nil, diags
	}

	discountForNoPublicIpv4Val, ok := discountForNoPublicIpv4Attribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_for_no_public_ipv4 expected to be basetypes.Float64Value, was: %T`, discountForNoPublicIpv4Attribute))
	}

	diskCostPerAdditionalGigabyteAttribute, ok := attributes["disk_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_cost_per_additional_gigabyte is missing from object`)

		return nil, diags
	}

	diskCostPerAdditionalGigabyteVal, ok := diskCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, diskCostPerAdditionalGigabyteAttribute))
	}

	diskMaxAttribute, ok := attributes["disk_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_max is missing from object`)

		return nil, diags
	}

	diskMaxVal, ok := diskMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_max expected to be basetypes.Int64Value, was: %T`, diskMaxAttribute))
	}

	diskMinAttribute, ok := attributes["disk_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_min is missing from object`)

		return nil, diags
	}

	diskMinVal, ok := diskMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_min expected to be basetypes.Int64Value, was: %T`, diskMinAttribute))
	}

	ipv4AddressesCostPerAddressAttribute, ok := attributes["ipv4_addresses_cost_per_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_cost_per_address is missing from object`)

		return nil, diags
	}

	ipv4AddressesCostPerAddressVal, ok := ipv4AddressesCostPerAddressAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_cost_per_address expected to be basetypes.Float64Value, was: %T`, ipv4AddressesCostPerAddressAttribute))
	}

	ipv4AddressesMaxAttribute, ok := attributes["ipv4_addresses_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_max is missing from object`)

		return nil, diags
	}

	ipv4AddressesMaxVal, ok := ipv4AddressesMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_max expected to be basetypes.Int64Value, was: %T`, ipv4AddressesMaxAttribute))
	}

	memoryCostPerAdditionalMegabyteAttribute, ok := attributes["memory_cost_per_additional_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_cost_per_additional_megabyte is missing from object`)

		return nil, diags
	}

	memoryCostPerAdditionalMegabyteVal, ok := memoryCostPerAdditionalMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_cost_per_additional_megabyte expected to be basetypes.Float64Value, was: %T`, memoryCostPerAdditionalMegabyteAttribute))
	}

	memoryMaxAttribute, ok := attributes["memory_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_max is missing from object`)

		return nil, diags
	}

	memoryMaxVal, ok := memoryMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_max expected to be basetypes.Int64Value, was: %T`, memoryMaxAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return nil, diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupFrequencyCostAttribute, ok := attributes["offsite_backup_frequency_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_frequency_cost is missing from object`)

		return nil, diags
	}

	offsiteBackupFrequencyCostVal, ok := offsiteBackupFrequencyCostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_frequency_cost expected to be basetypes.ObjectValue, was: %T`, offsiteBackupFrequencyCostAttribute))
	}

	offsiteBackupsCostPerGigabyteAttribute, ok := attributes["offsite_backups_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups_cost_per_gigabyte is missing from object`)

		return nil, diags
	}

	offsiteBackupsCostPerGigabyteVal, ok := offsiteBackupsCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, offsiteBackupsCostPerGigabyteAttribute))
	}

	restrictedDiskValuesAttribute, ok := attributes["restricted_disk_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted_disk_values is missing from object`)

		return nil, diags
	}

	restrictedDiskValuesVal, ok := restrictedDiskValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted_disk_values expected to be basetypes.ListValue, was: %T`, restrictedDiskValuesAttribute))
	}

	transferCostPerAdditionalGigabyteAttribute, ok := attributes["transfer_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_cost_per_additional_gigabyte is missing from object`)

		return nil, diags
	}

	transferCostPerAdditionalGigabyteVal, ok := transferCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, transferCostPerAdditionalGigabyteAttribute))
	}

	transferMaxAttribute, ok := attributes["transfer_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_max is missing from object`)

		return nil, diags
	}

	transferMaxVal, ok := transferMaxAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_max expected to be basetypes.Float64Value, was: %T`, transferMaxAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return nil, diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Options2Value{
		BackupsCostPerBackupPerGigabyte:   backupsCostPerBackupPerGigabyteVal,
		DailyBackups:                      dailyBackupsVal,
		DiscountForNoPublicIpv4:           discountForNoPublicIpv4Val,
		DiskCostPerAdditionalGigabyte:     diskCostPerAdditionalGigabyteVal,
		DiskMax:                           diskMaxVal,
		DiskMin:                           diskMinVal,
		Ipv4AddressesCostPerAddress:       ipv4AddressesCostPerAddressVal,
		Ipv4AddressesMax:                  ipv4AddressesMaxVal,
		MemoryCostPerAdditionalMegabyte:   memoryCostPerAdditionalMegabyteVal,
		MemoryMax:                         memoryMaxVal,
		MonthlyBackups:                    monthlyBackupsVal,
		OffsiteBackupFrequencyCost:        offsiteBackupFrequencyCostVal,
		OffsiteBackupsCostPerGigabyte:     offsiteBackupsCostPerGigabyteVal,
		RestrictedDiskValues:              restrictedDiskValuesVal,
		TransferCostPerAdditionalGigabyte: transferCostPerAdditionalGigabyteVal,
		TransferMax:                       transferMaxVal,
		WeeklyBackups:                     weeklyBackupsVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewOptions2ValueNull() Options2Value {
	return Options2Value{
		state: attr.ValueStateNull,
	}
}

func NewOptions2ValueUnknown() Options2Value {
	return Options2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewOptions2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Options2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Options2Value Attribute Value",
				"While creating a Options2Value value, a missing attribute value was detected. "+
					"A Options2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Options2Value Attribute Type",
				"While creating a Options2Value value, an invalid attribute value was detected. "+
					"A Options2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Options2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Options2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Options2Value Attribute Value",
				"While creating a Options2Value value, an extra attribute value was detected. "+
					"A Options2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Options2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptions2ValueUnknown(), diags
	}

	backupsCostPerBackupPerGigabyteAttribute, ok := attributes["backups_cost_per_backup_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backups_cost_per_backup_per_gigabyte is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	backupsCostPerBackupPerGigabyteVal, ok := backupsCostPerBackupPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backups_cost_per_backup_per_gigabyte expected to be basetypes.Float64Value, was: %T`, backupsCostPerBackupPerGigabyteAttribute))
	}

	dailyBackupsAttribute, ok := attributes["daily_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_backups is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	dailyBackupsVal, ok := dailyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_backups expected to be basetypes.Int64Value, was: %T`, dailyBackupsAttribute))
	}

	discountForNoPublicIpv4Attribute, ok := attributes["discount_for_no_public_ipv4"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_for_no_public_ipv4 is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	discountForNoPublicIpv4Val, ok := discountForNoPublicIpv4Attribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_for_no_public_ipv4 expected to be basetypes.Float64Value, was: %T`, discountForNoPublicIpv4Attribute))
	}

	diskCostPerAdditionalGigabyteAttribute, ok := attributes["disk_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_cost_per_additional_gigabyte is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	diskCostPerAdditionalGigabyteVal, ok := diskCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, diskCostPerAdditionalGigabyteAttribute))
	}

	diskMaxAttribute, ok := attributes["disk_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_max is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	diskMaxVal, ok := diskMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_max expected to be basetypes.Int64Value, was: %T`, diskMaxAttribute))
	}

	diskMinAttribute, ok := attributes["disk_min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`disk_min is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	diskMinVal, ok := diskMinAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`disk_min expected to be basetypes.Int64Value, was: %T`, diskMinAttribute))
	}

	ipv4AddressesCostPerAddressAttribute, ok := attributes["ipv4_addresses_cost_per_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_cost_per_address is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	ipv4AddressesCostPerAddressVal, ok := ipv4AddressesCostPerAddressAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_cost_per_address expected to be basetypes.Float64Value, was: %T`, ipv4AddressesCostPerAddressAttribute))
	}

	ipv4AddressesMaxAttribute, ok := attributes["ipv4_addresses_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses_max is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	ipv4AddressesMaxVal, ok := ipv4AddressesMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses_max expected to be basetypes.Int64Value, was: %T`, ipv4AddressesMaxAttribute))
	}

	memoryCostPerAdditionalMegabyteAttribute, ok := attributes["memory_cost_per_additional_megabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_cost_per_additional_megabyte is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	memoryCostPerAdditionalMegabyteVal, ok := memoryCostPerAdditionalMegabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_cost_per_additional_megabyte expected to be basetypes.Float64Value, was: %T`, memoryCostPerAdditionalMegabyteAttribute))
	}

	memoryMaxAttribute, ok := attributes["memory_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`memory_max is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	memoryMaxVal, ok := memoryMaxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`memory_max expected to be basetypes.Int64Value, was: %T`, memoryMaxAttribute))
	}

	monthlyBackupsAttribute, ok := attributes["monthly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_backups is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	monthlyBackupsVal, ok := monthlyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_backups expected to be basetypes.Int64Value, was: %T`, monthlyBackupsAttribute))
	}

	offsiteBackupFrequencyCostAttribute, ok := attributes["offsite_backup_frequency_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backup_frequency_cost is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	offsiteBackupFrequencyCostVal, ok := offsiteBackupFrequencyCostAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backup_frequency_cost expected to be basetypes.ObjectValue, was: %T`, offsiteBackupFrequencyCostAttribute))
	}

	offsiteBackupsCostPerGigabyteAttribute, ok := attributes["offsite_backups_cost_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`offsite_backups_cost_per_gigabyte is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	offsiteBackupsCostPerGigabyteVal, ok := offsiteBackupsCostPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`offsite_backups_cost_per_gigabyte expected to be basetypes.Float64Value, was: %T`, offsiteBackupsCostPerGigabyteAttribute))
	}

	restrictedDiskValuesAttribute, ok := attributes["restricted_disk_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted_disk_values is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	restrictedDiskValuesVal, ok := restrictedDiskValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted_disk_values expected to be basetypes.ListValue, was: %T`, restrictedDiskValuesAttribute))
	}

	transferCostPerAdditionalGigabyteAttribute, ok := attributes["transfer_cost_per_additional_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_cost_per_additional_gigabyte is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	transferCostPerAdditionalGigabyteVal, ok := transferCostPerAdditionalGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_cost_per_additional_gigabyte expected to be basetypes.Float64Value, was: %T`, transferCostPerAdditionalGigabyteAttribute))
	}

	transferMaxAttribute, ok := attributes["transfer_max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`transfer_max is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	transferMaxVal, ok := transferMaxAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`transfer_max expected to be basetypes.Float64Value, was: %T`, transferMaxAttribute))
	}

	weeklyBackupsAttribute, ok := attributes["weekly_backups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_backups is missing from object`)

		return NewOptions2ValueUnknown(), diags
	}

	weeklyBackupsVal, ok := weeklyBackupsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_backups expected to be basetypes.Int64Value, was: %T`, weeklyBackupsAttribute))
	}

	if diags.HasError() {
		return NewOptions2ValueUnknown(), diags
	}

	return Options2Value{
		BackupsCostPerBackupPerGigabyte:   backupsCostPerBackupPerGigabyteVal,
		DailyBackups:                      dailyBackupsVal,
		DiscountForNoPublicIpv4:           discountForNoPublicIpv4Val,
		DiskCostPerAdditionalGigabyte:     diskCostPerAdditionalGigabyteVal,
		DiskMax:                           diskMaxVal,
		DiskMin:                           diskMinVal,
		Ipv4AddressesCostPerAddress:       ipv4AddressesCostPerAddressVal,
		Ipv4AddressesMax:                  ipv4AddressesMaxVal,
		MemoryCostPerAdditionalMegabyte:   memoryCostPerAdditionalMegabyteVal,
		MemoryMax:                         memoryMaxVal,
		MonthlyBackups:                    monthlyBackupsVal,
		OffsiteBackupFrequencyCost:        offsiteBackupFrequencyCostVal,
		OffsiteBackupsCostPerGigabyte:     offsiteBackupsCostPerGigabyteVal,
		RestrictedDiskValues:              restrictedDiskValuesVal,
		TransferCostPerAdditionalGigabyte: transferCostPerAdditionalGigabyteVal,
		TransferMax:                       transferMaxVal,
		WeeklyBackups:                     weeklyBackupsVal,
		state:                             attr.ValueStateKnown,
	}, diags
}

func NewOptions2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Options2Value {
	object, diags := NewOptions2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptions2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Options2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptions2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptions2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptions2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptions2ValueMust(Options2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Options2Type) ValueType(ctx context.Context) attr.Value {
	return Options2Value{}
}

var _ basetypes.ObjectValuable = Options2Value{}

type Options2Value struct {
	BackupsCostPerBackupPerGigabyte   basetypes.Float64Value `tfsdk:"backups_cost_per_backup_per_gigabyte"`
	DailyBackups                      basetypes.Int64Value   `tfsdk:"daily_backups"`
	DiscountForNoPublicIpv4           basetypes.Float64Value `tfsdk:"discount_for_no_public_ipv4"`
	DiskCostPerAdditionalGigabyte     basetypes.Float64Value `tfsdk:"disk_cost_per_additional_gigabyte"`
	DiskMax                           basetypes.Int64Value   `tfsdk:"disk_max"`
	DiskMin                           basetypes.Int64Value   `tfsdk:"disk_min"`
	Ipv4AddressesCostPerAddress       basetypes.Float64Value `tfsdk:"ipv4_addresses_cost_per_address"`
	Ipv4AddressesMax                  basetypes.Int64Value   `tfsdk:"ipv4_addresses_max"`
	MemoryCostPerAdditionalMegabyte   basetypes.Float64Value `tfsdk:"memory_cost_per_additional_megabyte"`
	MemoryMax                         basetypes.Int64Value   `tfsdk:"memory_max"`
	MonthlyBackups                    basetypes.Int64Value   `tfsdk:"monthly_backups"`
	OffsiteBackupFrequencyCost        basetypes.ObjectValue  `tfsdk:"offsite_backup_frequency_cost"`
	OffsiteBackupsCostPerGigabyte     basetypes.Float64Value `tfsdk:"offsite_backups_cost_per_gigabyte"`
	RestrictedDiskValues              basetypes.ListValue    `tfsdk:"restricted_disk_values"`
	TransferCostPerAdditionalGigabyte basetypes.Float64Value `tfsdk:"transfer_cost_per_additional_gigabyte"`
	TransferMax                       basetypes.Float64Value `tfsdk:"transfer_max"`
	WeeklyBackups                     basetypes.Int64Value   `tfsdk:"weekly_backups"`
	state                             attr.ValueState
}

func (v Options2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["backups_cost_per_backup_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["daily_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["discount_for_no_public_ipv4"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["disk_cost_per_additional_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["disk_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["disk_min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses_cost_per_address"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["memory_cost_per_additional_megabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["memory_max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monthly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["offsite_backup_frequency_cost"] = basetypes.ObjectType{
		AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["offsite_backups_cost_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["restricted_disk_values"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["transfer_cost_per_additional_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["transfer_max"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_backups"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.BackupsCostPerBackupPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backups_cost_per_backup_per_gigabyte"] = val

		val, err = v.DailyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_backups"] = val

		val, err = v.DiscountForNoPublicIpv4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount_for_no_public_ipv4"] = val

		val, err = v.DiskCostPerAdditionalGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_cost_per_additional_gigabyte"] = val

		val, err = v.DiskMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_max"] = val

		val, err = v.DiskMin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["disk_min"] = val

		val, err = v.Ipv4AddressesCostPerAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses_cost_per_address"] = val

		val, err = v.Ipv4AddressesMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses_max"] = val

		val, err = v.MemoryCostPerAdditionalMegabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_cost_per_additional_megabyte"] = val

		val, err = v.MemoryMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["memory_max"] = val

		val, err = v.MonthlyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_backups"] = val

		val, err = v.OffsiteBackupFrequencyCost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backup_frequency_cost"] = val

		val, err = v.OffsiteBackupsCostPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["offsite_backups_cost_per_gigabyte"] = val

		val, err = v.RestrictedDiskValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted_disk_values"] = val

		val, err = v.TransferCostPerAdditionalGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer_cost_per_additional_gigabyte"] = val

		val, err = v.TransferMax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["transfer_max"] = val

		val, err = v.WeeklyBackups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_backups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Options2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Options2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Options2Value) String() string {
	return "Options2Value"
}

func (v Options2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var offsiteBackupFrequencyCost basetypes.ObjectValue

	if v.OffsiteBackupFrequencyCost.IsNull() {
		offsiteBackupFrequencyCost = types.ObjectNull(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		)
	}

	if v.OffsiteBackupFrequencyCost.IsUnknown() {
		offsiteBackupFrequencyCost = types.ObjectUnknown(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OffsiteBackupFrequencyCost.IsNull() && !v.OffsiteBackupFrequencyCost.IsUnknown() {
		offsiteBackupFrequencyCost = types.ObjectValueMust(
			OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
			v.OffsiteBackupFrequencyCost.Attributes(),
		)
	}

	restrictedDiskValuesVal, d := types.ListValue(types.Int64Type, v.RestrictedDiskValues.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
			"daily_backups":                        basetypes.Int64Type{},
			"discount_for_no_public_ipv4":          basetypes.Float64Type{},
			"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
			"disk_max":                             basetypes.Int64Type{},
			"disk_min":                             basetypes.Int64Type{},
			"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
			"ipv4_addresses_max":                   basetypes.Int64Type{},
			"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
			"memory_max":                           basetypes.Int64Type{},
			"monthly_backups":                      basetypes.Int64Type{},
			"offsite_backup_frequency_cost": basetypes.ObjectType{
				AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
			},
			"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
			"restricted_disk_values": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
			"transfer_max":                          basetypes.Float64Type{},
			"weekly_backups":                        basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
		"daily_backups":                        basetypes.Int64Type{},
		"discount_for_no_public_ipv4":          basetypes.Float64Type{},
		"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
		"disk_max":                             basetypes.Int64Type{},
		"disk_min":                             basetypes.Int64Type{},
		"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
		"ipv4_addresses_max":                   basetypes.Int64Type{},
		"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
		"memory_max":                           basetypes.Int64Type{},
		"monthly_backups":                      basetypes.Int64Type{},
		"offsite_backup_frequency_cost": basetypes.ObjectType{
			AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		},
		"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
		"restricted_disk_values": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
		"transfer_max":                          basetypes.Float64Type{},
		"weekly_backups":                        basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"backups_cost_per_backup_per_gigabyte":  v.BackupsCostPerBackupPerGigabyte,
			"daily_backups":                         v.DailyBackups,
			"discount_for_no_public_ipv4":           v.DiscountForNoPublicIpv4,
			"disk_cost_per_additional_gigabyte":     v.DiskCostPerAdditionalGigabyte,
			"disk_max":                              v.DiskMax,
			"disk_min":                              v.DiskMin,
			"ipv4_addresses_cost_per_address":       v.Ipv4AddressesCostPerAddress,
			"ipv4_addresses_max":                    v.Ipv4AddressesMax,
			"memory_cost_per_additional_megabyte":   v.MemoryCostPerAdditionalMegabyte,
			"memory_max":                            v.MemoryMax,
			"monthly_backups":                       v.MonthlyBackups,
			"offsite_backup_frequency_cost":         offsiteBackupFrequencyCost,
			"offsite_backups_cost_per_gigabyte":     v.OffsiteBackupsCostPerGigabyte,
			"restricted_disk_values":                restrictedDiskValuesVal,
			"transfer_cost_per_additional_gigabyte": v.TransferCostPerAdditionalGigabyte,
			"transfer_max":                          v.TransferMax,
			"weekly_backups":                        v.WeeklyBackups,
		})

	return objVal, diags
}

func (v Options2Value) Equal(o attr.Value) bool {
	other, ok := o.(Options2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BackupsCostPerBackupPerGigabyte.Equal(other.BackupsCostPerBackupPerGigabyte) {
		return false
	}

	if !v.DailyBackups.Equal(other.DailyBackups) {
		return false
	}

	if !v.DiscountForNoPublicIpv4.Equal(other.DiscountForNoPublicIpv4) {
		return false
	}

	if !v.DiskCostPerAdditionalGigabyte.Equal(other.DiskCostPerAdditionalGigabyte) {
		return false
	}

	if !v.DiskMax.Equal(other.DiskMax) {
		return false
	}

	if !v.DiskMin.Equal(other.DiskMin) {
		return false
	}

	if !v.Ipv4AddressesCostPerAddress.Equal(other.Ipv4AddressesCostPerAddress) {
		return false
	}

	if !v.Ipv4AddressesMax.Equal(other.Ipv4AddressesMax) {
		return false
	}

	if !v.MemoryCostPerAdditionalMegabyte.Equal(other.MemoryCostPerAdditionalMegabyte) {
		return false
	}

	if !v.MemoryMax.Equal(other.MemoryMax) {
		return false
	}

	if !v.MonthlyBackups.Equal(other.MonthlyBackups) {
		return false
	}

	if !v.OffsiteBackupFrequencyCost.Equal(other.OffsiteBackupFrequencyCost) {
		return false
	}

	if !v.OffsiteBackupsCostPerGigabyte.Equal(other.OffsiteBackupsCostPerGigabyte) {
		return false
	}

	if !v.RestrictedDiskValues.Equal(other.RestrictedDiskValues) {
		return false
	}

	if !v.TransferCostPerAdditionalGigabyte.Equal(other.TransferCostPerAdditionalGigabyte) {
		return false
	}

	if !v.TransferMax.Equal(other.TransferMax) {
		return false
	}

	if !v.WeeklyBackups.Equal(other.WeeklyBackups) {
		return false
	}

	return true
}

func (v Options2Value) Type(ctx context.Context) attr.Type {
	return Options2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Options2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"backups_cost_per_backup_per_gigabyte": basetypes.Float64Type{},
		"daily_backups":                        basetypes.Int64Type{},
		"discount_for_no_public_ipv4":          basetypes.Float64Type{},
		"disk_cost_per_additional_gigabyte":    basetypes.Float64Type{},
		"disk_max":                             basetypes.Int64Type{},
		"disk_min":                             basetypes.Int64Type{},
		"ipv4_addresses_cost_per_address":      basetypes.Float64Type{},
		"ipv4_addresses_max":                   basetypes.Int64Type{},
		"memory_cost_per_additional_megabyte":  basetypes.Float64Type{},
		"memory_max":                           basetypes.Int64Type{},
		"monthly_backups":                      basetypes.Int64Type{},
		"offsite_backup_frequency_cost": basetypes.ObjectType{
			AttrTypes: OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx),
		},
		"offsite_backups_cost_per_gigabyte": basetypes.Float64Type{},
		"restricted_disk_values": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"transfer_cost_per_additional_gigabyte": basetypes.Float64Type{},
		"transfer_max":                          basetypes.Float64Type{},
		"weekly_backups":                        basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OffsiteBackupFrequencyCostType{}

type OffsiteBackupFrequencyCostType struct {
	basetypes.ObjectType
}

func (t OffsiteBackupFrequencyCostType) Equal(o attr.Type) bool {
	other, ok := o.(OffsiteBackupFrequencyCostType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OffsiteBackupFrequencyCostType) String() string {
	return "OffsiteBackupFrequencyCostType"
}

func (t OffsiteBackupFrequencyCostType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dailyPerGigabyteAttribute, ok := attributes["daily_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_per_gigabyte is missing from object`)

		return nil, diags
	}

	dailyPerGigabyteVal, ok := dailyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_per_gigabyte expected to be basetypes.Float64Value, was: %T`, dailyPerGigabyteAttribute))
	}

	monthlyPerGigabyteAttribute, ok := attributes["monthly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_per_gigabyte is missing from object`)

		return nil, diags
	}

	monthlyPerGigabyteVal, ok := monthlyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, monthlyPerGigabyteAttribute))
	}

	weeklyPerGigabyteAttribute, ok := attributes["weekly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_per_gigabyte is missing from object`)

		return nil, diags
	}

	weeklyPerGigabyteVal, ok := weeklyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, weeklyPerGigabyteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OffsiteBackupFrequencyCostValue{
		DailyPerGigabyte:   dailyPerGigabyteVal,
		MonthlyPerGigabyte: monthlyPerGigabyteVal,
		WeeklyPerGigabyte:  weeklyPerGigabyteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupFrequencyCostValueNull() OffsiteBackupFrequencyCostValue {
	return OffsiteBackupFrequencyCostValue{
		state: attr.ValueStateNull,
	}
}

func NewOffsiteBackupFrequencyCostValueUnknown() OffsiteBackupFrequencyCostValue {
	return OffsiteBackupFrequencyCostValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOffsiteBackupFrequencyCostValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OffsiteBackupFrequencyCostValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OffsiteBackupFrequencyCostValue Attribute Value",
				"While creating a OffsiteBackupFrequencyCostValue value, a missing attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OffsiteBackupFrequencyCostValue Attribute Type",
				"While creating a OffsiteBackupFrequencyCostValue value, an invalid attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OffsiteBackupFrequencyCostValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OffsiteBackupFrequencyCostValue Attribute Value",
				"While creating a OffsiteBackupFrequencyCostValue value, an extra attribute value was detected. "+
					"A OffsiteBackupFrequencyCostValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OffsiteBackupFrequencyCostValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	dailyPerGigabyteAttribute, ok := attributes["daily_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`daily_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	dailyPerGigabyteVal, ok := dailyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`daily_per_gigabyte expected to be basetypes.Float64Value, was: %T`, dailyPerGigabyteAttribute))
	}

	monthlyPerGigabyteAttribute, ok := attributes["monthly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monthly_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	monthlyPerGigabyteVal, ok := monthlyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monthly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, monthlyPerGigabyteAttribute))
	}

	weeklyPerGigabyteAttribute, ok := attributes["weekly_per_gigabyte"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`weekly_per_gigabyte is missing from object`)

		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	weeklyPerGigabyteVal, ok := weeklyPerGigabyteAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`weekly_per_gigabyte expected to be basetypes.Float64Value, was: %T`, weeklyPerGigabyteAttribute))
	}

	if diags.HasError() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), diags
	}

	return OffsiteBackupFrequencyCostValue{
		DailyPerGigabyte:   dailyPerGigabyteVal,
		MonthlyPerGigabyte: monthlyPerGigabyteVal,
		WeeklyPerGigabyte:  weeklyPerGigabyteVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewOffsiteBackupFrequencyCostValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OffsiteBackupFrequencyCostValue {
	object, diags := NewOffsiteBackupFrequencyCostValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOffsiteBackupFrequencyCostValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OffsiteBackupFrequencyCostType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOffsiteBackupFrequencyCostValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOffsiteBackupFrequencyCostValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOffsiteBackupFrequencyCostValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOffsiteBackupFrequencyCostValueMust(OffsiteBackupFrequencyCostValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OffsiteBackupFrequencyCostType) ValueType(ctx context.Context) attr.Value {
	return OffsiteBackupFrequencyCostValue{}
}

var _ basetypes.ObjectValuable = OffsiteBackupFrequencyCostValue{}

type OffsiteBackupFrequencyCostValue struct {
	DailyPerGigabyte   basetypes.Float64Value `tfsdk:"daily_per_gigabyte"`
	MonthlyPerGigabyte basetypes.Float64Value `tfsdk:"monthly_per_gigabyte"`
	WeeklyPerGigabyte  basetypes.Float64Value `tfsdk:"weekly_per_gigabyte"`
	state              attr.ValueState
}

func (v OffsiteBackupFrequencyCostValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["daily_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["monthly_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["weekly_per_gigabyte"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DailyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["daily_per_gigabyte"] = val

		val, err = v.MonthlyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monthly_per_gigabyte"] = val

		val, err = v.WeeklyPerGigabyte.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["weekly_per_gigabyte"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OffsiteBackupFrequencyCostValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OffsiteBackupFrequencyCostValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OffsiteBackupFrequencyCostValue) String() string {
	return "OffsiteBackupFrequencyCostValue"
}

func (v OffsiteBackupFrequencyCostValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"daily_per_gigabyte":   basetypes.Float64Type{},
		"monthly_per_gigabyte": basetypes.Float64Type{},
		"weekly_per_gigabyte":  basetypes.Float64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"daily_per_gigabyte":   v.DailyPerGigabyte,
			"monthly_per_gigabyte": v.MonthlyPerGigabyte,
			"weekly_per_gigabyte":  v.WeeklyPerGigabyte,
		})

	return objVal, diags
}

func (v OffsiteBackupFrequencyCostValue) Equal(o attr.Value) bool {
	other, ok := o.(OffsiteBackupFrequencyCostValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DailyPerGigabyte.Equal(other.DailyPerGigabyte) {
		return false
	}

	if !v.MonthlyPerGigabyte.Equal(other.MonthlyPerGigabyte) {
		return false
	}

	if !v.WeeklyPerGigabyte.Equal(other.WeeklyPerGigabyte) {
		return false
	}

	return true
}

func (v OffsiteBackupFrequencyCostValue) Type(ctx context.Context) attr.Type {
	return OffsiteBackupFrequencyCostType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OffsiteBackupFrequencyCostValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"daily_per_gigabyte":   basetypes.Float64Type{},
		"monthly_per_gigabyte": basetypes.Float64Type{},
		"weekly_per_gigabyte":  basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = SizeTypeType{}

type SizeTypeType struct {
	basetypes.ObjectType
}

func (t SizeTypeType) Equal(o attr.Type) bool {
	other, ok := o.(SizeTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SizeTypeType) String() string {
	return "SizeTypeType"
}

func (t SizeTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SizeTypeValue{
		Description: descriptionVal,
		Name:        nameVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSizeTypeValueNull() SizeTypeValue {
	return SizeTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewSizeTypeValueUnknown() SizeTypeValue {
	return SizeTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSizeTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SizeTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SizeTypeValue Attribute Value",
				"While creating a SizeTypeValue value, a missing attribute value was detected. "+
					"A SizeTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SizeTypeValue Attribute Type",
				"While creating a SizeTypeValue value, an invalid attribute value was detected. "+
					"A SizeTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SizeTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SizeTypeValue Attribute Value",
				"While creating a SizeTypeValue value, an extra attribute value was detected. "+
					"A SizeTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SizeTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSizeTypeValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewSizeTypeValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	if diags.HasError() {
		return NewSizeTypeValueUnknown(), diags
	}

	return SizeTypeValue{
		Description: descriptionVal,
		Name:        nameVal,
		Slug:        slugVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewSizeTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SizeTypeValue {
	object, diags := NewSizeTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSizeTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SizeTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSizeTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSizeTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSizeTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSizeTypeValueMust(SizeTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SizeTypeType) ValueType(ctx context.Context) attr.Value {
	return SizeTypeValue{}
}

var _ basetypes.ObjectValuable = SizeTypeValue{}

type SizeTypeValue struct {
	Description basetypes.StringValue `tfsdk:"description"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Slug        basetypes.StringValue `tfsdk:"slug"`
	state       attr.ValueState
}

func (v SizeTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SizeTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SizeTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SizeTypeValue) String() string {
	return "SizeTypeValue"
}

func (v SizeTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description": v.Description,
			"name":        v.Name,
			"slug":        v.Slug,
		})

	return objVal, diags
}

func (v SizeTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(SizeTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	return true
}

func (v SizeTypeValue) Type(ctx context.Context) attr.Type {
	return SizeTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SizeTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description": basetypes.StringType{},
		"name":        basetypes.StringType{},
		"slug":        basetypes.StringType{},
	}
}
